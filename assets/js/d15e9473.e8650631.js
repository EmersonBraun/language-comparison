"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[809],{2222(n,e,a){a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"classes-oop","title":"Classes & OOP","description":"Classes, inheritance, interfaces, and polymorphism compared across 12 programming languages","source":"@site/docs/classes-oop.md","sourceDirName":".","slug":"/classes-oop","permalink":"/language-comparison/docs/classes-oop","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/classes-oop.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"description":"Classes, inheritance, interfaces, and polymorphism compared across 12 programming languages","keywords":["classes","OOP","inheritance","interfaces","polymorphism","object-oriented"]},"sidebar":"tutorialSidebar","previous":{"title":"Maps & Dictionaries","permalink":"/language-comparison/docs/maps-dictionaries"},"next":{"title":"Generics & Templates","permalink":"/language-comparison/docs/generics-templates"}}');var t=a(4848),i=a(8453),o=a(6153);const r={sidebar_position:15,description:"Classes, inheritance, interfaces, and polymorphism compared across 12 programming languages",keywords:["classes","OOP","inheritance","interfaces","polymorphism","object-oriented"]},l="Classes & OOP",c={},m=[{value:"Class Definition and Instantiation",id:"class-definition-and-instantiation",level:2},{value:"Interfaces and Polymorphism",id:"interfaces-and-polymorphism",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"classes--oop",children:"Classes & OOP"})}),"\n",(0,t.jsx)(e.p,{children:"Object-Oriented Programming concepts vary across languages. Here's how classes, inheritance, interfaces, and polymorphism work in different languages."}),"\n","\n",(0,t.jsx)(e.h2,{id:"class-definition-and-instantiation",children:"Class Definition and Instantiation"}),"\n",(0,t.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// ES6 Classes\nclass Person {\n  constructor(name, age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  greet() {\n      return `Hello, I\'m ${this.name}`;\n  }\n}\n\n// Instantiation\nconst person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  constructor(name, age, school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  study() {\n      return `${this.name} is studying`;\n  }\n}'},{name:"PHP",lang:"php",code:'<?php\n// Class definition\nclass Person {\n  private $name;\n  private $age;\n  \n  public function __construct($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n  }\n  \n  public function greet() {\n      return "Hello, I\'m " . $this->name;\n  }\n}\n\n// Instantiation\n$person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  private $school;\n  \n  public function __construct($name, $age, $school) {\n      parent::__construct($name, $age);\n      $this->school = $school;\n  }\n  \n  public function study() {\n      return $this->name . " is studying";\n  }\n}'},{name:"Rust",lang:"rust",code:'// Structs with impl blocks\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n      Person { name, age }\n  }\n  \n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}\n\n// Traits (similar to interfaces)\ntrait Greetable {\n  fn greet(&self) -> String;\n}\n\nimpl Greetable for Person {\n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}'},{name:"Go",lang:"go",code:'// Structs with methods\ntype Person struct {\n  name string\n  age  int\n}\n\nfunc NewPerson(name string, age int) *Person {\n  return &Person{name: name, age: age}\n}\n\nfunc (p *Person) Greet() string {\n  return fmt.Sprintf("Hello, I\'m %s", p.name)\n}\n\n// Interfaces\ntype Greetable interface {\n  Greet() string\n}\n\n// Embedding (composition)\ntype Student struct {\n  Person\n  school string\n}'},{name:"Python",lang:"python",code:'# Class definition\nclass Person:\n  def __init__(self, name, age):\n      self.name = name\n      self.age = age\n  \n  def greet(self):\n      return f"Hello, I\'m {self.name}"\n\n# Instantiation\nperson = Person("John", 30)\n\n# Inheritance\nclass Student(Person):\n  def __init__(self, name, age, school):\n      super().__init__(name, age)\n      self.school = school\n  \n  def study(self):\n      return f"{self.name} is studying"'},{name:"Zig",lang:"zig",code:'// Structs with methods\nconst Person = struct {\n  name: []const u8,\n  age: u32,\n  \n  pub fn init(name: []const u8, age: u32) Person {\n      return Person{\n          .name = name,\n          .age = age,\n      };\n  }\n  \n  pub fn greet(self: Person) []const u8 {\n      return "Hello, I\'m " ++ self.name;\n  }\n};\n\n// Interfaces (using function pointers)\nconst Greetable = struct {\n  greet: fn (*const anyopaque) []const u8,\n};'},{name:"C#",lang:"csharp",code:'// Class definition\npublic class Person\n{\n  private string name;\n  private int age;\n  \n  public Person(string name, int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public virtual string Greet()\n  {\n      return $"Hello, I\'m {name}";\n  }\n}\n\n// Instantiation\nvar person = new Person("John", 30);\n\n// Inheritance\npublic class Student : Person\n{\n  private string school;\n  \n  public Student(string name, int age, string school) \n      : base(name, age)\n  {\n      this.school = school;\n  }\n  \n  public override string Greet()\n  {\n      return base.Greet() + $" and I study at {school}";\n  }\n}'},{name:"C++",lang:"cpp",code:'// Class definition\nclass Person {\nprivate:\n  std::string name;\n  int age;\n  \npublic:\n  Person(const std::string& name, int age) \n      : name(name), age(age) {}\n  \n  virtual std::string greet() const {\n      return "Hello, I\'m " + name;\n  }\n  \n  virtual ~Person() = default;\n};\n\n// Instantiation\nPerson person("John", 30);\n\n// Inheritance\nclass Student : public Person {\nprivate:\n  std::string school;\n  \npublic:\n  Student(const std::string& name, int age, \n          const std::string& school)\n      : Person(name, age), school(school) {}\n  \n  std::string greet() const override {\n      return Person::greet() + " and I study at " + school;\n  }\n};'},{name:"C",lang:"c",code:'// Struct with function pointers (OOP-like)\ntypedef struct {\n  char name[50];\n  int age;\n  void (*greet)(struct Person*);\n} Person;\n\nvoid person_greet(Person* self) {\n  printf("Hello, I\'m %s\\n", self->name);\n}\n\nPerson* person_new(const char* name, int age) {\n  Person* p = malloc(sizeof(Person));\n  strcpy(p->name, name);\n  p->age = age;\n  p->greet = person_greet;\n  return p;\n}'},{name:"Java",lang:"java",code:'// Class definition\npublic class Person {\n  private String name;\n  private int age;\n  \n  public Person(String name, int age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public String greet() {\n      return "Hello, I\'m " + name;\n  }\n}\n\n// Instantiation\nPerson person = new Person("John", 30);\n\n// Inheritance\npublic class Student extends Person {\n  private String school;\n  \n  public Student(String name, int age, String school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  @Override\n  public String greet() {\n      return super.greet() + " and I study at " + school;\n  }\n}'},{name:"Ruby",lang:"ruby",code:'# Class definition\nclass Person\n  def initialize(name, age)\n      @name = name\n      @age = age\n  end\n  \n  def greet\n      "Hello, I\'m #{@name}"\n  end\nend\n\n# Instantiation\nperson = Person.new("John", 30)\n\n# Inheritance\nclass Student < Person\n  def initialize(name, age, school)\n      super(name, age)\n      @school = school\n  end\n  \n  def study\n      "#{@name} is studying"\n  end\nend'},{name:"Swift",lang:"swift",code:'// Class definition\nclass Person {\n  private var name: String\n  private var age: Int\n  \n  init(name: String, age: Int) {\n      self.name = name\n      self.age = age\n  }\n  \n  func greet() -> String {\n      "Hello, I\'m \\(name)"\n  }\n}\n\n// Instantiation\nlet person = Person(name: "John", age: 30)\n\n// Inheritance\nclass Student: Person {\n  private var school: String\n  \n  init(name: String, age: Int, school: String) {\n      self.school = school\n      super.init(name: name, age: age)\n  }\n  \n  override func greet() -> String {\n      super.greet() + " and I study at \\(school)"\n  }\n}'}]}),"\n",(0,t.jsx)(e.h2,{id:"interfaces-and-polymorphism",children:"Interfaces and Polymorphism"}),"\n",(0,t.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// No native interfaces, use duck typing\nclass Dog {\n  makeSound() {\n      return "Woof!";\n  }\n}\n\nclass Cat {\n  makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(animal) {\n  return animal.makeSound();\n}\n\n// TypeScript interfaces\ninterface Animal {\n  makeSound(): string;\n}'},{name:"PHP",lang:"php",code:'<?php\n// Interfaces\ninterface Animal {\n  public function makeSound(): string;\n}\n\nclass Dog implements Animal {\n  public function makeSound(): string {\n      return "Woof!";\n  }\n}\n\nclass Cat implements Animal {\n  public function makeSound(): string {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(Animal $animal): string {\n  return $animal->makeSound();\n}'},{name:"Rust",lang:"rust",code:'// Traits (interfaces)\ntrait Animal {\n  fn make_sound(&self) -> String;\n}\n\nstruct Dog;\nimpl Animal for Dog {\n  fn make_sound(&self) -> String {\n      "Woof!".to_string()\n  }\n}\n\nstruct Cat;\nimpl Animal for Cat {\n  fn make_sound(&self) -> String {\n      "Meow!".to_string()\n  }\n}\n\n// Polymorphism\nfn animal_sound(animal: &dyn Animal) -> String {\n  animal.make_sound()\n}'},{name:"Go",lang:"go",code:'// Interfaces\ntype Animal interface {\n  MakeSound() string\n}\n\ntype Dog struct{}\nfunc (d Dog) MakeSound() string {\n  return "Woof!"\n}\n\ntype Cat struct{}\nfunc (c Cat) MakeSound() string {\n  return "Meow!"\n}\n\n// Polymorphism\nfunc AnimalSound(a Animal) string {\n  return a.MakeSound()\n}'},{name:"Python",lang:"python",code:'# Duck typing (no explicit interfaces)\nclass Dog:\n  def make_sound(self):\n      return "Woof!"\n\nclass Cat:\n  def make_sound(self):\n      return "Meow!"\n\n# Polymorphism\ndef animal_sound(animal):\n  return animal.make_sound()\n\n# ABC (Abstract Base Classes)\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n  @abstractmethod\n  def make_sound(self):\n      pass'},{name:"Zig",lang:"zig",code:'// Function pointers (interface-like)\nconst Animal = struct {\n  make_sound: fn (*const anyopaque) []const u8,\n};\n\nconst Dog = struct {\n  pub fn make_sound(self: *const Dog) []const u8 {\n      return "Woof!";\n  }\n};\n\n// Polymorphism through function pointers\nfn animal_sound(animal: Animal) []const u8 {\n  return animal.make_sound(animal.self);\n}'},{name:"C#",lang:"csharp",code:'// Interfaces\npublic interface IAnimal\n{\n  string MakeSound();\n}\n\npublic class Dog : IAnimal\n{\n  public string MakeSound() => "Woof!";\n}\n\npublic class Cat : IAnimal\n{\n  public string MakeSound() => "Meow!";\n}\n\n// Polymorphism\npublic static string AnimalSound(IAnimal animal)\n{\n  return animal.MakeSound();\n}'},{name:"C++",lang:"cpp",code:'// Abstract classes\nclass Animal {\npublic:\n  virtual std::string makeSound() = 0;\n  virtual ~Animal() = default;\n};\n\nclass Dog : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Woof!";\n  }\n};\n\nclass Cat : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Meow!";\n  }\n};\n\n// Polymorphism\nstd::string animalSound(Animal* animal) {\n  return animal->makeSound();\n}'},{name:"C",lang:"c",code:'// Function pointers in structs\ntypedef struct {\n  void* self;\n  char* (*makeSound)(void*);\n} Animal;\n\nchar* dog_makeSound(void* self) {\n  return "Woof!";\n}\n\nchar* cat_makeSound(void* self) {\n  return "Meow!";\n}\n\n// Polymorphism\nchar* animalSound(Animal* animal) {\n  return animal->makeSound(animal->self);\n}'},{name:"Java",lang:"java",code:'// Interfaces\npublic interface Animal {\n  String makeSound();\n}\n\npublic class Dog implements Animal {\n  @Override\n  public String makeSound() {\n      return "Woof!";\n  }\n}\n\npublic class Cat implements Animal {\n  @Override\n  public String makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\npublic static String animalSound(Animal animal) {\n  return animal.makeSound();\n}'},{name:"Ruby",lang:"ruby",code:'# Modules as interfaces\nmodule Animal\n  def make_sound\n      raise NotImplementedError\n  end\nend\n\nclass Dog\n  include Animal\n  \n  def make_sound\n      "Woof!"\n  end\nend\n\nclass Cat\n  include Animal\n  \n  def make_sound\n      "Meow!"\n  end\nend\n\n# Polymorphism\ndef animal_sound(animal)\n  animal.make_sound\nend'},{name:"Swift",lang:"swift",code:'// Protocols (interfaces)\nprotocol Animal {\n  func makeSound() -> String\n}\n\nclass Dog: Animal {\n  func makeSound() -> String {\n      "Woof!"\n  }\n}\n\nclass Cat: Animal {\n  func makeSound() -> String {\n      "Meow!"\n  }\n}\n\n// Polymorphism\nfunc animalSound(_ animal: Animal) -> String {\n  animal.makeSound()\n}'}]}),"\n",(0,t.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Inheritance models"})," \u2014 Java, C#, C++, PHP, Ruby, Swift, and JavaScript use class-based single inheritance with ",(0,t.jsx)(e.code,{children:"extends"})," or ",(0,t.jsx)(e.code,{children:":"})," syntax; for example, ",(0,t.jsx)(e.code,{children:"class Student extends Person"})," in Java or ",(0,t.jsx)(e.code,{children:"class Student(Person)"})," in Python. Go rejects inheritance entirely and uses embedding instead: ",(0,t.jsx)(e.code,{children:"type Student struct { Person; school string }"})," embeds Person's fields and methods directly. Rust has no inheritance at all\u2014only traits that types implement. Choose Go or Rust when you want composition over hierarchy; choose Java/C#/Swift when you need clear class taxonomies and method overriding."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Interface patterns"})," \u2014 Java, C#, Swift, and PHP require explicit ",(0,t.jsx)(e.code,{children:"implements"})," declarations: ",(0,t.jsx)(e.code,{children:"class Dog implements Animal"}),". Go uses structural typing: any type with a ",(0,t.jsx)(e.code,{children:"MakeSound() string"})," method satisfies ",(0,t.jsx)(e.code,{children:"type Animal interface { MakeSound() string }"})," without declaring it. Python and Ruby rely on duck typing\u2014if it has ",(0,t.jsx)(e.code,{children:"make_sound()"}),", it works. Rust's traits work like interfaces: ",(0,t.jsx)(e.code,{children:"impl Animal for Dog { fn make_sound(&self) -> String { ... } }"}),". C and Zig simulate interfaces via structs of function pointers. Prefer Go-style implicit interfaces for flexibility; prefer explicit interfaces when you want compile-time contract enforcement."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"OOP philosophy"})," \u2014 Traditional OOP (Java, C#, C++) centers on classes, inheritance hierarchies, and ",(0,t.jsx)(e.code,{children:"virtual"}),"/",(0,t.jsx)(e.code,{children:"override"}),' for polymorphism. Go and Rust favor composition and traits: "prefer composition over inheritance." JavaScript and Python are multi-paradigm\u2014you can use classes or avoid them entirely. If you\'re building domain models with clear hierarchies (e.g., ',(0,t.jsx)(e.code,{children:"Vehicle"})," \u2192 ",(0,t.jsx)(e.code,{children:"Car"})," \u2192 ",(0,t.jsx)(e.code,{children:"ElectricCar"}),"), Java/C#/Swift excel. If you want flat, composable designs with minimal ceremony, choose Go or Rust."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Memory and lifecycle"})," \u2014 C++ and Rust require explicit attention to object lifecycle: C++ uses ",(0,t.jsx)(e.code,{children:"virtual"})," destructors and RAII; Rust's ownership prevents dangling references. Java, C#, PHP, Ruby, Python, and JavaScript use garbage collection, so you rarely manage object lifetime. Go uses lightweight GC. For systems programming or performance-critical code, Rust and C++ give you control; for rapid development, garbage-collected languages reduce cognitive load."]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);