"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[70],{4624(n,e,r){r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"operators","title":"Operators","description":"Arithmetic, comparison, logical, and bitwise operators compared across 12 languages","source":"@site/docs/operators.md","sourceDirName":".","slug":"/operators","permalink":"/language-comparison/docs/operators","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/operators.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"description":"Arithmetic, comparison, logical, and bitwise operators compared across 12 languages","keywords":["operators","arithmetic","comparison","logical","bitwise","null coalescing"]},"sidebar":"tutorialSidebar","previous":{"title":"Variables & Types","permalink":"/language-comparison/docs/variables-types"},"next":{"title":"Constants & Enums","permalink":"/language-comparison/docs/constants-enums"}}');var i=r(4848),a=r(8453),s=r(6153);const o={sidebar_position:4,description:"Arithmetic, comparison, logical, and bitwise operators compared across 12 languages",keywords:["operators","arithmetic","comparison","logical","bitwise","null coalescing"]},l="Operators",c={},d=[{value:"Arithmetic &amp; Assignment Operators",id:"arithmetic--assignment-operators",level:2},{value:"Comparison &amp; Logical Operators",id:"comparison--logical-operators",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"operators",children:"Operators"})}),"\n",(0,i.jsx)(e.p,{children:"Operators are symbols that perform operations on values. Here's how different languages handle arithmetic, comparison, logical, and bitwise operators."}),"\n","\n",(0,i.jsx)(e.h2,{id:"arithmetic--assignment-operators",children:"Arithmetic & Assignment Operators"}),"\n",(0,i.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Arithmetic\n5 + 3;    // 8  (addition)\n5 - 3;    // 2  (subtraction)\n5 * 3;    // 15 (multiplication)\n5 / 3;    // 1.6667 (division)\n5 % 3;    // 2  (modulo)\n5 ** 3;   // 125 (exponentiation)\n\n// Increment / Decrement\nlet x = 5;\nx++;      // 6 (post-increment)\n++x;      // 7 (pre-increment)\nx--;      // 6 (post-decrement)\n\n// Assignment\nx += 3;   // x = x + 3\nx -= 2;   // x = x - 2\nx *= 4;   // x = x * 4\nx /= 2;   // x = x / 2\nx %= 3;   // x = x % 3\nx **= 2;  // x = x ** 2"},{name:"PHP",lang:"php",code:'<?php\n// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1.6667\n5 % 3;    // 2\n5 ** 3;   // 125\n\n// Increment / Decrement\n$x = 5;\n$x++;     // 6\n++$x;     // 7\n$x--;     // 6\n\n// Assignment\n$x += 3;\n$x -= 2;\n$x *= 4;\n$x /= 2;\n$x %= 3;\n$x **= 2;\n\n// String concatenation\n$str = "Hello" . " " . "World";\n$str .= "!";  // append'},{name:"Rust",lang:"rust",code:"// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1 (integer division)\n5.0 / 3.0; // 1.6667 (float)\n5 % 3;    // 2\n\n// No increment/decrement operators\nlet mut x = 5;\nx += 1;   // instead of x++\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\nx /= 2;\nx %= 3;\n\n// No implicit type coercion\n// 5 + 3.0  // compile error\n5 as f64 + 3.0;  // OK\n\n// Overflow handling\n5_i32.checked_add(3);   // Some(8)\ni32::MAX.checked_add(1); // None"},{name:"Go",lang:"go",code:'// Arithmetic\n5 + 3    // 8\n5 - 3    // 2\n5 * 3    // 15\n5 / 3    // 1 (integer division)\n5.0 / 3.0 // 1.6667\n5 % 3    // 2\n\n// Increment / Decrement (statements only)\nx := 5\nx++      // 6 (no pre-increment)\nx--      // 5 (no pre-decrement)\n// y := x++  // error: not an expression\n\n// Assignment\nx += 3\nx -= 2\nx *= 4\nx /= 2\nx %= 3\n\n// No exponentiation operator\nimport "math"\nmath.Pow(5, 3)  // 125.0'},{name:"Python",lang:"python",code:'# Arithmetic\n5 + 3     # 8\n5 - 3     # 2\n5 * 3     # 15\n5 / 3     # 1.6667 (always float)\n5 // 3    # 1 (floor division)\n5 % 3     # 2\n5 ** 3    # 125 (exponentiation)\n\n# No increment/decrement operators\nx = 5\nx += 1    # instead of x++\n\n# Assignment\nx += 3\nx -= 2\nx *= 4\nx /= 2   # result is float\nx //= 3\nx %= 3\nx **= 2\n\n# Walrus operator (Python 3.8+)\nif (n := len(items)) > 10:\n  print(f"List is too long ({n} elements)")'},{name:"Zig",lang:"zig",code:"// Arithmetic\nconst a: i32 = 5 + 3;   // 8\nconst b: i32 = 5 - 3;   // 2\nconst c: i32 = 5 * 3;   // 15\nconst d: i32 = @divTrunc(5, 3); // 1\nconst e: i32 = @mod(5, 3);      // 2\n\n// No increment/decrement operators\nvar x: i32 = 5;\nx += 1;\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\n\n// Overflow-safe by default\n// x = x + 1;  // panics on overflow in debug\nx +%= 1;  // wrapping add (no panic)\n\n// Saturating arithmetic\nx +|= 1;  // saturating add"},{name:"C#",lang:"csharp",code:'// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1 (integer division)\n5.0 / 3;  // 1.6667\n5 % 3;    // 2\nMath.Pow(5, 3);  // 125\n\n// Increment / Decrement\nint x = 5;\nx++;      // 6\n++x;      // 7\nx--;      // 6\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\nx /= 2;\nx %= 3;\n\n// Null-coalescing assignment\nstring? name = null;\nname ??= "default";'},{name:"C++",lang:"cpp",code:"// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1 (integer division)\n5.0 / 3;  // 1.6667\n5 % 3;    // 2\npow(5, 3); // 125\n\n// Increment / Decrement\nint x = 5;\nx++;      // 6\n++x;      // 7  (prefer pre-increment)\nx--;      // 6\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\nx /= 2;\nx %= 3;"},{name:"C",lang:"c",code:"// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1 (integer division)\n5.0 / 3;  // 1.6667\n5 % 3;    // 2\npow(5, 3); // 125.0 (from math.h)\n\n// Increment / Decrement\nint x = 5;\nx++;      // 6\n++x;      // 7\nx--;      // 6\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\nx /= 2;\nx %= 3;"},{name:"Java",lang:"java",code:"// Arithmetic\n5 + 3;    // 8\n5 - 3;    // 2\n5 * 3;    // 15\n5 / 3;    // 1 (integer division)\n5.0 / 3;  // 1.6667\n5 % 3;    // 2\nMath.pow(5, 3);  // 125.0\n\n// Increment / Decrement\nint x = 5;\nx++;      // 6\n++x;      // 7\nx--;      // 6\n\n// Assignment\nx += 3;\nx -= 2;\nx *= 4;\nx /= 2;\nx %= 3;"},{name:"Ruby",lang:"ruby",code:"# Arithmetic\n5 + 3     # 8\n5 - 3     # 2\n5 * 3     # 15\n5 / 3     # 1 (integer division)\n5.0 / 3   # 1.6667\n5 % 3     # 2\n5 ** 3    # 125\n\n# No increment/decrement operators\nx = 5\nx += 1    # instead of x++\n\n# Assignment\nx += 3\nx -= 2\nx *= 4\nx /= 2\nx %= 3\nx **= 2\n\n# Integer methods\n5.even?   # false\n5.odd?    # true\n-5.abs    # 5"},{name:"Swift",lang:"swift",code:"// Arithmetic\n5 + 3     // 8\n5 - 3     // 2\n5 * 3     // 15\n5 / 3     // 1 (integer division)\n5.0 / 3   // 1.6667\n5 % 3     // 2\npow(5.0, 3.0)  // 125.0\n\n// No increment/decrement (removed in Swift 3)\nvar x = 5\nx += 1    // instead of x++\n\n// Assignment\nx += 3\nx -= 2\nx *= 4\nx /= 2\nx %= 3\n\n// Overflow operators\nvar y: Int8 = 127\ny = y &+ 1   // -128 (wrapping)"}]}),"\n",(0,i.jsx)(e.h2,{id:"comparison--logical-operators",children:"Comparison & Logical Operators"}),"\n",(0,i.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Comparison\n5 == "5";     // true  (loose equality)\n5 === "5";    // false (strict equality)\n5 != "5";     // false (loose inequality)\n5 !== "5";    // true  (strict inequality)\n5 > 3;        // true\n5 >= 5;       // true\n5 < 10;       // true\n5 <= 5;       // true\n\n// Logical\ntrue && false;   // false (AND)\ntrue || false;   // true  (OR)\n!true;           // false (NOT)\n\n// Nullish coalescing\nnull ?? "default";    // "default"\nundefined ?? "default"; // "default"\n0 ?? "default";       // 0\n\n// Optional chaining\nuser?.address?.city;\narr?.[0];\nfunc?.();'},{name:"PHP",lang:"php",code:'<?php\n// Comparison\n5 == "5";     // true  (loose)\n5 === "5";    // false (strict)\n5 != "5";     // false\n5 !== "5";    // true\n5 > 3;        // true\n5 <=> 3;      // 1 (spaceship operator)\n\n// Logical\ntrue && false;   // false\ntrue || false;   // true\n!true;           // false\ntrue and false;  // false (lower precedence)\ntrue or false;   // true\n\n// Null coalescing\n$name = $user ?? "default";\n$name ??= "default";  // PHP 7.4+\n\n// Null safe operator (PHP 8.0+)\n$city = $user?->address?->city;'},{name:"Rust",lang:"rust",code:'// Comparison (must be same type)\n5 == 5;     // true\n5 != 3;     // true\n5 > 3;      // true\n5 >= 5;     // true\n5 < 10;     // true\n5 <= 5;     // true\n\n// Logical\ntrue && false;   // false\ntrue || false;   // true\n!true;           // false\n\n// No null - use Option\nlet x: Option<i32> = Some(5);\nlet y: Option<i32> = None;\n\n// Unwrap with default\nx.unwrap_or(0);        // 5\ny.unwrap_or(0);        // 0\n\n// if let (pattern matching)\nif let Some(value) = x {\n  println!("{}", value);\n}'},{name:"Go",lang:"go",code:'// Comparison\n5 == 5     // true\n5 != 3     // true\n5 > 3      // true\n5 >= 5     // true\n5 < 10     // true\n5 <= 5     // true\n\n// Logical\ntrue && false   // false\ntrue || false   // true\n!true           // false\n\n// No ternary operator\n// Use if/else instead\nvar result string\nif x > 0 {\n  result = "positive"\n} else {\n  result = "non-positive"\n}\n\n// No null coalescing\n// Check nil explicitly\nif value != nil {\n  // use value\n}'},{name:"Python",lang:"python",code:'# Comparison\n5 == 5      # True\n5 != 3      # True\n5 > 3       # True\n5 >= 5      # True\n5 < 10      # True\n5 <= 5      # True\n5 is 5      # True (identity check)\n\n# Chained comparisons\n1 < x < 10         # True if x between 1 and 10\na == b == c         # True if all equal\n\n# Logical\nTrue and False   # False\nTrue or False    # True\nnot True         # False\n\n# Ternary\nresult = "yes" if condition else "no"\n\n# Truthiness\nbool(0)      # False\nbool("")     # False\nbool(None)   # False\nbool([])     # False\nbool(1)      # True'},{name:"Zig",lang:"zig",code:'// Comparison\nconst a = (5 == 5);   // true\nconst b = (5 != 3);   // true\nconst c = (5 > 3);    // true\nconst d = (5 >= 5);   // true\nconst e = (5 < 10);   // true\nconst f = (5 <= 5);   // true\n\n// Logical\nconst g = true and false;  // false\nconst h = true or false;   // true\nconst i = !true;           // false\n\n// Optional handling\nvar x: ?i32 = 42;\nvar y: ?i32 = null;\n\n// orelse (null coalescing)\nconst val = x orelse 0;    // 42\nconst val2 = y orelse 0;   // 0\n\n// if with optionals\nif (x) |value| {\n  std.debug.print("{d}\\n", .{value});\n}'},{name:"C#",lang:"csharp",code:'// Comparison\n5 == 5;     // true\n5 != 3;     // true\n5 > 3;      // true\n5 >= 5;     // true\n\n// Logical\ntrue && false;   // false\ntrue || false;   // true\n!true;           // false\n\n// Ternary\nvar result = x > 0 ? "positive" : "non-positive";\n\n// Null-coalescing\nstring name = user ?? "default";\nstring city = user?.Address?.City ?? "unknown";\n\n// Null-conditional\nint? length = text?.Length;\n\n// Pattern matching operators (C# 9+)\nif (x is > 0 and < 100) { }\nif (x is not null) { }'},{name:"C++",lang:"cpp",code:'// Comparison\n5 == 5;     // true\n5 != 3;     // true\n5 > 3;      // true\n5 >= 5;     // true\n(5 <=> 3);  // strong_ordering::greater (C++20)\n\n// Logical\ntrue && false;   // false\ntrue || false;   // true\n!true;           // false\n\n// Ternary\nauto result = x > 0 ? "positive" : "non-positive";\n\n// No null coalescing\n// Use std::optional (C++17)\nstd::optional<int> x = 42;\nint val = x.value_or(0);  // 42'},{name:"C",lang:"c",code:"// Comparison\n5 == 5;     // 1 (true)\n5 != 3;     // 1\n5 > 3;      // 1\n5 >= 5;     // 1\n\n// Logical\n1 && 0;     // 0 (false)\n1 || 0;     // 1 (true)\n!1;         // 0 (false)\n\n// Ternary\nint result = x > 0 ? 1 : -1;\n\n// Bitwise\n5 & 3;      // 1  (AND)\n5 | 3;      // 7  (OR)\n5 ^ 3;      // 6  (XOR)\n~5;         // -6 (NOT)\n5 << 1;     // 10 (left shift)\n5 >> 1;     // 2  (right shift)"},{name:"Java",lang:"java",code:'// Comparison\n5 == 5;        // true (primitives)\n"a".equals("a"); // true (objects)\n5 != 3;        // true\n5 > 3;         // true\n\n// Logical\ntrue && false;   // false\ntrue || false;   // true\n!true;           // false\n\n// Ternary\nString result = x > 0 ? "positive" : "non-positive";\n\n// instanceof (type check)\nif (obj instanceof String s) {\n  // s is already cast (Java 16+)\n  System.out.println(s.length());\n}'},{name:"Ruby",lang:"ruby",code:'# Comparison\n5 == 5      # true\n5 != 3      # true\n5 > 3       # true\n5 >= 5      # true\n5 <=> 3     # 1 (spaceship)\n5 === 5     # true (case equality)\n\n# Logical\ntrue && false   # false\ntrue || false   # true\n!true           # false\ntrue and false  # false (lower precedence)\n\n# Ternary\nresult = x > 0 ? "positive" : "non-positive"\n\n# Safe navigation\ncity = user&.address&.city\n\n# Or-assign\nname ||= "default"  # assign if nil/false'},{name:"Swift",lang:"swift",code:'// Comparison\n5 == 5     // true\n5 != 3     // true\n5 > 3      // true\n5 >= 5     // true\n\n// Logical\ntrue && false   // false\ntrue || false   // true\n!true           // false\n\n// Ternary\nlet result = x > 0 ? "positive" : "non-positive"\n\n// Nil-coalescing\nlet name = optionalName ?? "default"\n\n// Optional chaining\nlet city = user?.address?.city\n\n// Nil-coalescing assignment\nvar name: String? = nil\nname = name ?? "default"'}]}),"\n",(0,i.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Operator overloading is language-dependent"})," -- C++ and Swift allow custom operators for user-defined types; Rust uses traits like ",(0,i.jsx)(e.code,{children:"Add"})," and ",(0,i.jsx)(e.code,{children:"Sub"})," for overloading. Python allows ",(0,i.jsx)(e.code,{children:"__add__"}),", ",(0,i.jsx)(e.code,{children:"__sub__"}),", and similar methods to define operator behavior. Go and Java forbid operator overloading for user types, so you use methods instead (e.g., ",(0,i.jsx)(e.code,{children:"a.Add(b)"})," in Go). If you need expressive numeric or domain-specific operators (e.g., vector math), prefer C++, Rust, Swift, or Python; if you want simpler, more predictable semantics, Go or Java may be better."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsxs)(e.strong,{children:["Null coalescing (",(0,i.jsx)(e.code,{children:"??"}),") and optional chaining (",(0,i.jsx)(e.code,{children:"?."}),")"]})," -- JavaScript, C#, Swift, PHP 8+, and Ruby support ",(0,i.jsx)(e.code,{children:"??"})," for default values when a value is null/undefined and ",(0,i.jsx)(e.code,{children:"?."})," for safe property access. For example, ",(0,i.jsx)(e.code,{children:'user?.address?.city ?? "unknown"'})," avoids null pointer errors. Go and Rust have no null; Go uses explicit nil checks; Rust uses ",(0,i.jsx)(e.code,{children:"Option"})," with ",(0,i.jsx)(e.code,{children:"unwrap_or(0)"})," or ",(0,i.jsx)(e.code,{children:"orelse 0"})," in Zig. C and Java lack built-in equivalents and rely on manual checks or libraries. When working with nullable data, prefer languages with first-class null handling to reduce boilerplate and bugs."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Overflow behavior differs"})," -- Zig panics on overflow in debug builds and wraps in release; Rust offers ",(0,i.jsx)(e.code,{children:"checked_add"}),", ",(0,i.jsx)(e.code,{children:"wrapping_add"}),", and ",(0,i.jsx)(e.code,{children:"saturating_add"})," so you choose the behavior. C and C++ have undefined behavior on integer overflow, which can lead to security issues. JavaScript and Python use arbitrary-precision integers, so overflow is effectively absent. For safe numeric code, use Rust's checked APIs or Zig's explicit operators; avoid relying on C/C++ overflow semantics."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Integer division semantics"})," -- Python 3's ",(0,i.jsx)(e.code,{children:"/"})," always returns a float (",(0,i.jsx)(e.code,{children:"5 / 3"})," is ",(0,i.jsx)(e.code,{children:"1.666..."}),"); ",(0,i.jsx)(e.code,{children:"//"})," is floor division for integers. C, Go, Rust, and Java use truncating division for integers (",(0,i.jsx)(e.code,{children:"5 / 3"})," is ",(0,i.jsx)(e.code,{children:"1"}),"). This affects portability when moving numeric code between languages. For consistency, use explicit floor division (",(0,i.jsx)(e.code,{children:"//"})," in Python, ",(0,i.jsx)(e.code,{children:"@divTrunc"})," in Zig) or cast to float when you need fractional results. When porting algorithms, double-check division semantics to avoid off-by-one or rounding errors."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Increment/decrement operators are absent in some languages"})," -- Rust, Python, Swift, and Zig omit ",(0,i.jsx)(e.code,{children:"++"})," and ",(0,i.jsx)(e.code,{children:"--"}),"; Go has them but only as statements (e.g., ",(0,i.jsx)(e.code,{children:"x++"}),"), not expressions. These languages prefer explicit ",(0,i.jsx)(e.code,{children:"x += 1"})," for clarity and to avoid pre/post-increment confusion (e.g., ",(0,i.jsx)(e.code,{children:"i++"})," vs ",(0,i.jsx)(e.code,{children:"++i"}),"). C, C++, C#, Java, JavaScript, and PHP retain ",(0,i.jsx)(e.code,{children:"++"}),"/",(0,i.jsx)(e.code,{children:"--"}),". If you switch between languages, default to ",(0,i.jsx)(e.code,{children:"x += 1"})," where available to avoid portability issues and subtle bugs."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}}}]);