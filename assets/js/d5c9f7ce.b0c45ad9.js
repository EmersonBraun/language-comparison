"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[183],{2406(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>f});const i=JSON.parse('{"id":"file-io","title":"File I/O","description":"File reading, writing, and manipulation compared across 12 programming languages","source":"@site/docs/file-io.md","sourceDirName":".","slug":"/file-io","permalink":"/language-comparison/docs/file-io","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/file-io.md","tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19,"description":"File reading, writing, and manipulation compared across 12 programming languages","keywords":["file I/O","reading files","writing files","file system","streams"]},"sidebar":"tutorialSidebar","previous":{"title":"Dates","permalink":"/language-comparison/docs/dates"},"next":{"title":"JSON & Serialization","permalink":"/language-comparison/docs/json-serialization"}}');var r=t(4848),l=t(8453),a=t(6153);const o={sidebar_position:19,description:"File reading, writing, and manipulation compared across 12 programming languages",keywords:["file I/O","reading files","writing files","file system","streams"]},s="File I/O",d={},f=[{value:"Reading Files",id:"reading-files",level:2},{value:"Writing Files",id:"writing-files",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"file-io",children:"File I/O"})}),"\n",(0,r.jsx)(n.p,{children:"Reading and writing files is a fundamental operation. Here's how different languages handle file operations."}),"\n","\n",(0,r.jsx)(n.h2,{id:"reading-files",children:"Reading Files"}),"\n",(0,r.jsx)(a.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Synchronous\nconst data = fs.readFileSync('file.txt', 'utf8');\n\n// Asynchronous (callback)\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Async/await (modern)\nconst data2 = await fsPromises.readFile('file.txt', 'utf8');\n\n// Read line by line\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: fs.createReadStream('file.txt'),\n});\nfor await (const line of rl) {\n  console.log(line);\n}"},{name:"PHP",lang:"php",code:"<?php\n// Read entire file\n$content = file_get_contents('file.txt');\n\n// Read into array of lines\n$lines = file('file.txt', FILE_IGNORE_NEW_LINES);\n\n// Read with fopen\n$fp = fopen('file.txt', 'r');\nwhile (($line = fgets($fp)) !== false) {\n  echo $line;\n}\nfclose($fp);\n\n// Read binary\n$data = file_get_contents('image.png');\n\n// Read CSV\n$fp = fopen('data.csv', 'r');\nwhile (($row = fgetcsv($fp)) !== false) {\n  print_r($row);\n}\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::{self, BufRead, Read};\n\n// Read entire file to string\nlet content = fs::read_to_string("file.txt")?;\n\n// Read to bytes\nlet bytes = fs::read("file.txt")?;\n\n// Read line by line\nlet file = fs::File::open("file.txt")?;\nlet reader = io::BufReader::new(file);\nfor line in reader.lines() {\n  let line = line?;\n  println!("{}", line);\n}\n\n// Read with buffer\nlet mut file = fs::File::open("file.txt")?;\nlet mut buffer = String::new();\nfile.read_to_string(&mut buffer)?;'},{name:"Go",lang:"go",code:'import (\n  "bufio"\n  "os"\n  "io"\n)\n\n// Read entire file\ndata, err := os.ReadFile("file.txt")\nif err != nil {\n  log.Fatal(err)\n}\nfmt.Println(string(data))\n\n// Read line by line\nfile, _ := os.Open("file.txt")\ndefer file.Close()\n\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n  fmt.Println(scanner.Text())\n}\n\n// Read with io.ReadAll\nfile, _ := os.Open("file.txt")\ndefer file.Close()\ndata, _ := io.ReadAll(file)'},{name:"Python",lang:"python",code:"# Read entire file\nwith open('file.txt', 'r') as f:\n  content = f.read()\n\n# Read all lines\nwith open('file.txt', 'r') as f:\n  lines = f.readlines()\n\n# Read line by line (memory efficient)\nwith open('file.txt', 'r') as f:\n  for line in f:\n      print(line.strip())\n\n# Read binary\nwith open('image.png', 'rb') as f:\n  data = f.read()\n\n# Read with encoding\nwith open('file.txt', 'r', encoding='utf-8') as f:\n  content = f.read()\n\n# pathlib (modern)\nfrom pathlib import Path\ncontent = Path('file.txt').read_text()"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Read entire file\nconst content = try std.fs.cwd().readFileAlloc(\n  allocator, "file.txt", 1024 * 1024\n);\ndefer allocator.free(content);\n\n// Read with file handle\nconst file = try std.fs.cwd().openFile("file.txt", .{});\ndefer file.close();\n\nvar buf: [1024]u8 = undefined;\nconst bytes_read = try file.read(&buf);\n\n// Read line by line\nvar buf_reader = std.io.bufferedReader(file.reader());\nvar line_buf: [4096]u8 = undefined;\nwhile (try buf_reader.reader().readUntilDelimiterOrEof(\n  &line_buf, \'\\n\'\n)) |line| {\n  std.debug.print("{s}\\n", .{line});\n}'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Read entire file\nstring content = File.ReadAllText("file.txt");\n\n// Read all lines\nstring[] lines = File.ReadAllLines("file.txt");\n\n// Read line by line\nforeach (string line in File.ReadLines("file.txt"))\n{\n  Console.WriteLine(line);\n}\n\n// StreamReader\nusing var reader = new StreamReader("file.txt");\nstring? line;\nwhile ((line = reader.ReadLine()) != null)\n{\n  Console.WriteLine(line);\n}\n\n// Async\nstring content2 = await File.ReadAllTextAsync("file.txt");\n\n// Read bytes\nbyte[] bytes = File.ReadAllBytes("file.bin");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n#include <sstream>\n#include <string>\n\n// Read entire file\nstd::ifstream file("file.txt");\nstd::stringstream buffer;\nbuffer << file.rdbuf();\nstd::string content = buffer.str();\n\n// Read line by line\nstd::ifstream file("file.txt");\nstd::string line;\nwhile (std::getline(file, line)) {\n  std::cout << line << std::endl;\n}\n\n// Read binary\nstd::ifstream file("data.bin", std::ios::binary);\nstd::vector<char> data(\n  (std::istreambuf_iterator<char>(file)),\n  std::istreambuf_iterator<char>()\n);\n\n// Check if file exists (C++17)\n#include <filesystem>\nif (std::filesystem::exists("file.txt")) { }'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Read entire file\nFILE* fp = fopen("file.txt", "r");\nif (fp == NULL) { perror("Error"); return 1; }\n\nfseek(fp, 0, SEEK_END);\nlong size = ftell(fp);\nrewind(fp);\n\nchar* buffer = malloc(size + 1);\nfread(buffer, 1, size, fp);\nbuffer[size] = \'\\0\';\nfclose(fp);\n\n// Read line by line\nFILE* fp = fopen("file.txt", "r");\nchar line[256];\nwhile (fgets(line, sizeof(line), fp)) {\n  printf("%s", line);\n}\nfclose(fp);\n\n// Read binary\nFILE* fp = fopen("data.bin", "rb");\nunsigned char buf[1024];\nsize_t n = fread(buf, 1, sizeof(buf), fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\nimport java.io.*;\n\n// Read entire file (Java 11+)\nString content = Files.readString(Path.of("file.txt"));\n\n// Read all lines\nList<String> lines = Files.readAllLines(Path.of("file.txt"));\n\n// Read line by line (buffered)\ntry (BufferedReader reader =\n      Files.newBufferedReader(Path.of("file.txt"))) {\n  String line;\n  while ((line = reader.readLine()) != null) {\n      System.out.println(line);\n  }\n}\n\n// Stream lines\nFiles.lines(Path.of("file.txt"))\n   .forEach(System.out::println);\n\n// Read bytes\nbyte[] bytes = Files.readAllBytes(Path.of("file.bin"));'},{name:"Ruby",lang:"ruby",code:"# Read entire file\ncontent = File.read('file.txt')\n\n# Read all lines\nlines = File.readlines('file.txt', chomp: true)\n\n# Read line by line\nFile.foreach('file.txt') do |line|\nputs line.chomp\nend\n\n# Read with block (auto-closes)\nFile.open('file.txt', 'r') do |f|\ncontent = f.read\nend\n\n# Read binary\ndata = File.binread('image.png')\n\n# Check file existence\nFile.exist?('file.txt')  # true/false"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Read entire file\nlet content = try String(\n  contentsOfFile: "file.txt",\n  encoding: .utf8\n)\n\n// Read with URL\nlet url = URL(fileURLWithPath: "file.txt")\nlet data = try Data(contentsOf: url)\nlet text = String(data: data, encoding: .utf8)!\n\n// Read line by line\nif let contents = try? String(contentsOfFile: "file.txt") {\n  for line in contents.components(separatedBy: "\\n") {\n      print(line)\n  }\n}\n\n// FileManager\nlet fm = FileManager.default\nif fm.fileExists(atPath: "file.txt") {\n  let data = fm.contents(atPath: "file.txt")\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"writing-files",children:"Writing Files"}),"\n",(0,r.jsx)(a.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Write (overwrite)\nfs.writeFileSync('output.txt', 'Hello World');\n\n// Write async\nawait fsPromises.writeFile('output.txt', 'Hello World');\n\n// Append\nfs.appendFileSync('output.txt', '\\nNew line');\n\n// Write with stream\nconst stream = fs.createWriteStream('output.txt');\nstream.write('Line 1\\n');\nstream.write('Line 2\\n');\nstream.end();"},{name:"PHP",lang:"php",code:"<?php\n// Write (overwrite)\nfile_put_contents('output.txt', 'Hello World');\n\n// Append\nfile_put_contents('output.txt', \"\\nNew line\", FILE_APPEND);\n\n// Write with fopen\n$fp = fopen('output.txt', 'w');\nfwrite($fp, \"Line 1\\n\");\nfwrite($fp, \"Line 2\\n\");\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::Write;\n\n// Write (overwrite)\nfs::write("output.txt", "Hello World")?;\n\n// Write with file handle\nlet mut file = fs::File::create("output.txt")?;\nfile.write_all(b"Hello World")?;\n\n// Append\nuse std::fs::OpenOptions;\nlet mut file = OpenOptions::new()\n  .append(true)\n  .open("output.txt")?;\nwriteln!(file, "New line")?;'},{name:"Go",lang:"go",code:'import "os"\n\n// Write (overwrite)\nos.WriteFile("output.txt", []byte("Hello World"), 0644)\n\n// Write with file handle\nfile, _ := os.Create("output.txt")\ndefer file.Close()\nfile.WriteString("Hello World\\n")\n\n// Append\nfile, _ := os.OpenFile("output.txt",\n  os.O_APPEND|os.O_WRONLY, 0644)\ndefer file.Close()\nfile.WriteString("New line\\n")\n\n// Buffered writer\nwriter := bufio.NewWriter(file)\nwriter.WriteString("Buffered content\\n")\nwriter.Flush()'},{name:"Python",lang:"python",code:"# Write (overwrite)\nwith open('output.txt', 'w') as f:\n  f.write('Hello World')\n\n# Append\nwith open('output.txt', 'a') as f:\n  f.write('\\nNew line')\n\n# Write multiple lines\nlines = ['Line 1', 'Line 2', 'Line 3']\nwith open('output.txt', 'w') as f:\n  f.writelines(line + '\\n' for line in lines)\n\n# pathlib (modern)\nfrom pathlib import Path\nPath('output.txt').write_text('Hello World')"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Write (overwrite)\nconst file = try std.fs.cwd().createFile("output.txt", .{});\ndefer file.close();\ntry file.writeAll("Hello World");\n\n// Write formatted\nconst writer = file.writer();\ntry writer.print("Value: {d}\\n", .{42});\n\n// Append\nconst file = try std.fs.cwd().openFile("output.txt", .{\n  .mode = .write_only,\n});\ndefer file.close();\ntry file.seekFromEnd(0);\ntry file.writeAll("New line\\n");'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Write (overwrite)\nFile.WriteAllText("output.txt", "Hello World");\n\n// Write lines\nFile.WriteAllLines("output.txt",\n  new[] { "Line 1", "Line 2" });\n\n// Append\nFile.AppendAllText("output.txt", "\\nNew line");\n\n// StreamWriter\nusing var writer = new StreamWriter("output.txt");\nwriter.WriteLine("Line 1");\nwriter.WriteLine("Line 2");\n\n// Async\nawait File.WriteAllTextAsync("output.txt", "Hello");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n\n// Write (overwrite)\nstd::ofstream file("output.txt");\nfile << "Hello World" << std::endl;\nfile.close();\n\n// Append\nstd::ofstream file("output.txt", std::ios::app);\nfile << "New line" << std::endl;\n\n// Write binary\nstd::ofstream file("data.bin", std::ios::binary);\nfile.write(reinterpret_cast<char*>(&data), sizeof(data));'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Write (overwrite)\nFILE* fp = fopen("output.txt", "w");\nfprintf(fp, "Hello World\\n");\nfclose(fp);\n\n// Append\nFILE* fp = fopen("output.txt", "a");\nfprintf(fp, "New line\\n");\nfclose(fp);\n\n// Write binary\nFILE* fp = fopen("data.bin", "wb");\nfwrite(data, sizeof(data[0]), count, fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\n\n// Write (overwrite) - Java 11+\nFiles.writeString(Path.of("output.txt"), "Hello World");\n\n// Write lines\nFiles.write(Path.of("output.txt"),\n  List.of("Line 1", "Line 2"));\n\n// Append\nFiles.writeString(Path.of("output.txt"), "\\nNew line",\n  StandardOpenOption.APPEND);\n\n// BufferedWriter\ntry (BufferedWriter writer =\n      Files.newBufferedWriter(Path.of("output.txt"))) {\n  writer.write("Line 1");\n  writer.newLine();\n}'},{name:"Ruby",lang:"ruby",code:"# Write (overwrite)\nFile.write('output.txt', 'Hello World')\n\n# Append\nFile.open('output.txt', 'a') do |f|\nf.puts 'New line'\nend\n\n# Write with block\nFile.open('output.txt', 'w') do |f|\nf.puts 'Line 1'\nf.puts 'Line 2'\nend\n\n# Write binary\nFile.binwrite('data.bin', binary_data)"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Write (overwrite)\ntry "Hello World".write(\n  toFile: "output.txt",\n  atomically: true,\n  encoding: .utf8\n)\n\n// Write with Data\nlet data = "Hello".data(using: .utf8)!\ntry data.write(to: URL(fileURLWithPath: "output.txt"))\n\n// Append\nlet handle = try FileHandle(\n  forWritingTo: URL(fileURLWithPath: "output.txt")\n)\nhandle.seekToEndOfFile()\nhandle.write("New line\\n".data(using: .utf8)!)\nhandle.closeFile()'}]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sync vs async APIs coexist"})," \u2014 Most languages offer both: Node.js has ",(0,r.jsx)(n.code,{children:"fs.readFileSync"})," and ",(0,r.jsx)(n.code,{children:"fs.promises.readFile"}),"; C# has ",(0,r.jsx)(n.code,{children:"File.ReadAllText"})," and ",(0,r.jsx)(n.code,{children:"File.ReadAllTextAsync"}),"; Python's ",(0,r.jsx)(n.code,{children:"open()"})," is sync by default, though ",(0,r.jsx)(n.code,{children:"asyncio"})," can wrap it. For I/O-bound workloads (e.g., web servers reading many files), prefer async to avoid blocking; for scripts or CLI tools, sync is often simpler. Choose a language that supports your concurrency model\u2014Node.js and C# are async-first; Rust offers ",(0,r.jsx)(n.code,{children:"tokio"})," for async file I/O."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resource cleanup patterns differ"})," \u2014 Python's ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," and C#/Java's ",(0,r.jsx)(n.code,{children:"using"}),"/try-with-resources, plus Rust's RAII, guarantee closure even on errors. Go uses ",(0,r.jsx)(n.code,{children:"defer file.Close()"})," which runs when the function returns. C and Zig require explicit ",(0,r.jsx)(n.code,{children:"fclose"})," or ",(0,r.jsx)(n.code,{children:"file.close()"}),"\u2014if an error occurs before the close, the handle can leak. Prefer block-based or RAII patterns when available; in C or Zig, structure code so every ",(0,r.jsx)(n.code,{children:"open"})," has a corresponding ",(0,r.jsx)(n.code,{children:"close"})," in the same control path."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Encoding handling is explicit in some languages"})," \u2014 Python and Node.js accept ",(0,r.jsx)(n.code,{children:"encoding='utf-8'"})," when reading text; C# defaults to UTF-8 in newer APIs. C and C++ treat files as raw bytes; you must use libraries or manual conversion for UTF-8. Zig exposes low-level byte APIs\u2014",(0,r.jsx)(n.code,{children:"readFileAlloc"})," returns ",(0,r.jsx)(n.code,{children:"[]u8"}),", and you handle string decoding yourself. For international text, prefer Python, C#, or Java; for binary or when you need full control, C/C++/Zig are appropriate."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High-level helpers vs manual control"})," \u2014 C#, Python, and Java offer ",(0,r.jsx)(n.code,{children:"File.ReadAllText"}),", ",(0,r.jsx)(n.code,{children:"Path('file.txt').read_text()"}),", and ",(0,r.jsx)(n.code,{children:'Files.readString(Path.of("file.txt"))'})," for one-line reads. C and Zig require manual buffer allocation, ",(0,r.jsx)(n.code,{children:"fread"}),"/",(0,r.jsx)(n.code,{children:"read"})," loops, and null termination. High-level APIs are convenient but may load entire files into memory; for large files, use streaming (e.g., ",(0,r.jsx)(n.code,{children:"File.ReadLines"}),", ",(0,r.jsx)(n.code,{children:"BufferedReader"}),", or Rust's ",(0,r.jsx)(n.code,{children:"BufReader"}),"). Choose helpers for small files; use streams when memory or latency matters."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Block-based APIs avoid leaks"})," \u2014 Ruby's ",(0,r.jsx)(n.code,{children:"File.open('file.txt') { |f| }"})," and Python's ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," guarantee closure even when exceptions occur. Explicit ",(0,r.jsx)(n.code,{children:"fclose"})," in C and PHP can lead to leaks if an error happens before the close\u2014e.g., a ",(0,r.jsx)(n.code,{children:"return"})," or ",(0,r.jsx)(n.code,{children:"throw"})," in the middle of processing. Always prefer block-based or RAII patterns when available; in C, consider using ",(0,r.jsx)(n.code,{children:"goto"})," to a cleanup label or a minimal wrapper pattern to centralize close logic."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);