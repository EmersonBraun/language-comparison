"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[47],{6154(n,e,l){l.r(e),l.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"null-safety","title":"Null Safety & Optionals","description":"Null safety, Optional types, and nil handling compared across 12 programming languages","source":"@site/docs/null-safety.md","sourceDirName":".","slug":"/null-safety","permalink":"/language-comparison/docs/null-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/null-safety.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{"sidebar_position":23,"description":"Null safety, Optional types, and nil handling compared across 12 programming languages","keywords":["null safety","Optional","nullable","nil","null coalescing","optionals"]},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/language-comparison/docs/error-handling"},"next":{"title":"Concurrency & Async","permalink":"/language-comparison/docs/concurrency-async"}}');var i=l(4848),a=l(8453),s=l(6153);const r={sidebar_position:23,description:"Null safety, Optional types, and nil handling compared across 12 programming languages",keywords:["null safety","Optional","nullable","nil","null coalescing","optionals"]},o="Null Safety & Optionals",u={},d=[{value:"Nullable Types &amp; Optionals",id:"nullable-types--optionals",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"null-safety--optionals",children:"Null Safety & Optionals"})}),"\n",(0,i.jsx)(e.p,{children:"Handling null/nil values is a common source of bugs. Here's how different languages approach null safety."}),"\n","\n",(0,i.jsx)(e.h2,{id:"nullable-types--optionals",children:"Nullable Types & Optionals"}),"\n",(0,i.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// null and undefined are distinct\nlet a = null;       // Intentionally empty\nlet b = undefined;  // Not yet assigned\nlet c;              // undefined\n\n// Checking for null/undefined\nif (value === null) { }\nif (value === undefined) { }\nif (value == null) { }  // checks both null & undefined\n\n// Nullish coalescing (??)\nconst name = user ?? "default";\nconst age = data.age ?? 0;\n\n// Optional chaining (?.)\nconst city = user?.address?.city;\nconst first = arr?.[0];\nconst result = func?.();\n\n// Nullish coalescing assignment\nlet x = null;\nx ??= "default";  // x is now "default"\n\n// Logical OR (includes falsy values)\nconst name2 = user || "default";  // "" -> "default"\nconst name3 = user ?? "default";  // "" -> ""'},{name:"PHP",lang:"php",code:'<?php\n// Null\n$value = null;\nis_null($value);     // true\nisset($value);       // false\n\n// Null coalescing\n$name = $user ?? "default";\n$name ??= "default";  // PHP 7.4+\n\n// Null safe operator (PHP 8.0+)\n$city = $user?->getAddress()?->getCity();\n\n// Nullable types\nfunction find(?int $id): ?User {\n  if ($id === null) return null;\n  return User::find($id);\n}\n\n// Union types with null\nfunction process(string|null $value): string {\n  return $value ?? "default";\n}\n\n// Null strict comparison\n$value === null;   // Strict check\n$value == null;    // Also matches false, 0, ""'},{name:"Rust",lang:"rust",code:'// No null! Use Option<T>\nlet some_value: Option<i32> = Some(42);\nlet no_value: Option<i32> = None;\n\n// Pattern matching\nmatch some_value {\n  Some(v) => println!("Got: {}", v),\n  None => println!("Nothing"),\n}\n\n// if let\nif let Some(v) = some_value {\n  println!("Got: {}", v);\n}\n\n// Unwrap methods\nsome_value.unwrap();           // Panics if None\nsome_value.unwrap_or(0);       // Default value\nsome_value.unwrap_or_default(); // Type\'s default\nsome_value.expect("must exist"); // Panic with message\n\n// Combinators\nsome_value.map(|v| v * 2);         // Some(84)\nno_value.map(|v| v * 2);           // None\nsome_value.and_then(|v| Some(v + 1)); // Some(43)\nsome_value.filter(|v| *v > 50);    // None\nno_value.or(Some(0));              // Some(0)\n\n// ? operator (propagate None)\nfn get_city(user: &Option<User>) -> Option<String> {\n  let city = user.as_ref()?.address.as_ref()?.city.clone();\n  Some(city)\n}'},{name:"Go",lang:"go",code:'// nil is the zero value for pointers, interfaces,\n// maps, slices, channels, and functions\nvar ptr *int = nil\nvar slice []int = nil\nvar m map[string]int = nil\n\n// Check for nil\nif ptr != nil {\n  fmt.Println(*ptr)\n}\n\n// Pointer for optional values\nfunc findUser(id int) *User {\n  // return nil if not found\n  return nil\n}\n\nuser := findUser(1)\nif user != nil {\n  fmt.Println(user.Name)\n}\n\n// Error pattern (idiomatic Go)\nfunc getCity(user *User) (string, error) {\n  if user == nil {\n      return "", errors.New("user is nil")\n  }\n  if user.Address == nil {\n      return "", errors.New("address is nil")\n  }\n  return user.Address.City, nil\n}\n\n// Zero values (no nil needed)\nvar s string  // "" (not nil)\nvar n int     // 0 (not nil)\nvar b bool    // false (not nil)'},{name:"Python",lang:"python",code:"# None is Python's null\nvalue = None\n\n# Check for None (use 'is', not '==')\nif value is None:\n  print(\"no value\")\n\nif value is not None:\n  print(value)\n\n# Optional type hints\nfrom typing import Optional\n\ndef find_user(id: int) -> Optional[User]:\n  # Returns User or None\n  return None\n\n# Union syntax (Python 3.10+)\ndef find_user(id: int) -> User | None:\n  return None\n\n# Default values\nname = user.name if user else \"default\"\n\n# Walrus operator for safe access\nif (user := find_user(1)) is not None:\n  print(user.name)\n\n# getattr with default\nname = getattr(user, 'name', 'default')\n\n# dict.get with default\ncity = data.get('city', 'unknown')"},{name:"Zig",lang:"zig",code:'// Optional type: ?T\nvar value: ?i32 = 42;\nvar empty: ?i32 = null;\n\n// Unwrap with orelse\nconst result = value orelse 0;       // 42\nconst result2 = empty orelse 0;      // 0\n\n// Unwrap with if\nif (value) |v| {\n  std.debug.print("Got: {d}\\n", .{v});\n} else {\n  std.debug.print("null\\n", .{});\n}\n\n// Unwrap with .?  (assert non-null)\nconst v = value.?;  // panics if null\n\n// Optional pointers\nvar ptr: ?*i32 = null;\n\n// Chaining optionals\nfn getCity(user: ?*User) ?[]const u8 {\n  const u = user orelse return null;\n  const addr = u.address orelse return null;\n  return addr.city;\n}'},{name:"C#",lang:"csharp",code:'// Nullable value types\nint? nullableInt = null;\nint? withValue = 42;\n\n// Null check\nif (nullableInt.HasValue)\n  Console.WriteLine(nullableInt.Value);\n\n// Null-coalescing\nstring name = user ?? "default";\nint age = nullableAge ?? 0;\n\n// Null-coalescing assignment\nstring? name = null;\nname ??= "default";\n\n// Null-conditional (safe navigation)\nstring? city = user?.Address?.City;\nint? length = text?.Length;\nint? first = list?.FirstOrDefault();\n\n// Nullable reference types (C# 8+)\n#nullable enable\nstring nonNull = "hello";     // Cannot be null\nstring? canBeNull = null;     // Can be null\n\n// Pattern matching with null\nif (value is not null) { }\nif (value is string s) { }\n\n// Null-forgiving operator\nstring s = possiblyNull!;  // Trust me, not null'},{name:"C++",lang:"cpp",code:"// Pointers can be null\nint* ptr = nullptr;\n\nif (ptr != nullptr) {\n  std::cout << *ptr;\n}\n\n// std::optional (C++17)\n#include <optional>\n\nstd::optional<int> findValue(int id) {\n  if (id > 0) return 42;\n  return std::nullopt;\n}\n\nauto result = findValue(1);\n\n// Check and access\nif (result.has_value()) {\n  std::cout << result.value();\n}\n\n// value_or (default)\nint val = result.value_or(0);\n\n// Dereference (undefined if empty)\nif (result) {\n  std::cout << *result;\n}\n\n// std::unique_ptr / std::shared_ptr\nauto ptr = std::make_unique<int>(42);\nif (ptr) {\n  std::cout << *ptr;\n}"},{name:"C",lang:"c",code:'// NULL pointer\nint* ptr = NULL;\n\n// Check before use\nif (ptr != NULL) {\n  printf("%d\\n", *ptr);\n}\n\n// Common patterns\n// Return NULL for "not found"\nchar* find_name(int id) {\n  if (id < 0) return NULL;\n  return "John";\n}\n\nchar* name = find_name(-1);\nif (name != NULL) {\n  printf("%s\\n", name);\n}\n\n// Sentinel values (no optionals)\n#define NOT_FOUND -1\n\nint find_index(int* arr, int size, int target) {\n  for (int i = 0; i < size; i++) {\n      if (arr[i] == target) return i;\n  }\n  return NOT_FOUND;\n}'},{name:"Java",lang:"java",code:'// null reference\nString name = null;\n\n// NullPointerException if not checked\n// name.length();  // throws NPE!\n\n// Optional<T> (Java 8+)\nOptional<String> opt = Optional.of("hello");\nOptional<String> empty = Optional.empty();\nOptional<String> nullable = Optional.ofNullable(name);\n\n// Access\nopt.get();                    // "hello" (throws if empty)\nopt.orElse("default");        // "hello"\nempty.orElse("default");      // "default"\nopt.orElseGet(() -> compute()); // Lazy default\n\n// Transform\nopt.map(String::toUpperCase); // Optional("HELLO")\nopt.flatMap(this::findUser);  // Flatten nested Optional\nopt.filter(s -> s.length() > 3); // Optional("hello")\n\n// Check\nopt.isPresent();              // true\nopt.isEmpty();                // false (Java 11+)\nopt.ifPresent(s -> System.out.println(s));\n\n// Chaining\nOptional<String> city = Optional.ofNullable(user)\n  .map(User::getAddress)\n  .map(Address::getCity);'},{name:"Ruby",lang:"ruby",code:'# nil is Ruby\'s null\nvalue = nil\n\n# Check for nil\nvalue.nil?       # true\nvalue == nil     # true\n\n# Safe navigation operator (&.)\ncity = user&.address&.city\n\n# Default with ||\nname = user_name || "default"\n\n# Default with ||= (assign if nil/false)\n@name ||= "default"\n\n# Dig method (safe nested access)\ncity = data.dig(:user, :address, :city)\n\n# &. with method calls\nlength = text&.length  # nil if text is nil\n\n# Presence check (Rails)\n# name.present?  # false for nil, "", " "\n# name.presence || "default"\n\n# Compact (remove nils from array)\n[1, nil, 2, nil, 3].compact  # [1, 2, 3]'},{name:"Swift",lang:"swift",code:'// Optionals (core language feature)\nvar name: String? = nil       // Optional String\nvar age: Int? = 42            // Optional Int\n\n// Forced unwrap (crashes if nil!)\nlet n = name!  // Don\'t do this unless sure\n\n// Optional binding (if let)\nif let name = name {\n  print(name)\n}\n\n// Guard let (early return)\nguard let name = name else {\n  return\n}\nprint(name)  // name is now non-optional\n\n// Nil-coalescing\nlet result = name ?? "default"\n\n// Optional chaining\nlet city = user?.address?.city\n\n// Map / flatMap\nlet upper = name.map { $0.uppercased() }\nlet user = id.flatMap { findUser($0) }\n\n// Implicitly unwrapped optional\nvar label: String!  // Assumed non-nil after init\n\n// Multiple optional binding\nif let name = name, let age = age {\n  print("\\(name) is \\(age)")\n}'}]}),"\n",(0,i.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Option/Optional types"})," -- Rust (",(0,i.jsx)(e.code,{children:"Option<T>"}),"), Swift (",(0,i.jsx)(e.code,{children:"T?"}),"), Zig (",(0,i.jsx)(e.code,{children:"?T"}),"), and Java (",(0,i.jsx)(e.code,{children:"Optional<T>"}),") provide explicit optional types instead of nullable references. In Rust, ",(0,i.jsx)(e.code,{children:"let x: Option<i32> = Some(42)"})," or ",(0,i.jsx)(e.code,{children:"None"})," -- there is no ",(0,i.jsx)(e.code,{children:"null"}),"; you use ",(0,i.jsx)(e.code,{children:"match"}),", ",(0,i.jsx)(e.code,{children:"if let"}),", or ",(0,i.jsx)(e.code,{children:"unwrap_or(0)"}),". Swift's ",(0,i.jsx)(e.code,{children:"var name: String? = nil"})," and Zig's ",(0,i.jsx)(e.code,{children:"var value: ?i32 = null"})," make optionality part of the type. Java's ",(0,i.jsx)(e.code,{children:"Optional<String> opt = Optional.ofNullable(name)"})," wraps nullable values. These types force you to handle absence explicitly. Choose Option/Optional when you want compile-time enforcement; use nullable references (JavaScript, Python, C) when you prefer flexibility and runtime checks."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Null coalescing operators"})," -- Most languages support ",(0,i.jsx)(e.code,{children:"??"})," for default values: JavaScript's ",(0,i.jsx)(e.code,{children:'const name = user ?? "default"'}),", PHP's ",(0,i.jsx)(e.code,{children:'$name = $user ?? "default"'}),", C#'s ",(0,i.jsx)(e.code,{children:'string name = user ?? "default"'}),", Swift's ",(0,i.jsx)(e.code,{children:'let result = name ?? "default"'}),", and Zig's ",(0,i.jsx)(e.code,{children:"const result = value orelse 0"}),". These ignore falsy values like ",(0,i.jsx)(e.code,{children:'""'})," or ",(0,i.jsx)(e.code,{children:"0"})," (unlike ",(0,i.jsx)(e.code,{children:"||"})," in JavaScript). Go has no ",(0,i.jsx)(e.code,{children:"??"}),"; you use ",(0,i.jsx)(e.code,{children:'if user != nil { name = user.Name } else { name = "default" }'})," or helper functions. Choose languages with ",(0,i.jsx)(e.code,{children:"??"})," when you frequently need safe defaults; in Go, factor defaults into small helper functions."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Languages that eliminate null"})," -- Rust has no null; optional values use ",(0,i.jsx)(e.code,{children:"Option<T>"}),". Swift and Zig use optional types as the primary mechanism: in Swift, ",(0,i.jsx)(e.code,{children:"String?"})," is distinct from ",(0,i.jsx)(e.code,{children:"String"}),", and unwrapping with ",(0,i.jsx)(e.code,{children:"!"})," or ",(0,i.jsx)(e.code,{children:"if let"})," is explicit. Zig's ",(0,i.jsx)(e.code,{children:"?T"})," forces ",(0,i.jsx)(e.code,{children:"orelse"})," or ",(0,i.jsx)(e.code,{children:"if"}),' to handle null. This avoids the "billion-dollar mistake" of null dereferences. Python, JavaScript, Java, and C allow ',(0,i.jsx)(e.code,{children:"null"}),"/",(0,i.jsx)(e.code,{children:"None"}),"/",(0,i.jsx)(e.code,{children:"undefined"})," anywhere, leading to ",(0,i.jsx)(e.code,{children:"NullPointerException"})," or ",(0,i.jsx)(e.code,{children:"TypeError"})," at runtime. If eliminating null bugs is a priority, choose Rust; Swift and Zig offer strong optional handling with less strictness than Rust."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Safe navigation"})," -- Optional chaining (",(0,i.jsx)(e.code,{children:"?."}),") in JavaScript, PHP, C#, Swift, and Ruby prevents null dereference errors when traversing nested structures. For example, ",(0,i.jsx)(e.code,{children:"user?.address?.city"})," returns ",(0,i.jsx)(e.code,{children:"undefined"})," or ",(0,i.jsx)(e.code,{children:"nil"})," if any link is null instead of throwing. JavaScript's ",(0,i.jsx)(e.code,{children:"arr?.[0]"})," and ",(0,i.jsx)(e.code,{children:"func?.()"})," extend this to arrays and calls. Without ",(0,i.jsx)(e.code,{children:"?."}),", you write ",(0,i.jsx)(e.code,{children:"user && user.address && user.address.city"})," (JavaScript) or nested ",(0,i.jsx)(e.code,{children:"if"})," checks. Go has no ",(0,i.jsx)(e.code,{children:"?."}),"; you check ",(0,i.jsx)(e.code,{children:"if user != nil && user.Address != nil { city = user.Address.City }"}),". Prefer ",(0,i.jsx)(e.code,{children:"?."})," when working with deeply nested, loosely typed data (APIs, configs)."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Null-coalescing assignment"})," -- JavaScript (",(0,i.jsx)(e.code,{children:'x ??= "default"'}),"), PHP (",(0,i.jsx)(e.code,{children:'$name ??= "default"'}),"), and C# (",(0,i.jsx)(e.code,{children:'name ??= "default"'}),") assign a default only when the variable is null or undefined. This keeps code concise when initializing optional fields. Go and Rust require explicit ",(0,i.jsx)(e.code,{children:"if"})," or ",(0,i.jsx)(e.code,{children:"match"}),". Use ",(0,i.jsx)(e.code,{children:"??="})," when you have optional configuration or lazy defaults; in Go and Rust, use ",(0,i.jsx)(e.code,{children:"Option"}),"/",(0,i.jsx)(e.code,{children:"if"})," patterns for clarity."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);