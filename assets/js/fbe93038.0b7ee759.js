"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[133],{3504(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"testing","title":"Testing","description":"Unit testing frameworks, assertions, and mocking compared across 12 programming languages","source":"@site/docs/testing.md","sourceDirName":".","slug":"/testing","permalink":"/language-comparison/docs/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/testing.md","tags":[],"version":"current","sidebarPosition":28,"frontMatter":{"sidebar_position":28,"description":"Unit testing frameworks, assertions, and mocking compared across 12 programming languages","keywords":["testing","unit tests","assertions","mocking","test frameworks","TDD"]},"sidebar":"tutorialSidebar","previous":{"title":"Package Management","permalink":"/language-comparison/docs/package-management"}}');var a=t(4848),r=t(8453),i=t(6153);const o={sidebar_position:28,description:"Unit testing frameworks, assertions, and mocking compared across 12 programming languages",keywords:["testing","unit tests","assertions","mocking","test frameworks","TDD"]},d="Testing",c={},u=[{value:"Basic Unit Tests",id:"basic-unit-tests",level:2},{value:"Mocking &amp; Advanced Testing",id:"mocking--advanced-testing",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"testing",children:"Testing"})}),"\n",(0,a.jsx)(e.p,{children:"Unit testing is fundamental to software quality. Here's how different languages handle testing with their built-in or most popular frameworks."}),"\n","\n",(0,a.jsx)(e.h2,{id:"basic-unit-tests",children:"Basic Unit Tests"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Jest (most popular)\n// npm install --save-dev jest\n\n// math.js\nfunction add(a, b) { return a + b; }\nmodule.exports = { add };\n\n// math.test.js\nconst { add } = require('./math');\n\ndescribe('add', () => {\n  test('adds two numbers', () => {\n      expect(add(1, 2)).toBe(3);\n  });\n\n  test('handles negative numbers', () => {\n      expect(add(-1, 1)).toBe(0);\n  });\n\n  test('handles zero', () => {\n      expect(add(0, 0)).toBe(0);\n  });\n});\n\n// Run: npx jest"},{name:"PHP",lang:"php",code:"<?php\n// PHPUnit (standard)\n// composer require --dev phpunit/phpunit\n\nuse PHPUnit\\Framework\\TestCase;\n\nclass MathTest extends TestCase\n{\n  public function testAdd(): void\n  {\n      $this->assertEquals(3, add(1, 2));\n  }\n\n  public function testNegativeNumbers(): void\n  {\n      $this->assertEquals(0, add(-1, 1));\n  }\n\n  public function testZero(): void\n  {\n      $this->assertEquals(0, add(0, 0));\n  }\n}\n\n// Run: ./vendor/bin/phpunit"},{name:"Rust",lang:"rust",code:'// Built-in test framework\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn test_add() {\n      assert_eq!(add(1, 2), 3);\n  }\n\n  #[test]\n  fn test_negative() {\n      assert_eq!(add(-1, 1), 0);\n  }\n\n  #[test]\n  #[should_panic(expected = "overflow")]\n  fn test_overflow() {\n      add(i32::MAX, 1);\n  }\n}\n\n// Run: cargo test'},{name:"Go",lang:"go",code:'// Built-in testing package\n// File: math_test.go\npackage math\n\nimport "testing"\n\nfunc TestAdd(t *testing.T) {\n  result := Add(1, 2)\n  if result != 3 {\n      t.Errorf("Add(1, 2) = %d; want 3", result)\n  }\n}\n\nfunc TestNegative(t *testing.T) {\n  result := Add(-1, 1)\n  if result != 0 {\n      t.Errorf("Add(-1, 1) = %d; want 0", result)\n  }\n}\n\n// Table-driven tests (Go idiom)\nfunc TestAddTable(t *testing.T) {\n  tests := []struct {\n      a, b, want int\n  }{\n      {1, 2, 3},\n      {-1, 1, 0},\n      {0, 0, 0},\n  }\n  for _, tt := range tests {\n      got := Add(tt.a, tt.b)\n      if got != tt.want {\n          t.Errorf("Add(%d, %d) = %d; want %d",\n              tt.a, tt.b, got, tt.want)\n      }\n  }\n}\n\n// Run: go test ./...'},{name:"Python",lang:"python",code:"# pytest (most popular)\n# pip install pytest\n\n# test_math.py\ndef add(a, b):\n  return a + b\n\ndef test_add():\n  assert add(1, 2) == 3\n\ndef test_negative():\n  assert add(-1, 1) == 0\n\ndef test_zero():\n  assert add(0, 0) == 0\n\n# unittest (built-in)\nimport unittest\n\nclass TestMath(unittest.TestCase):\n  def test_add(self):\n      self.assertEqual(add(1, 2), 3)\n\n  def test_negative(self):\n      self.assertEqual(add(-1, 1), 0)\n\n# Run: pytest\n# Run: python -m unittest"},{name:"Zig",lang:"zig",code:'const std = @import("std");\nconst testing = std.testing;\n\nfn add(a: i32, b: i32) i32 {\n  return a + b;\n}\n\ntest "add two numbers" {\n  try testing.expectEqual(@as(i32, 3), add(1, 2));\n}\n\ntest "negative numbers" {\n  try testing.expectEqual(@as(i32, 0), add(-1, 1));\n}\n\ntest "zero" {\n  try testing.expectEqual(@as(i32, 0), add(0, 0));\n}\n\n// Run: zig build test'},{name:"C#",lang:"csharp",code:"// xUnit (most popular)\n// dotnet add package xunit\n\nusing Xunit;\n\npublic class MathTests\n{\n  [Fact]\n  public void Add_TwoNumbers_ReturnsSum()\n  {\n      Assert.Equal(3, Math.Add(1, 2));\n  }\n\n  [Fact]\n  public void Add_NegativeNumbers_ReturnsZero()\n  {\n      Assert.Equal(0, Math.Add(-1, 1));\n  }\n\n  [Theory]\n  [InlineData(1, 2, 3)]\n  [InlineData(-1, 1, 0)]\n  [InlineData(0, 0, 0)]\n  public void Add_Various(int a, int b, int expected)\n  {\n      Assert.Equal(expected, Math.Add(a, b));\n  }\n}\n\n// Run: dotnet test"},{name:"C++",lang:"cpp",code:'// Google Test (most popular)\n// #include <gtest/gtest.h>\n\nTEST(MathTest, AddTwoNumbers) {\n  EXPECT_EQ(add(1, 2), 3);\n}\n\nTEST(MathTest, NegativeNumbers) {\n  EXPECT_EQ(add(-1, 1), 0);\n}\n\nTEST(MathTest, Zero) {\n  EXPECT_EQ(add(0, 0), 0);\n}\n\n// Catch2 (header-only alternative)\n// #include <catch2/catch_test_macros.hpp>\n\nTEST_CASE("add works", "[math]") {\n  REQUIRE(add(1, 2) == 3);\n\n  SECTION("negative numbers") {\n      REQUIRE(add(-1, 1) == 0);\n  }\n}\n\n// Run: cmake --build . && ctest'},{name:"C",lang:"c",code:'// Unity (popular C test framework)\n// or simple assert-based testing\n\n#include <assert.h>\n#include <stdio.h>\n\nint add(int a, int b) { return a + b; }\n\nvoid test_add() {\n  assert(add(1, 2) == 3);\n  printf("test_add passed\\n");\n}\n\nvoid test_negative() {\n  assert(add(-1, 1) == 0);\n  printf("test_negative passed\\n");\n}\n\nvoid test_zero() {\n  assert(add(0, 0) == 0);\n  printf("test_zero passed\\n");\n}\n\nint main() {\n  test_add();\n  test_negative();\n  test_zero();\n  printf("All tests passed!\\n");\n  return 0;\n}\n\n// Compile & run: gcc -o tests test_math.c && ./tests'},{name:"Java",lang:"java",code:'// JUnit 5 (standard)\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass MathTest {\n  @Test\n  void addTwoNumbers() {\n      assertEquals(3, Math.add(1, 2));\n  }\n\n  @Test\n  void negativeNumbers() {\n      assertEquals(0, Math.add(-1, 1));\n  }\n\n  @ParameterizedTest\n  @CsvSource({"1, 2, 3", "-1, 1, 0", "0, 0, 0"})\n  void addVarious(int a, int b, int expected) {\n      assertEquals(expected, Math.add(a, b));\n  }\n}\n\n// Run: mvn test\n// Run: gradle test'},{name:"Ruby",lang:"ruby",code:"# RSpec (most popular)\n# gem install rspec\n\n# spec/math_spec.rb\nrequire_relative '../math'\n\nRSpec.describe 'add' do\nit 'adds two numbers' do\n  expect(add(1, 2)).to eq(3)\nend\n\nit 'handles negative numbers' do\n  expect(add(-1, 1)).to eq(0)\nend\n\nit 'handles zero' do\n  expect(add(0, 0)).to eq(0)\nend\nend\n\n# Minitest (built-in)\nrequire 'minitest/autorun'\n\nclass TestMath < Minitest::Test\ndef test_add\n  assert_equal 3, add(1, 2)\nend\nend\n\n# Run: rspec\n# Run: ruby test_math.rb"},{name:"Swift",lang:"swift",code:'// XCTest (built-in)\nimport XCTest\n@testable import MyModule\n\nclass MathTests: XCTestCase {\n  func testAdd() {\n      XCTAssertEqual(add(1, 2), 3)\n  }\n\n  func testNegative() {\n      XCTAssertEqual(add(-1, 1), 0)\n  }\n\n  func testZero() {\n      XCTAssertEqual(add(0, 0), 0)\n  }\n}\n\n// Swift Testing (Swift 5.9+)\nimport Testing\n\n@Test func addTwoNumbers() {\n  #expect(add(1, 2) == 3)\n}\n\n@Test("Parameterized", arguments: [\n  (1, 2, 3), (-1, 1, 0), (0, 0, 0)\n])\nfunc addVarious(a: Int, b: Int, expected: Int) {\n  #expect(add(a, b) == expected)\n}\n\n// Run: swift test'}]}),"\n",(0,a.jsx)(e.h2,{id:"mocking--advanced-testing",children:"Mocking & Advanced Testing"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Jest mocking\njest.mock('./api');\nconst api = require('./api');\n\napi.fetchUser.mockResolvedValue({ name: 'John' });\n\ntest('fetches user', async () => {\n  const user = await getUser(1);\n  expect(api.fetchUser).toHaveBeenCalledWith(1);\n  expect(user.name).toBe('John');\n});\n\n// Spies\nconst spy = jest.spyOn(console, 'log');\ndoSomething();\nexpect(spy).toHaveBeenCalledWith('expected');\n\n// Async testing\ntest('async operation', async () => {\n  await expect(fetchData()).resolves.toBe('data');\n  await expect(failOp()).rejects.toThrow('error');\n});"},{name:"PHP",lang:"php",code:"<?php\n// PHPUnit mocking\nclass UserServiceTest extends TestCase\n{\n  public function testGetUser(): void\n  {\n      $repo = $this->createMock(UserRepository::class);\n      $repo->method('find')\n           ->willReturn(new User('John'));\n\n      $service = new UserService($repo);\n      $user = $service->getUser(1);\n\n      $this->assertEquals('John', $user->getName());\n  }\n\n  // Data providers\n  /** @dataProvider additionProvider */\n  public function testAdd(int $a, int $b, int $expected): void\n  {\n      $this->assertEquals($expected, add($a, $b));\n  }\n\n  public static function additionProvider(): array\n  {\n      return [[1, 2, 3], [-1, 1, 0], [0, 0, 0]];\n  }\n}"},{name:"Rust",lang:"rust",code:'// Integration tests (tests/ directory)\n// File: tests/integration_test.rs\nuse my_crate::add;\n\n#[test]\nfn test_add_integration() {\n  assert_eq!(add(1, 2), 3);\n}\n\n// Mocking with mockall\nuse mockall::{automock, predicate::*};\n\n#[automock]\ntrait UserRepo {\n  fn find(&self, id: u32) -> Option<User>;\n}\n\n#[test]\nfn test_get_user() {\n  let mut mock = MockUserRepo::new();\n  mock.expect_find()\n      .with(eq(1))\n      .returning(|_| Some(User { name: "John".into() }));\n\n  let user = mock.find(1).unwrap();\n  assert_eq!(user.name, "John");\n}'},{name:"Go",lang:"go",code:'// Interfaces for mocking\ntype UserRepo interface {\n  Find(id int) (*User, error)\n}\n\ntype MockUserRepo struct {\n  FindFunc func(int) (*User, error)\n}\n\nfunc (m *MockUserRepo) Find(id int) (*User, error) {\n  return m.FindFunc(id)\n}\n\nfunc TestGetUser(t *testing.T) {\n  mock := &MockUserRepo{\n      FindFunc: func(id int) (*User, error) {\n          return &User{Name: "John"}, nil\n      },\n  }\n\n  user, err := mock.Find(1)\n  if err != nil {\n      t.Fatal(err)\n  }\n  if user.Name != "John" {\n      t.Errorf("got %s; want John", user.Name)\n  }\n}\n\n// Benchmarks\nfunc BenchmarkAdd(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n      Add(1, 2)\n  }\n}\n// Run: go test -bench=.'},{name:"Python",lang:"python",code:'# pytest with mocking\nfrom unittest.mock import Mock, patch, MagicMock\n\ndef test_get_user():\n  mock_repo = Mock()\n  mock_repo.find.return_value = User("John")\n\n  service = UserService(mock_repo)\n  user = service.get_user(1)\n\n  mock_repo.find.assert_called_once_with(1)\n  assert user.name == "John"\n\n# Patching\n@patch(\'mymodule.requests.get\')\ndef test_fetch(mock_get):\n  mock_get.return_value.json.return_value = {"name": "John"}\n  result = fetch_user(1)\n  assert result["name"] == "John"\n\n# Fixtures\nimport pytest\n\n@pytest.fixture\ndef user():\n  return User("John")\n\ndef test_user_name(user):\n  assert user.name == "John"'},{name:"Zig",lang:"zig",code:'const std = @import("std");\nconst testing = std.testing;\n\n// Test with allocator\ntest "arraylist operations" {\n  var list = std.ArrayList(i32).init(testing.allocator);\n  defer list.deinit();\n\n  try list.append(42);\n  try testing.expectEqual(@as(usize, 1), list.items.len);\n  try testing.expectEqual(@as(i32, 42), list.items[0]);\n}\n\n// Test error cases\ntest "division by zero returns error" {\n  const result = divide(10, 0);\n  try testing.expectError(error.DivisionByZero, result);\n}\n\n// Test with temporary directory\ntest "file operations" {\n  var tmp = testing.tmpDir(.{});\n  defer tmp.cleanup();\n  // test file operations in temporary directory\n}'},{name:"C#",lang:"csharp",code:'// Moq (popular mocking library)\nusing Moq;\n\n[Fact]\npublic void GetUser_ReturnsUser()\n{\n  var mockRepo = new Mock<IUserRepository>();\n  mockRepo.Setup(r => r.Find(1))\n          .Returns(new User("John"));\n\n  var service = new UserService(mockRepo.Object);\n  var user = service.GetUser(1);\n\n  Assert.Equal("John", user.Name);\n  mockRepo.Verify(r => r.Find(1), Times.Once);\n}\n\n// FluentAssertions\nuser.Name.Should().Be("John");\nlist.Should().HaveCount(3);\naction.Should().Throw<ArgumentException>();'},{name:"C++",lang:"cpp",code:'// Google Mock\nclass MockUserRepo : public UserRepo {\npublic:\n  MOCK_METHOD(User*, find, (int id), (override));\n};\n\nTEST(UserServiceTest, GetUser) {\n  MockUserRepo mock;\n  EXPECT_CALL(mock, find(1))\n      .WillOnce(Return(new User("John")));\n\n  UserService service(&mock);\n  auto user = service.getUser(1);\n\n  EXPECT_EQ(user->getName(), "John");\n}\n\n// Catch2 sections\nTEST_CASE("Vector operations", "[vector]") {\n  std::vector<int> v;\n\n  SECTION("push increases size") {\n      v.push_back(1);\n      REQUIRE(v.size() == 1);\n  }\n\n  SECTION("pop decreases size") {\n      v.push_back(1);\n      v.pop_back();\n      REQUIRE(v.empty());\n  }\n}'},{name:"C",lang:"c",code:"// CMocka framework\n#include <cmocka.h>\n\nstatic void test_add(void **state) {\n  (void)state;\n  assert_int_equal(add(1, 2), 3);\n}\n\nstatic void test_negative(void **state) {\n  (void)state;\n  assert_int_equal(add(-1, 1), 0);\n}\n\nint main(void) {\n  const struct CMUnitTest tests[] = {\n      cmocka_unit_test(test_add),\n      cmocka_unit_test(test_negative),\n  };\n  return cmocka_run_group_tests(tests, NULL, NULL);\n}\n\n// Function wrapping for mocking\nint __wrap_read_file(const char* path) {\n  check_expected(path);\n  return mock_type(int);\n}"},{name:"Java",lang:"java",code:'// Mockito\nimport static org.mockito.Mockito.*;\n\n@Test\nvoid testGetUser() {\n  UserRepo mockRepo = mock(UserRepo.class);\n  when(mockRepo.find(1))\n      .thenReturn(new User("John"));\n\n  UserService service = new UserService(mockRepo);\n  User user = service.getUser(1);\n\n  assertEquals("John", user.getName());\n  verify(mockRepo).find(1);\n}\n\n// AssertJ (fluent assertions)\nassertThat(user.getName()).isEqualTo("John");\nassertThat(list).hasSize(3).contains("item");\nassertThatThrownBy(() -> divide(1, 0))\n  .isInstanceOf(ArithmeticException.class);'},{name:"Ruby",lang:"ruby",code:"# RSpec mocking\nRSpec.describe UserService do\nit 'fetches user' do\n  repo = double('UserRepo')\n  allow(repo).to receive(:find).with(1)\n    .and_return(User.new('John'))\n\n  service = UserService.new(repo)\n  user = service.get_user(1)\n\n  expect(user.name).to eq('John')\n  expect(repo).to have_received(:find).with(1)\nend\n\n# Shared examples\nshared_examples 'a collection' do\n  it { is_expected.to respond_to(:each) }\n  it { is_expected.to respond_to(:size) }\nend\n\ndescribe Array do\n  it_behaves_like 'a collection'\nend\nend"},{name:"Swift",lang:"swift",code:'// XCTest with protocols for mocking\nprotocol UserRepository {\n  func find(id: Int) -> User?\n}\n\nclass MockUserRepo: UserRepository {\n  var findResult: User?\n  var findCallCount = 0\n\n  func find(id: Int) -> User? {\n      findCallCount += 1\n      return findResult\n  }\n}\n\nclass UserServiceTests: XCTestCase {\n  func testGetUser() {\n      let mock = MockUserRepo()\n      mock.findResult = User(name: "John")\n\n      let service = UserService(repo: mock)\n      let user = service.getUser(id: 1)\n\n      XCTAssertEqual(user?.name, "John")\n      XCTAssertEqual(mock.findCallCount, 1)\n  }\n\n  // Async testing\n  func testAsyncFetch() async throws {\n      let data = try await fetchData()\n      XCTAssertFalse(data.isEmpty)\n  }\n}'}]}),"\n",(0,a.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Built-in vs external frameworks"})," -- Rust, Go, and Zig ship with test runners; JavaScript, Python, PHP, and C++ rely on external tools (Jest, pytest, PHPUnit, Google Test)."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Assertion styles differ"})," -- Go uses manual ",(0,a.jsx)(e.code,{children:"if got != want { t.Errorf(...) }"}),"; xUnit/Jest use ",(0,a.jsx)(e.code,{children:"Assert.Equal"}),"/",(0,a.jsx)(e.code,{children:"expect().toBe"}),"; RSpec and FluentAssertions favor BDD-style ",(0,a.jsx)(e.code,{children:"expect(x).to eq(y)"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Mocking approaches vary"})," -- Interface-based mocking is common in Go and Swift; Java/C# use Mockito/Moq; Python uses ",(0,a.jsx)(e.code,{children:"unittest.mock"}),"; Rust uses crates like ",(0,a.jsx)(e.code,{children:"mockall"})," with trait-based mocks."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parameterized tests are idiomatic in some ecosystems"})," -- Go favors table-driven tests; xUnit uses ",(0,a.jsx)(e.code,{children:"[Theory]"})," and ",(0,a.jsx)(e.code,{children:"[InlineData]"}),"; JUnit 5 and Swift Testing have ",(0,a.jsx)(e.code,{children:"@ParameterizedTest"})," and ",(0,a.jsx)(e.code,{children:"@Test(arguments:)"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance testing is built-in for Go"})," -- ",(0,a.jsx)(e.code,{children:"go test -bench=."})," runs benchmarks; other languages typically use separate tools (pytest-benchmark, criterion for Rust, etc.)."]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(l,{...n})}):l(n)}}}]);