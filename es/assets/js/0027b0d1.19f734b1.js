"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[457],{1719(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"maps-dictionaries","title":"Mapas y Diccionarios","description":"Mapas hash, diccionarios y arreglos asociativos comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/maps-dictionaries.md","sourceDirName":".","slug":"/maps-dictionaries","permalink":"/language-comparison/es/docs/maps-dictionaries","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/maps-dictionaries.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"description":"Mapas hash, diccionarios y arreglos asociativos comparados en 12 lenguajes de programaci\xf3n","keywords":["mapas","diccionarios","mapas hash","arreglos asociativos","clave-valor"]},"sidebar":"tutorialSidebar","previous":{"title":"Objects & Structs","permalink":"/language-comparison/es/docs/objects-structs"},"next":{"title":"Classes & OOP","permalink":"/language-comparison/es/docs/classes-oop"}}');var i=a(4848),t=a(8453),r=a(6153);const o={sidebar_position:14,description:"Mapas hash, diccionarios y arreglos asociativos comparados en 12 lenguajes de programaci\xf3n",keywords:["mapas","diccionarios","mapas hash","arreglos asociativos","clave-valor"]},c="Mapas y Diccionarios",d={},p=[{value:"Creaci\xf3n y Acceso a Mapas",id:"creaci\xf3n-y-acceso-a-mapas",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mapas-y-diccionarios",children:"Mapas y Diccionarios"})}),"\n",(0,i.jsx)(n.p,{children:"Los mapas (tambi\xe9n conocidos como diccionarios, mapas hash o arreglos asociativos) almacenan pares clave-valor. As\xed es como los manejan los diferentes lenguajes."}),"\n","\n",(0,i.jsx)(n.h2,{id:"creaci\xf3n-y-acceso-a-mapas",children:"Creaci\xf3n y Acceso a Mapas"}),"\n",(0,i.jsx)(r.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Object (string keys only)\nconst obj = { name: "John", age: 30 };\nobj.name;         // "John"\nobj["age"];       // 30\n\n// Map (any key type)\nconst map = new Map();\nmap.set("key", "value");\nmap.set(42, "number key");\nmap.set(obj, "object key");\n\nmap.get("key");       // "value"\nmap.has("key");       // true\nmap.size;             // 3\nmap.delete("key");\n\n// Initialize Map\nconst map2 = new Map([\n  ["a", 1], ["b", 2], ["c", 3]\n]);\n\n// WeakMap (keys are garbage collected)\nconst weakMap = new WeakMap();\nweakMap.set(obj, "data");'},{name:"PHP",lang:"php",code:'<?php\n// Associative array\n$map = [\n  "name" => "John",\n  "age" => 30,\n];\n\n$map["name"];         // "John"\n$map["city"] = "NYC"; // Add\nisset($map["name"]);  // true\nunset($map["age"]);   // Delete\ncount($map);          // Size\n\n// Array functions\narray_key_exists("name", $map);  // true\narray_keys($map);       // ["name", "city"]\narray_values($map);     // ["John", "NYC"]\n\n// Merge\n$merged = array_merge($map1, $map2);\n\n// SplObjectStorage (object keys)\n$storage = new SplObjectStorage();\n$storage[$obj] = "data";'},{name:"Rust",lang:"rust",code:'use std::collections::HashMap;\n\n// Create\nlet mut map = HashMap::new();\nmap.insert("name", "John");\nmap.insert("city", "NYC");\n\n// Access\nmap.get("name");        // Some("John")\nmap["name"];            // "John" (panics if missing)\nmap.contains_key("name"); // true\n\n// Initialize with collect\nlet map: HashMap<&str, i32> = vec![\n  ("a", 1), ("b", 2), ("c", 3),\n].into_iter().collect();\n\n// Entry API (insert if missing)\nmap.entry("count")\n .or_insert(0);\n*map.entry("count").or_insert(0) += 1;\n\n// Remove\nmap.remove("name");\nmap.len();  // Size\n\n// BTreeMap (ordered)\nuse std::collections::BTreeMap;\nlet ordered = BTreeMap::new();'},{name:"Go",lang:"go",code:'// Create\nm := map[string]string{\n  "name": "John",\n  "city": "NYC",\n}\n\n// Access\nname := m["name"]         // "John"\nvalue, ok := m["missing"] // "", false\n\n// Check existence\nif val, ok := m["name"]; ok {\n  fmt.Println(val)\n}\n\n// Add / Update\nm["age"] = "30"\n\n// Delete\ndelete(m, "age")\n\n// Size\nlen(m)\n\n// Make with capacity\nm2 := make(map[string]int, 100)\n\n// Iterate\nfor key, value := range m {\n  fmt.Printf("%s: %s\\n", key, value)\n}'},{name:"Python",lang:"python",code:'# Dict literal\nd = {"name": "John", "age": 30}\n\n# Access\nd["name"]               # "John"\nd.get("name")           # "John"\nd.get("missing", "default")  # "default"\n\n# Add / Update\nd["city"] = "NYC"\nd.update({"city": "NYC", "zip": "10001"})\n\n# Delete\ndel d["age"]\nd.pop("age", None)  # Remove with default\n\n# Check\n"name" in d          # True\nlen(d)               # Size\n\n# Methods\nd.keys()             # dict_keys\nd.values()           # dict_values\nd.items()            # dict_items\n\n# Dict comprehension\nsquares = {x: x**2 for x in range(5)}\n\n# defaultdict\nfrom collections import defaultdict\ndd = defaultdict(list)\ndd["key"].append(1)  # Auto-creates list\n\n# OrderedDict (maintains insertion order)\n# Note: regular dict is ordered since Python 3.7'},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// HashMap\nvar map = std.StringHashMap(i32).init(allocator);\ndefer map.deinit();\n\n// Insert\ntry map.put("name", 42);\ntry map.put("age", 30);\n\n// Access\nconst value = map.get("name");  // ?i32\nif (map.get("name")) |v| {\n  std.debug.print("{d}\\n", .{v});\n}\n\n// Remove\n_ = map.remove("name");\n\n// Contains\nconst exists = map.contains("name");\n\n// Size\nconst size = map.count();\n\n// Iterate\nvar it = map.iterator();\nwhile (it.next()) |entry| {\n  std.debug.print("{s}: {d}\\n",\n      .{entry.key_ptr.*, entry.value_ptr.*});\n}\n\n// AutoHashMap (auto-managed)\nvar auto_map = std.AutoHashMap(i32, []const u8).init(allocator);'},{name:"C#",lang:"csharp",code:'// Dictionary\nvar dict = new Dictionary<string, string>\n{\n  ["name"] = "John",\n  ["city"] = "NYC",\n};\n\n// Access\ndict["name"];                // "John"\ndict.TryGetValue("name", out var value); // true\ndict.ContainsKey("name");    // true\n\n// Add / Update\ndict["age"] = "30";\ndict.Add("zip", "10001");   // Throws if exists\n\n// Remove\ndict.Remove("age");\ndict.Count;                  // Size\n\n// Iterate\nforeach (var (key, val) in dict)\n{\n  Console.WriteLine($"{key}: {val}");\n}\n\n// SortedDictionary (ordered by key)\nvar sorted = new SortedDictionary<string, int>();\n\n// ConcurrentDictionary (thread-safe)\nvar concurrent = new ConcurrentDictionary<string, int>();'},{name:"C++",lang:"cpp",code:'#include <map>\n#include <unordered_map>\n\n// unordered_map (hash map)\nstd::unordered_map<std::string, int> map;\nmap["name"] = 42;\nmap["age"] = 30;\n\n// Access\nmap["name"];                 // 42\nmap.at("name");              // 42 (throws if missing)\nmap.count("name");           // 1 or 0\nmap.find("name") != map.end(); // true\n\n// Insert\nmap.insert({"city", 1});\nmap.emplace("zip", 2);\n\n// Remove\nmap.erase("age");\nmap.size();\n\n// Initialize\nstd::unordered_map<std::string, int> m = {\n  {"a", 1}, {"b", 2}, {"c", 3}\n};\n\n// std::map (ordered, tree-based)\nstd::map<std::string, int> ordered;'},{name:"C",lang:"c",code:"// No built-in hash map\n// Common approaches:\n\n// Simple struct array\n#define MAX_ENTRIES 100\ntypedef struct {\n  char key[50];\n  int value;\n} Entry;\n\nEntry map[MAX_ENTRIES];\nint map_size = 0;\n\n// Add\nvoid map_put(const char* key, int value) {\n  strcpy(map[map_size].key, key);\n  map[map_size].value = value;\n  map_size++;\n}\n\n// Find (linear search)\nint* map_get(const char* key) {\n  for (int i = 0; i < map_size; i++) {\n      if (strcmp(map[i].key, key) == 0)\n          return &map[i].value;\n  }\n  return NULL;\n}\n\n// For real projects, use libraries like\n// uthash, glib GHashTable, etc."},{name:"Java",lang:"java",code:'// HashMap\nMap<String, Integer> map = new HashMap<>();\nmap.put("name", 42);\nmap.put("age", 30);\n\n// Access\nmap.get("name");           // 42\nmap.getOrDefault("missing", 0); // 0\nmap.containsKey("name");   // true\n\n// Add / Update\nmap.put("city", 1);\nmap.putIfAbsent("city", 2); // Won\'t overwrite\n\n// Remove\nmap.remove("age");\nmap.size();\n\n// Initialize (Java 9+)\nvar m = Map.of("a", 1, "b", 2, "c", 3);\n\n// Iterate\nfor (var entry : map.entrySet()) {\n  System.out.println(entry.getKey() + ": " + entry.getValue());\n}\nmap.forEach((k, v) -> System.out.println(k + ": " + v));\n\n// TreeMap (sorted)\nMap<String, Integer> sorted = new TreeMap<>();\n\n// ConcurrentHashMap (thread-safe)\nMap<String, Integer> concurrent = new ConcurrentHashMap<>();'},{name:"Ruby",lang:"ruby",code:'# Hash literal\nhash = { name: "John", age: 30 }\nhash2 = { "name" => "John", "age" => 30 }\n\n# Access\nhash[:name]              # "John"\nhash.fetch(:name)        # "John" (raises if missing)\nhash.fetch(:missing, "default")  # "default"\n\n# Add / Update\nhash[:city] = "NYC"\nhash.merge!({ zip: "10001" })\n\n# Delete\nhash.delete(:age)\nhash.size                # Size\n\n# Check\nhash.key?(:name)         # true\nhash.value?("John")      # true\n\n# Iterate\nhash.each { |k, v| puts "#{k}: #{v}" }\n\n# Transform\nhash.map { |k, v| [k, v.to_s] }.to_h\nhash.select { |k, v| v.is_a?(String) }\nhash.transform_values { |v| v.to_s }\n\n# Dig (nested access)\ndata = { user: { address: { city: "NYC" } } }\ndata.dig(:user, :address, :city)  # "NYC"'},{name:"Swift",lang:"swift",code:'// Dictionary literal\nvar dict: [String: Int] = [\n  "name": 42,\n  "age": 30,\n]\n\n// Access (returns Optional)\ndict["name"]               // Optional(42)\ndict["missing"]            // nil\ndict["missing", default: 0]  // 0\n\n// Add / Update\ndict["city"] = 1\ndict.updateValue(2, forKey: "city")\n\n// Remove\ndict.removeValue(forKey: "age")\ndict.count                 // Size\n\n// Check\ndict.keys.contains("name")  // true\n\n// Iterate\nfor (key, value) in dict {\n  print("\\(key): \\(value)")\n}\n\n// Transform\nlet mapped = dict.mapValues { $0 * 2 }\nlet filtered = dict.filter { $0.value > 10 }\n\n// Grouping\nlet grouped = Dictionary(grouping: items) { $0.category }'}]}),"\n",(0,i.jsx)(n.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Soporte de sintaxis incorporada"})," -- JavaScript, Python, Ruby, Go y Swift tienen sintaxis literal dedicada para mapas/diccionarios (por ejemplo, ",(0,i.jsx)(n.code,{children:'{"name": "John"}'})," en Python, ",(0,i.jsx)(n.code,{children:'map[string]string{"name": "John"}'})," en Go). C no tiene mapa hash incorporado y requiere bibliotecas como uthash o implementaci\xf3n manual. La sintaxis literal mejora la legibilidad y reduce el c\xf3digo repetitivo. Si trabajas frecuentemente con datos clave-valor (configuraci\xf3n, cach\xe9s, JSON), elige un lenguaje con soporte de mapas de primera clase; para C, planea integrar una biblioteca desde el inicio."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ordenado vs no ordenado"})," -- Los diccionarios de Python (3.7+), los arreglos de PHP y el ",(0,i.jsx)(n.code,{children:"Map"})," de JavaScript preservan el orden de inserci\xf3n. El ",(0,i.jsx)(n.code,{children:"HashMap"})," de Rust no est\xe1 ordenado; usa ",(0,i.jsx)(n.code,{children:"BTreeMap"})," para iteraci\xf3n ordenada por clave. Los mapas de Go no est\xe1n ordenados; el ",(0,i.jsx)(n.code,{children:"HashMap"})," de Java no est\xe1 ordenado (usa ",(0,i.jsx)(n.code,{children:"LinkedHashMap"})," para orden de inserci\xf3n). El orden importa para salida reproducible, cach\xe9s LRU o cuando el orden codifica significado. Prefiere Python, PHP o ",(0,i.jsx)(n.code,{children:"Map"})," de JavaScript cuando el orden es importante; ",(0,i.jsx)(n.code,{children:"BTreeMap"})," de Rust cuando necesitas claves ordenadas."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patrones de acceso seguro"})," -- El ",(0,i.jsx)(n.code,{children:'value, ok := m["key"]'})," de Go retorna un booleano de existencia; el sub\xedndice opcional de Swift (",(0,i.jsx)(n.code,{children:'dict["key"]'}),") retorna ",(0,i.jsx)(n.code,{children:"nil"})," para claves faltantes; el ",(0,i.jsx)(n.code,{children:'dict.get("key", default)'})," de Python y el ",(0,i.jsx)(n.code,{children:"hash.fetch(:key, default)"})," de Ruby evitan excepciones. El acceso directo por \xedndice en Rust (",(0,i.jsx)(n.code,{children:'map["key"]'}),") causa panic si la clave falta; en C++ ",(0,i.jsx)(n.code,{children:'map["key"]'})," crea una entrada con un valor por defecto. Usa acceso seguro cuando las claves pueden estar ausentes (por ejemplo, entrada de usuario, configuraci\xf3n opcional); acceso directo cuando las claves est\xe1n garantizadas."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tipos de clave y valor"})," -- Los objetos planos de JavaScript solo soportan claves de tipo string; ",(0,i.jsx)(n.code,{children:"Map"})," permite cualquier tipo incluyendo objetos. Los diccionarios de Python requieren claves hashables (por ejemplo, strings, n\xfameros, tuplas). Los mapas de Go requieren claves comparables. El ",(0,i.jsx)(n.code,{children:"HashMap"})," de Rust necesita claves que implementen ",(0,i.jsx)(n.code,{children:"Hash"})," y ",(0,i.jsx)(n.code,{children:"Eq"}),". Elige ",(0,i.jsx)(n.code,{children:"Map"})," en JavaScript cuando necesites claves que no sean strings; en Rust, considera ",(0,i.jsx)(n.code,{children:"BTreeMap"})," para tipos de clave personalizados que no implementen bien ",(0,i.jsx)(n.code,{children:"Hash"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Seguridad en hilos y concurrencia"})," -- El ",(0,i.jsx)(n.code,{children:"ConcurrentHashMap"})," de Java y el ",(0,i.jsx)(n.code,{children:"ConcurrentDictionary"})," de C# est\xe1n dise\xf1ados para acceso concurrente. Los mapas de Go no son seguros para escrituras concurrentes; usa ",(0,i.jsx)(n.code,{children:"sync.Map"})," o mutexes. El modelo de propiedad de Rust previene carreras de datos sin un tipo de mapa concurrente separado. Para estado mutable compartido entre hilos, prefiere Java o C#; en Go, envuelve los mapas con mutexes o usa ",(0,i.jsx)(n.code,{children:"sync.Map"}),"; en Rust, usa canales o ",(0,i.jsx)(n.code,{children:"Arc<Mutex<HashMap>>"}),"."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);