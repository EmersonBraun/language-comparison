"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[87],{1558:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"error-handling","title":"Error Handling","description":"Error handling mechanisms vary significantly across languages. Here\'s how different languages handle errors and exceptions.","source":"@site/docs/error-handling.md","sourceDirName":".","slug":"/error-handling","permalink":"/language-comparison/es/docs/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/error-handling.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Objects & Structs","permalink":"/language-comparison/es/docs/objects-structs"},"next":{"title":"Classes & OOP","permalink":"/language-comparison/es/docs/classes-oop"}}');var o=r(4848),s=r(8453),i=r(2061);const a={},c="Error Handling",l={},d=[{value:"Basic Error Handling",id:"basic-error-handling",level:2},{value:"Advanced Error Handling Patterns",id:"advanced-error-handling-patterns",level:2}];function p(n){const e={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(e.p,{children:"Error handling mechanisms vary significantly across languages. Here's how different languages handle errors and exceptions."}),"\n","\n",(0,o.jsx)(e.h2,{id:"basic-error-handling",children:"Basic Error Handling"}),"\n",(0,o.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (error) {\n  console.error("Error:", error.message);\n} finally {\n  cleanup();\n}\n\n// Throwing errors\nthrow new Error("Something went wrong");\n\n// Custom errors\nclass CustomError extends Error {\n  constructor(message) {\n      super(message);\n      this.name = "CustomError";\n  }\n}'},{name:"PHP",lang:"php",code:'<?php\n// Try-catch\ntry {\n  riskyOperation();\n} catch (Exception $e) {\n  echo "Error: " . $e->getMessage();\n} finally {\n  cleanup();\n}\n\n// Throwing exceptions\nthrow new Exception("Something went wrong");\n\n// Custom exceptions\nclass CustomException extends Exception {\n  public function __construct($message) {\n      parent::__construct($message);\n  }\n}'},{name:"Rust",lang:"rust",code:'// Result type\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n  if b == 0.0 {\n      Err("Division by zero".to_string())\n  } else {\n      Ok(a / b)\n  }\n}\n\n// Using Result\nmatch divide(10.0, 2.0) {\n  Ok(result) => println!("Result: {}", result),\n  Err(e) => println!("Error: {}", e),\n}\n\n// Option type\nfn find_item(items: &[i32], target: i32) -> Option<usize> {\n  items.iter().position(|&x| x == target)\n}'},{name:"Go",lang:"go",code:'// Error return\nfunc divide(a, b float64) (float64, error) {\n  if b == 0 {\n      return 0, fmt.Errorf("division by zero")\n  }\n  return a / b, nil\n}\n\n// Using errors\nresult, err := divide(10, 2)\nif err != nil {\n  log.Fatal(err)\n}\nfmt.Println(result)\n\n// Custom error type\ntype DivisionError struct {\n  Message string\n}\n\nfunc (e *DivisionError) Error() string {\n  return e.Message\n}'},{name:"Python",lang:"python",code:'# Try-except\ntry:\n  risky_operation()\nexcept ValueError as e:\n  print(f"Error: {e}")\nexcept Exception as e:\n  print(f"Unexpected error: {e}")\nelse:\n  print("No errors")\nfinally:\n  cleanup()\n\n# Raising exceptions\nraise ValueError("Something went wrong")\n\n# Custom exceptions\nclass CustomError(Exception):\n  def __init__(self, message):\n      self.message = message\n      super().__init__(self.message)'},{name:"Zig",lang:"zig",code:'// Error union type\nfn divide(a: f64, b: f64) !f64 {\n  if (b == 0) return error.DivisionByZero;\n  return a / b;\n}\n\n// Using error union\nconst result = divide(10, 2) catch |err| {\n  std.debug.print("Error: {}\\n", .{err});\n  return;\n};\n\n// Error sets\nconst MathError = error{\n  DivisionByZero,\n  Overflow,\n};'},{name:"C#",lang:"csharp",code:'// Try-catch\ntry\n{\n  RiskyOperation();\n}\ncatch (ArgumentException ex)\n{\n  Console.WriteLine($"Error: {ex.Message}");\n}\ncatch (Exception ex)\n{\n  Console.WriteLine($"Unexpected error: {ex.Message}");\n}\nfinally\n{\n  Cleanup();\n}\n\n// Throwing exceptions\nthrow new ArgumentException("Something went wrong");\n\n// Custom exceptions\npublic class CustomException : Exception\n{\n  public CustomException(string message) : base(message) { }\n}'},{name:"C++",lang:"cpp",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (const std::exception& e) {\n  std::cerr << "Error: " << e.what() << std::endl;\n} catch (...) {\n  std::cerr << "Unknown error" << std::endl;\n}\n\n// Throwing exceptions\nthrow std::runtime_error("Something went wrong");\n\n// Custom exceptions\nclass CustomException : public std::exception {\n  const char* what() const noexcept override {\n      return "Custom error";\n  }\n};'},{name:"C",lang:"c",code:'// No built-in exceptions\n// Use return codes and error handling\n\nint divide(double a, double b, double* result) {\n  if (b == 0) {\n      return -1;  // Error code\n  }\n  *result = a / b;\n  return 0;  // Success\n}\n\n// Using error codes\ndouble result;\nif (divide(10, 2, &result) != 0) {\n  fprintf(stderr, "Division by zero\\n");\n  return;\n}\nprintf("Result: %f\\n", result);'},{name:"Java",lang:"java",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (IllegalArgumentException e) {\n  System.err.println("Error: " + e.getMessage());\n} catch (Exception e) {\n  System.err.println("Unexpected error: " + e.getMessage());\n} finally {\n  cleanup();\n}\n\n// Throwing exceptions\nthrow new IllegalArgumentException("Something went wrong");\n\n// Custom exceptions\npublic class CustomException extends Exception {\n  public CustomException(String message) {\n      super(message);\n  }\n}'},{name:"Ruby",lang:"ruby",code:'# Begin-rescue\nbegin\n  risky_operation\nrescue ArgumentError => e\n  puts "Error: #{e.message}"\nrescue => e\n  puts "Unexpected error: #{e.message}"\nensure\n  cleanup\nend\n\n# Raising exceptions\nraise ArgumentError, "Something went wrong"\n\n# Custom exceptions\nclass CustomError < StandardError\n  def initialize(message)\n      super(message)\n  end\nend'},{name:"Swift",lang:"swift",code:'// Do-catch\ndo {\n  try riskyOperation()\n} catch let error as CustomError {\n  print("Error: \\(error)")\n} catch {\n  print("Unexpected error: \\(error)")\n}\n\n// Throwing errors\nthrow CustomError.somethingWentWrong\n\n// Error protocol\nenum CustomError: Error {\n  case somethingWentWrong\n  case invalidInput(String)\n  \n  var localizedDescription: String {\n      switch self {\n      case .somethingWentWrong:\n          return "Something went wrong"\n      case .invalidInput(let message):\n          return "Invalid input: \\(message)"\n      }\n  }\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"advanced-error-handling-patterns",children:"Advanced Error Handling Patterns"}),"\n",(0,o.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Promise error handling\nfetch('/api/data')\n  .then(response => response.json())\n  .catch(error => console.error(\"Error:\", error));\n\n// Async/await\nasync function fetchData() {\n  try {\n      const response = await fetch('/api/data');\n      return await response.json();\n  } catch (error) {\n      console.error(\"Error:\", error);\n      throw error;\n  }\n}\n\n// Error boundaries (React)\nclass ErrorBoundary extends React.Component {\n  componentDidCatch(error, errorInfo) {\n      logErrorToService(error, errorInfo);\n  }\n}"},{name:"PHP",lang:"php",code:'<?php\n// Error handling with set_error_handler\nset_error_handler(function($severity, $message, $file, $line) {\n  throw new ErrorException($message, 0, $severity, $file, $line);\n});\n\n// Exception chaining\ntry {\n  // code\n} catch (Exception $e) {\n  throw new CustomException("New error", 0, $e);\n}'},{name:"Rust",lang:"rust",code:'// Error propagation with ?\nfn read_file(path: &str) -> Result<String, io::Error> {\n  let mut file = File::open(path)?;\n  let mut contents = String::new();\n  file.read_to_string(&mut contents)?;\n  Ok(contents)\n}\n\n// Combinators\nlet result = divide(10, 2)\n  .map(|x| x * 2)\n  .map_err(|e| format!("Error: {}", e));\n\n// Unwrap with custom message\nlet value = divide(10, 2)\n  .expect("Failed to divide");'},{name:"Go",lang:"go",code:'// Error wrapping (Go 1.13+)\nif err != nil {\n  return fmt.Errorf("failed to process: %w", err)\n}\n\n// Error checking\nif errors.Is(err, ErrNotFound) {\n  // handle not found\n}\n\n// Error unwrapping\nvar targetErr *CustomError\nif errors.As(err, &targetErr) {\n  // handle custom error\n}'},{name:"Python",lang:"python",code:"# Exception chaining\ntry:\n  risky_operation()\nexcept ValueError as e:\n  raise RuntimeError(\"Failed\") from e\n\n# Context managers for cleanup\nwith open('file.txt') as f:\n  content = f.read()\n# File automatically closed\n\n# Suppressing exceptions\nfrom contextlib import suppress\nwith suppress(FileNotFoundError):\n  os.remove('file.txt')"},{name:"Zig",lang:"zig",code:'// Error propagation\nfn read_file(path: []const u8) ![]const u8 {\n  const file = try std.fs.cwd().openFile(path, .{});\n  defer file.close();\n  return try file.reader().readAllAlloc(allocator, 1024);\n}\n\n// Catching specific errors\nconst result = read_file("data.txt") catch |err| switch (err) {\n  error.FileNotFound => "default content",\n  else => return err,\n};'},{name:"C#",lang:"csharp",code:'// Using statement (automatic disposal)\nusing var file = new FileStream("data.txt", FileMode.Open);\n// Automatically disposed\n\n// Exception filters (C# 6+)\ntry {\n  ProcessData();\n}\ncatch (Exception ex) when (ex.Message.Contains("timeout"))\n{\n  // Handle timeout\n}\n\n// AggregateException\nvar exceptions = new List<Exception>();\n// ... collect exceptions\nthrow new AggregateException(exceptions);'},{name:"C++",lang:"cpp",code:'// RAII (Resource Acquisition Is Initialization)\n{\n  std::ifstream file("data.txt");\n  // File automatically closed when out of scope\n}\n\n// Exception specifications (deprecated, use noexcept)\nvoid function() noexcept {\n  // Function that doesn\'t throw\n}\n\n// Nested exceptions\ntry {\n  // outer code\n} catch (...) {\n  std::throw_with_nested(std::runtime_error("Outer error"));\n}'},{name:"C",lang:"c",code:'// Error codes with errno\n#include <errno.h>\n\nFILE* file = fopen("data.txt", "r");\nif (file == NULL) {\n  perror("Error opening file");\n  // errno contains error code\n}\n\n// setjmp/longjmp (not recommended)\n#include <setjmp.h>\njmp_buf env;\nif (setjmp(env) == 0) {\n  // code that might call longjmp\n} else {\n  // error handling\n}'},{name:"Java",lang:"java",code:'// Try-with-resources (automatic close)\ntry (FileReader file = new FileReader("data.txt")) {\n  // use file\n} // automatically closed\n\n// Multi-catch (Java 7+)\ntry {\n  process();\n} catch (IOException | SQLException e) {\n  // handle both\n}\n\n// Suppressed exceptions\ntry (Resource1 r1 = ...; Resource2 r2 = ...) {\n  // if both throw, one is suppressed\n}'},{name:"Ruby",lang:"ruby",code:"# Retry mechanism\nretries = 0\nbegin\n  risky_operation\nrescue => e\n  retries += 1\n  retry if retries < 3\n  raise\nend\n\n# Exception hierarchy\nbegin\n  # code\nrescue StandardError => e\n  # catches most exceptions\nrescue => e\n  # catches all exceptions\nend"},{name:"Swift",lang:"swift",code:'// Result type (alternative to throwing)\nfunc fetchData() -> Result<String, NetworkError> {\n  // return .success("data") or .failure(.timeout)\n}\n\n// Using Result\nswitch fetchData() {\ncase .success(let data):\n  print(data)\ncase .failure(let error):\n  print("Error: \\(error)")\n}\n\n// Defer for cleanup\nfunc processFile() {\n  let file = openFile()\n  defer { closeFile(file) }\n  // file will be closed when function exits\n}'}]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}}}]);