"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[979],{3299(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"file-io","title":"E/S de Archivos","description":"Lectura, escritura y manipulaci\xf3n de archivos comparadas en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/file-io.md","sourceDirName":".","slug":"/file-io","permalink":"/language-comparison/es/docs/file-io","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/file-io.md","tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19,"description":"Lectura, escritura y manipulaci\xf3n de archivos comparadas en 12 lenguajes de programaci\xf3n","keywords":["E/S de archivos","lectura de archivos","escritura de archivos","sistema de archivos","streams"]},"sidebar":"tutorialSidebar","previous":{"title":"Dates","permalink":"/language-comparison/es/docs/dates"},"next":{"title":"JSON & Serialization","permalink":"/language-comparison/es/docs/json-serialization"}}');var r=t(4848),a=t(8453),l=t(6153);const o={sidebar_position:19,description:"Lectura, escritura y manipulaci\xf3n de archivos comparadas en 12 lenguajes de programaci\xf3n",keywords:["E/S de archivos","lectura de archivos","escritura de archivos","sistema de archivos","streams"]},s="E/S de Archivos",d={},c=[{value:"Lectura de Archivos",id:"lectura-de-archivos",level:2},{value:"Escritura de Archivos",id:"escritura-de-archivos",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function f(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"es-de-archivos",children:"E/S de Archivos"})}),"\n",(0,r.jsx)(n.p,{children:"Leer y escribir archivos es una operaci\xf3n fundamental. As\xed es como los diferentes lenguajes manejan las operaciones de archivos."}),"\n","\n",(0,r.jsx)(n.h2,{id:"lectura-de-archivos",children:"Lectura de Archivos"}),"\n",(0,r.jsx)(l.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Synchronous\nconst data = fs.readFileSync('file.txt', 'utf8');\n\n// Asynchronous (callback)\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Async/await (modern)\nconst data2 = await fsPromises.readFile('file.txt', 'utf8');\n\n// Read line by line\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: fs.createReadStream('file.txt'),\n});\nfor await (const line of rl) {\n  console.log(line);\n}"},{name:"PHP",lang:"php",code:"<?php\n// Read entire file\n$content = file_get_contents('file.txt');\n\n// Read into array of lines\n$lines = file('file.txt', FILE_IGNORE_NEW_LINES);\n\n// Read with fopen\n$fp = fopen('file.txt', 'r');\nwhile (($line = fgets($fp)) !== false) {\n  echo $line;\n}\nfclose($fp);\n\n// Read binary\n$data = file_get_contents('image.png');\n\n// Read CSV\n$fp = fopen('data.csv', 'r');\nwhile (($row = fgetcsv($fp)) !== false) {\n  print_r($row);\n}\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::{self, BufRead, Read};\n\n// Read entire file to string\nlet content = fs::read_to_string("file.txt")?;\n\n// Read to bytes\nlet bytes = fs::read("file.txt")?;\n\n// Read line by line\nlet file = fs::File::open("file.txt")?;\nlet reader = io::BufReader::new(file);\nfor line in reader.lines() {\n  let line = line?;\n  println!("{}", line);\n}\n\n// Read with buffer\nlet mut file = fs::File::open("file.txt")?;\nlet mut buffer = String::new();\nfile.read_to_string(&mut buffer)?;'},{name:"Go",lang:"go",code:'import (\n  "bufio"\n  "os"\n  "io"\n)\n\n// Read entire file\ndata, err := os.ReadFile("file.txt")\nif err != nil {\n  log.Fatal(err)\n}\nfmt.Println(string(data))\n\n// Read line by line\nfile, _ := os.Open("file.txt")\ndefer file.Close()\n\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n  fmt.Println(scanner.Text())\n}\n\n// Read with io.ReadAll\nfile, _ := os.Open("file.txt")\ndefer file.Close()\ndata, _ := io.ReadAll(file)'},{name:"Python",lang:"python",code:"# Read entire file\nwith open('file.txt', 'r') as f:\n  content = f.read()\n\n# Read all lines\nwith open('file.txt', 'r') as f:\n  lines = f.readlines()\n\n# Read line by line (memory efficient)\nwith open('file.txt', 'r') as f:\n  for line in f:\n      print(line.strip())\n\n# Read binary\nwith open('image.png', 'rb') as f:\n  data = f.read()\n\n# Read with encoding\nwith open('file.txt', 'r', encoding='utf-8') as f:\n  content = f.read()\n\n# pathlib (modern)\nfrom pathlib import Path\ncontent = Path('file.txt').read_text()"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Read entire file\nconst content = try std.fs.cwd().readFileAlloc(\n  allocator, "file.txt", 1024 * 1024\n);\ndefer allocator.free(content);\n\n// Read with file handle\nconst file = try std.fs.cwd().openFile("file.txt", .{});\ndefer file.close();\n\nvar buf: [1024]u8 = undefined;\nconst bytes_read = try file.read(&buf);\n\n// Read line by line\nvar buf_reader = std.io.bufferedReader(file.reader());\nvar line_buf: [4096]u8 = undefined;\nwhile (try buf_reader.reader().readUntilDelimiterOrEof(\n  &line_buf, \'\\n\'\n)) |line| {\n  std.debug.print("{s}\\n", .{line});\n}'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Read entire file\nstring content = File.ReadAllText("file.txt");\n\n// Read all lines\nstring[] lines = File.ReadAllLines("file.txt");\n\n// Read line by line\nforeach (string line in File.ReadLines("file.txt"))\n{\n  Console.WriteLine(line);\n}\n\n// StreamReader\nusing var reader = new StreamReader("file.txt");\nstring? line;\nwhile ((line = reader.ReadLine()) != null)\n{\n  Console.WriteLine(line);\n}\n\n// Async\nstring content2 = await File.ReadAllTextAsync("file.txt");\n\n// Read bytes\nbyte[] bytes = File.ReadAllBytes("file.bin");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n#include <sstream>\n#include <string>\n\n// Read entire file\nstd::ifstream file("file.txt");\nstd::stringstream buffer;\nbuffer << file.rdbuf();\nstd::string content = buffer.str();\n\n// Read line by line\nstd::ifstream file("file.txt");\nstd::string line;\nwhile (std::getline(file, line)) {\n  std::cout << line << std::endl;\n}\n\n// Read binary\nstd::ifstream file("data.bin", std::ios::binary);\nstd::vector<char> data(\n  (std::istreambuf_iterator<char>(file)),\n  std::istreambuf_iterator<char>()\n);\n\n// Check if file exists (C++17)\n#include <filesystem>\nif (std::filesystem::exists("file.txt")) { }'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Read entire file\nFILE* fp = fopen("file.txt", "r");\nif (fp == NULL) { perror("Error"); return 1; }\n\nfseek(fp, 0, SEEK_END);\nlong size = ftell(fp);\nrewind(fp);\n\nchar* buffer = malloc(size + 1);\nfread(buffer, 1, size, fp);\nbuffer[size] = \'\\0\';\nfclose(fp);\n\n// Read line by line\nFILE* fp = fopen("file.txt", "r");\nchar line[256];\nwhile (fgets(line, sizeof(line), fp)) {\n  printf("%s", line);\n}\nfclose(fp);\n\n// Read binary\nFILE* fp = fopen("data.bin", "rb");\nunsigned char buf[1024];\nsize_t n = fread(buf, 1, sizeof(buf), fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\nimport java.io.*;\n\n// Read entire file (Java 11+)\nString content = Files.readString(Path.of("file.txt"));\n\n// Read all lines\nList<String> lines = Files.readAllLines(Path.of("file.txt"));\n\n// Read line by line (buffered)\ntry (BufferedReader reader =\n      Files.newBufferedReader(Path.of("file.txt"))) {\n  String line;\n  while ((line = reader.readLine()) != null) {\n      System.out.println(line);\n  }\n}\n\n// Stream lines\nFiles.lines(Path.of("file.txt"))\n   .forEach(System.out::println);\n\n// Read bytes\nbyte[] bytes = Files.readAllBytes(Path.of("file.bin"));'},{name:"Ruby",lang:"ruby",code:"# Read entire file\ncontent = File.read('file.txt')\n\n# Read all lines\nlines = File.readlines('file.txt', chomp: true)\n\n# Read line by line\nFile.foreach('file.txt') do |line|\nputs line.chomp\nend\n\n# Read with block (auto-closes)\nFile.open('file.txt', 'r') do |f|\ncontent = f.read\nend\n\n# Read binary\ndata = File.binread('image.png')\n\n# Check file existence\nFile.exist?('file.txt')  # true/false"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Read entire file\nlet content = try String(\n  contentsOfFile: "file.txt",\n  encoding: .utf8\n)\n\n// Read with URL\nlet url = URL(fileURLWithPath: "file.txt")\nlet data = try Data(contentsOf: url)\nlet text = String(data: data, encoding: .utf8)!\n\n// Read line by line\nif let contents = try? String(contentsOfFile: "file.txt") {\n  for line in contents.components(separatedBy: "\\n") {\n      print(line)\n  }\n}\n\n// FileManager\nlet fm = FileManager.default\nif fm.fileExists(atPath: "file.txt") {\n  let data = fm.contents(atPath: "file.txt")\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"escritura-de-archivos",children:"Escritura de Archivos"}),"\n",(0,r.jsx)(l.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Write (overwrite)\nfs.writeFileSync('output.txt', 'Hello World');\n\n// Write async\nawait fsPromises.writeFile('output.txt', 'Hello World');\n\n// Append\nfs.appendFileSync('output.txt', '\\nNew line');\n\n// Write with stream\nconst stream = fs.createWriteStream('output.txt');\nstream.write('Line 1\\n');\nstream.write('Line 2\\n');\nstream.end();"},{name:"PHP",lang:"php",code:"<?php\n// Write (overwrite)\nfile_put_contents('output.txt', 'Hello World');\n\n// Append\nfile_put_contents('output.txt', \"\\nNew line\", FILE_APPEND);\n\n// Write with fopen\n$fp = fopen('output.txt', 'w');\nfwrite($fp, \"Line 1\\n\");\nfwrite($fp, \"Line 2\\n\");\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::Write;\n\n// Write (overwrite)\nfs::write("output.txt", "Hello World")?;\n\n// Write with file handle\nlet mut file = fs::File::create("output.txt")?;\nfile.write_all(b"Hello World")?;\n\n// Append\nuse std::fs::OpenOptions;\nlet mut file = OpenOptions::new()\n  .append(true)\n  .open("output.txt")?;\nwriteln!(file, "New line")?;'},{name:"Go",lang:"go",code:'import "os"\n\n// Write (overwrite)\nos.WriteFile("output.txt", []byte("Hello World"), 0644)\n\n// Write with file handle\nfile, _ := os.Create("output.txt")\ndefer file.Close()\nfile.WriteString("Hello World\\n")\n\n// Append\nfile, _ := os.OpenFile("output.txt",\n  os.O_APPEND|os.O_WRONLY, 0644)\ndefer file.Close()\nfile.WriteString("New line\\n")\n\n// Buffered writer\nwriter := bufio.NewWriter(file)\nwriter.WriteString("Buffered content\\n")\nwriter.Flush()'},{name:"Python",lang:"python",code:"# Write (overwrite)\nwith open('output.txt', 'w') as f:\n  f.write('Hello World')\n\n# Append\nwith open('output.txt', 'a') as f:\n  f.write('\\nNew line')\n\n# Write multiple lines\nlines = ['Line 1', 'Line 2', 'Line 3']\nwith open('output.txt', 'w') as f:\n  f.writelines(line + '\\n' for line in lines)\n\n# pathlib (modern)\nfrom pathlib import Path\nPath('output.txt').write_text('Hello World')"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Write (overwrite)\nconst file = try std.fs.cwd().createFile("output.txt", .{});\ndefer file.close();\ntry file.writeAll("Hello World");\n\n// Write formatted\nconst writer = file.writer();\ntry writer.print("Value: {d}\\n", .{42});\n\n// Append\nconst file = try std.fs.cwd().openFile("output.txt", .{\n  .mode = .write_only,\n});\ndefer file.close();\ntry file.seekFromEnd(0);\ntry file.writeAll("New line\\n");'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Write (overwrite)\nFile.WriteAllText("output.txt", "Hello World");\n\n// Write lines\nFile.WriteAllLines("output.txt",\n  new[] { "Line 1", "Line 2" });\n\n// Append\nFile.AppendAllText("output.txt", "\\nNew line");\n\n// StreamWriter\nusing var writer = new StreamWriter("output.txt");\nwriter.WriteLine("Line 1");\nwriter.WriteLine("Line 2");\n\n// Async\nawait File.WriteAllTextAsync("output.txt", "Hello");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n\n// Write (overwrite)\nstd::ofstream file("output.txt");\nfile << "Hello World" << std::endl;\nfile.close();\n\n// Append\nstd::ofstream file("output.txt", std::ios::app);\nfile << "New line" << std::endl;\n\n// Write binary\nstd::ofstream file("data.bin", std::ios::binary);\nfile.write(reinterpret_cast<char*>(&data), sizeof(data));'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Write (overwrite)\nFILE* fp = fopen("output.txt", "w");\nfprintf(fp, "Hello World\\n");\nfclose(fp);\n\n// Append\nFILE* fp = fopen("output.txt", "a");\nfprintf(fp, "New line\\n");\nfclose(fp);\n\n// Write binary\nFILE* fp = fopen("data.bin", "wb");\nfwrite(data, sizeof(data[0]), count, fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\n\n// Write (overwrite) - Java 11+\nFiles.writeString(Path.of("output.txt"), "Hello World");\n\n// Write lines\nFiles.write(Path.of("output.txt"),\n  List.of("Line 1", "Line 2"));\n\n// Append\nFiles.writeString(Path.of("output.txt"), "\\nNew line",\n  StandardOpenOption.APPEND);\n\n// BufferedWriter\ntry (BufferedWriter writer =\n      Files.newBufferedWriter(Path.of("output.txt"))) {\n  writer.write("Line 1");\n  writer.newLine();\n}'},{name:"Ruby",lang:"ruby",code:"# Write (overwrite)\nFile.write('output.txt', 'Hello World')\n\n# Append\nFile.open('output.txt', 'a') do |f|\nf.puts 'New line'\nend\n\n# Write with block\nFile.open('output.txt', 'w') do |f|\nf.puts 'Line 1'\nf.puts 'Line 2'\nend\n\n# Write binary\nFile.binwrite('data.bin', binary_data)"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Write (overwrite)\ntry "Hello World".write(\n  toFile: "output.txt",\n  atomically: true,\n  encoding: .utf8\n)\n\n// Write with Data\nlet data = "Hello".data(using: .utf8)!\ntry data.write(to: URL(fileURLWithPath: "output.txt"))\n\n// Append\nlet handle = try FileHandle(\n  forWritingTo: URL(fileURLWithPath: "output.txt")\n)\nhandle.seekToEndOfFile()\nhandle.write("New line\\n".data(using: .utf8)!)\nhandle.closeFile()'}]}),"\n",(0,r.jsx)(n.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"APIs s\xedncronas y as\xedncronas coexisten"})," \u2014 La mayor\xeda de los lenguajes ofrecen ambas: Node.js tiene ",(0,r.jsx)(n.code,{children:"fs.readFileSync"})," y ",(0,r.jsx)(n.code,{children:"fs.promises.readFile"}),"; C# tiene ",(0,r.jsx)(n.code,{children:"File.ReadAllText"})," y ",(0,r.jsx)(n.code,{children:"File.ReadAllTextAsync"}),"; el ",(0,r.jsx)(n.code,{children:"open()"})," de Python es s\xedncrono por defecto, aunque ",(0,r.jsx)(n.code,{children:"asyncio"})," puede envolverlo. Para cargas de trabajo con mucha E/S (por ejemplo, servidores web leyendo muchos archivos), prefiere async para evitar bloqueos; para scripts o herramientas CLI, sync suele ser m\xe1s simple. Elige un lenguaje que soporte tu modelo de concurrencia\u2014Node.js y C# son async-first; Rust ofrece ",(0,r.jsx)(n.code,{children:"tokio"})," para E/S de archivos as\xedncrona."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Los patrones de limpieza de recursos difieren"})," \u2014 El ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," de Python y el ",(0,r.jsx)(n.code,{children:"using"}),"/try-with-resources de C#/Java, m\xe1s el RAII de Rust, garantizan el cierre incluso ante errores. Go usa ",(0,r.jsx)(n.code,{children:"defer file.Close()"})," que se ejecuta cuando la funci\xf3n retorna. C y Zig requieren ",(0,r.jsx)(n.code,{children:"fclose"})," o ",(0,r.jsx)(n.code,{children:"file.close()"})," expl\xedcito\u2014si ocurre un error antes del cierre, el handle puede fugarse. Prefiere patrones basados en bloques o RAII cuando est\xe9n disponibles; en C o Zig, estructura el c\xf3digo para que cada ",(0,r.jsx)(n.code,{children:"open"})," tenga un ",(0,r.jsx)(n.code,{children:"close"})," correspondiente en la misma ruta de control."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"El manejo de codificaci\xf3n es expl\xedcito en algunos lenguajes"})," \u2014 Python y Node.js aceptan ",(0,r.jsx)(n.code,{children:"encoding='utf-8'"})," al leer texto; C# usa UTF-8 por defecto en APIs m\xe1s nuevas. C y C++ tratan los archivos como bytes crudos; debes usar bibliotecas o conversi\xf3n manual para UTF-8. Zig expone APIs de bytes de bajo nivel\u2014",(0,r.jsx)(n.code,{children:"readFileAlloc"})," retorna ",(0,r.jsx)(n.code,{children:"[]u8"}),", y t\xfa manejas la decodificaci\xf3n de strings. Para texto internacional, prefiere Python, C# o Java; para binario o cuando necesitas control total, C/C++/Zig son apropiados."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Helpers de alto nivel vs control manual"})," \u2014 C#, Python y Java ofrecen ",(0,r.jsx)(n.code,{children:"File.ReadAllText"}),", ",(0,r.jsx)(n.code,{children:"Path('file.txt').read_text()"})," y ",(0,r.jsx)(n.code,{children:'Files.readString(Path.of("file.txt"))'})," para lecturas en una l\xednea. C y Zig requieren asignaci\xf3n manual de buffers, bucles ",(0,r.jsx)(n.code,{children:"fread"}),"/",(0,r.jsx)(n.code,{children:"read"})," y terminaci\xf3n nula. Las APIs de alto nivel son convenientes pero pueden cargar archivos completos en memoria; para archivos grandes, usa streaming (por ejemplo, ",(0,r.jsx)(n.code,{children:"File.ReadLines"}),", ",(0,r.jsx)(n.code,{children:"BufferedReader"})," o ",(0,r.jsx)(n.code,{children:"BufReader"})," de Rust). Elige helpers para archivos peque\xf1os; usa streams cuando la memoria o la latencia importen."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Las APIs basadas en bloques evitan fugas"})," \u2014 El ",(0,r.jsx)(n.code,{children:"File.open('file.txt') { |f| }"})," de Ruby y el ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," de Python garantizan el cierre incluso cuando ocurren excepciones. El ",(0,r.jsx)(n.code,{children:"fclose"})," expl\xedcito en C y PHP puede causar fugas si ocurre un error antes del cierre\u2014por ejemplo, un ",(0,r.jsx)(n.code,{children:"return"})," o ",(0,r.jsx)(n.code,{children:"throw"})," en medio del procesamiento. Siempre prefiere patrones basados en bloques o RAII cuando est\xe9n disponibles; en C, considera usar ",(0,r.jsx)(n.code,{children:"goto"})," a una etiqueta de limpieza o un patr\xf3n de wrapper m\xednimo para centralizar la l\xf3gica de cierre."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}}}]);