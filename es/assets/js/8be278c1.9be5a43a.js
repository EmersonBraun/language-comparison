"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[769],{8882(e,n,a){a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"memory-management","title":"Memory Management","description":"Memory management -- garbage collection, ownership, and manual memory across 12 languages","source":"@site/docs/memory-management.md","sourceDirName":".","slug":"/memory-management","permalink":"/language-comparison/es/docs/memory-management","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/memory-management.md","tags":[],"version":"current","sidebarPosition":25,"frontMatter":{"sidebar_position":25,"description":"Memory management -- garbage collection, ownership, and manual memory across 12 languages","keywords":["memory management","garbage collection","ownership","RAII","smart pointers","ARC"]},"sidebar":"tutorialSidebar","previous":{"title":"Concurrency & Async","permalink":"/language-comparison/es/docs/concurrency-async"},"next":{"title":"Modules & Imports","permalink":"/language-comparison/es/docs/modules-imports"}}');var r=a(4848),o=a(8453),s=a(2531);const l={sidebar_position:25,description:"Memory management -- garbage collection, ownership, and manual memory across 12 languages",keywords:["memory management","garbage collection","ownership","RAII","smart pointers","ARC"]},i="Memory Management",c={},d=[{value:"Memory Model Overview",id:"memory-model-overview",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"memory-management",children:"Memory Management"})}),"\n",(0,r.jsx)(n.p,{children:"How a language manages memory is one of the most fundamental design decisions. Here's how different languages handle memory allocation, deallocation, and safety."}),"\n","\n",(0,r.jsx)(n.h2,{id:"memory-model-overview",children:"Memory Model Overview"}),"\n",(0,r.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// GARBAGE COLLECTED (automatic)\n// V8 engine uses generational GC\n\n// Objects are heap-allocated, GC handles cleanup\nlet obj = { name: "John" };\nobj = null;  // Eligible for garbage collection\n\n// WeakRef (allows GC to collect)\nlet target = { data: "important" };\nlet weakRef = new WeakRef(target);\nweakRef.deref();  // target or undefined\n\n// WeakMap / WeakSet (weak references)\nconst cache = new WeakMap();\ncache.set(obj, "cached");\n// When obj is GC\'d, entry is removed\n\n// FinalizationRegistry (cleanup callback)\nconst registry = new FinalizationRegistry((value) => {\n  console.log("Object collected:", value);\n});\nregistry.register(obj, "my object");\n\n// Memory leaks to watch for:\n// - Forgotten timers/intervals\n// - Closures holding references\n// - Detached DOM nodes\n// - Global variables'},{name:"PHP",lang:"php",code:"<?php\n// GARBAGE COLLECTED (reference counting + cycle collector)\n\n// Objects use reference counting\n$a = new stdClass();  // refcount = 1\n$b = $a;              // refcount = 2\nunset($a);            // refcount = 1\nunset($b);            // refcount = 0 -> freed\n\n// Circular reference detection\n$a = new stdClass();\n$b = new stdClass();\n$a->ref = $b;\n$b->ref = $a;\nunset($a, $b);  // Cycle collector handles this\n\n// Manual cleanup\nunset($variable);\n$variable = null;\n\n// Memory functions\nmemory_get_usage();       // Current memory\nmemory_get_peak_usage();  // Peak memory\n\n// PHP is request-scoped: all memory freed after request\n\n// Generators for memory-efficient iteration\nfunction bigRange($start, $end) {\n  for ($i = $start; $i <= $end; $i++) {\n      yield $i;  // Only one value in memory at a time\n  }\n}"},{name:"Rust",lang:"rust",code:'// OWNERSHIP SYSTEM (no GC, no manual free)\n// Zero-cost abstractions, compile-time safety\n\n// Ownership: each value has exactly one owner\nlet s1 = String::from("hello");\nlet s2 = s1;  // s1 is MOVED, no longer usable\n// println!("{}", s1);  // Compile error!\n\n// Borrowing: references without ownership\nfn print_len(s: &String) {  // Immutable borrow\n  println!("{}", s.len());\n}\n\nlet s = String::from("hello");\nprint_len(&s);  // s still valid\n\n// Mutable borrow (only one at a time)\nfn push_char(s: &mut String) {\n  s.push(\'!\');\n}\n\n// Lifetimes (compiler tracks reference validity)\nfn longest<\'a>(x: &\'a str, y: &\'a str) -> &\'a str {\n  if x.len() > y.len() { x } else { y }\n}\n\n// Smart pointers\nuse std::rc::Rc;      // Reference counted\nuse std::cell::RefCell; // Interior mutability\n\nlet shared = Rc::new(42);\nlet clone = Rc::clone(&shared);  // Rc count: 2\n\n// Box: heap allocation\nlet boxed = Box::new(42);\n// Automatically freed when Box goes out of scope'},{name:"Go",lang:"go",code:'// GARBAGE COLLECTED (concurrent, tri-color mark-sweep)\n\n// Stack vs Heap (escape analysis decides)\nfunc example() {\n  x := 42         // Likely stack-allocated\n  y := new(int)   // Likely heap-allocated\n  *y = 42\n\n  // Compiler decides allocation via escape analysis\n  return y  // y escapes to heap\n}\n\n// Pointers (but no pointer arithmetic)\nx := 42\nptr := &x\nfmt.Println(*ptr)  // 42\n\n// Make vs New\nslice := make([]int, 0, 100)  // make: slices, maps, channels\nptr := new(int)                // new: returns pointer\n\n// Defer for cleanup (not memory, but resources)\nfile, _ := os.Open("data.txt")\ndefer file.Close()\n\n// Finalizers (not recommended)\nruntime.SetFinalizer(obj, func(o *MyType) {\n  o.Cleanup()\n})\n\n// Memory stats\nvar m runtime.MemStats\nruntime.ReadMemStats(&m)\nfmt.Printf("Alloc: %d MB\\n", m.Alloc/1024/1024)\n\n// Manual GC trigger (rarely needed)\nruntime.GC()'},{name:"Python",lang:"python",code:"# GARBAGE COLLECTED (reference counting + generational GC)\n\nimport gc\nimport sys\n\n# Reference counting\na = [1, 2, 3]\nsys.getrefcount(a)  # Reference count\n\nb = a    # refcount increases\ndel b    # refcount decreases\n\n# Garbage collector for cycles\ngc.collect()           # Manual collection\ngc.get_count()         # Generation counts\ngc.disable()           # Disable GC (rare)\n\n# Weak references\nimport weakref\nobj = SomeClass()\nweak = weakref.ref(obj)\nweak()  # Returns obj or None\n\n# Context managers for resource cleanup\nwith open('file.txt') as f:\n  data = f.read()\n# File automatically closed\n\n# __del__ (destructor, unreliable)\nclass Resource:\n  def __del__(self):\n      self.cleanup()\n\n# Memory-efficient patterns\n# Generators instead of lists\nsquares = (x**2 for x in range(1000000))\n\n# __slots__ to reduce memory\nclass Point:\n  __slots__ = ['x', 'y']\n  def __init__(self, x, y):\n      self.x = x\n      self.y = y"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// MANUAL MEMORY (with allocator abstraction)\n// No GC, no hidden allocations\n\n// Allocator pattern\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\ndefer _ = gpa.deinit();  // Detect leaks in debug\n\n// Allocate and free\nconst ptr = try allocator.create(i32);\ndefer allocator.destroy(ptr);\nptr.* = 42;\n\n// Allocate slice\nconst slice = try allocator.alloc(u8, 100);\ndefer allocator.free(slice);\n\n// Arena allocator (bulk free)\nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\ndefer arena.deinit();  // Frees everything at once\n\n// Defer for cleanup (runs at scope exit)\nconst file = try std.fs.cwd().openFile("data.txt", .{});\ndefer file.close();\n\n// No hidden heap allocations\n// String concatenation, etc. require explicit allocator\nconst result = try std.fmt.allocPrint(allocator, "{s} {s}", .{"hello", "world"});\ndefer allocator.free(result);'},{name:"C#",lang:"csharp",code:'// GARBAGE COLLECTED (.NET GC, generational)\n\n// Value types (stack) vs Reference types (heap)\nint x = 42;           // Stack (value type)\nstring s = "hello";   // Heap (reference type)\n\n// GC is generational (Gen 0, 1, 2)\nGC.Collect();              // Force collection\nGC.GetTotalMemory(false);  // Current memory\n\n// IDisposable for unmanaged resources\nclass Connection : IDisposable\n{\n  public void Dispose()\n  {\n      // Release unmanaged resources\n  }\n}\n\n// Using statement (automatic Dispose)\nusing var conn = new Connection();\n// Disposed at end of scope\n\n// Span<T> / Memory<T> (stack-allocated views)\nSpan<int> span = stackalloc int[100];\n\n// ArrayPool (reuse arrays)\nvar pool = ArrayPool<byte>.Shared;\nvar buffer = pool.Rent(1024);\ntry { /* use buffer */ }\nfinally { pool.Return(buffer); }\n\n// Weak references\nvar weak = new WeakReference<MyClass>(obj);\nif (weak.TryGetTarget(out var target)) { }'},{name:"C++",lang:"cpp",code:'// MANUAL MEMORY (with RAII and smart pointers)\n\n// Stack allocation (automatic)\nint x = 42;  // Freed when scope exits\n\n// Heap allocation (manual)\nint* ptr = new int(42);\ndelete ptr;\n\nint* arr = new int[100];\ndelete[] arr;\n\n// RAII: Resource Acquisition Is Initialization\n{\n  std::ifstream file("data.txt");\n  // Automatically closed when scope exits\n}\n\n// Smart pointers (C++11, preferred)\n// unique_ptr: exclusive ownership\nauto uptr = std::make_unique<int>(42);\n// Automatically freed when uptr goes out of scope\n\n// shared_ptr: shared ownership (reference counted)\nauto sptr = std::make_shared<int>(42);\nauto sptr2 = sptr;  // Refcount: 2\n\n// weak_ptr: non-owning reference\nstd::weak_ptr<int> wptr = sptr;\nif (auto locked = wptr.lock()) {\n  // Use locked (shared_ptr)\n}\n\n// Move semantics\nauto v1 = std::make_unique<int>(42);\nauto v2 = std::move(v1);  // v1 is now null'},{name:"C",lang:"c",code:'#include <stdlib.h>\n\n// MANUAL MEMORY (malloc/free)\n\n// Stack allocation\nint x = 42;  // Freed when function returns\n\n// Heap allocation\nint* ptr = (int*)malloc(sizeof(int));\n*ptr = 42;\nfree(ptr);\nptr = NULL;  // Prevent dangling pointer\n\n// Array allocation\nint* arr = (int*)calloc(100, sizeof(int));  // Zero-initialized\narr = (int*)realloc(arr, 200 * sizeof(int)); // Resize\nfree(arr);\n\n// Common errors:\n// - Memory leak (forget to free)\n// - Double free\n// - Use after free\n// - Buffer overflow\n\n// Struct allocation\ntypedef struct {\n  char* name;\n  int age;\n} Person;\n\nPerson* p = malloc(sizeof(Person));\np->name = strdup("John");  // Also allocates\np->age = 30;\n\n// Must free in reverse order\nfree(p->name);\nfree(p);'},{name:"Java",lang:"java",code:'// GARBAGE COLLECTED (generational, multiple GC algorithms)\n\n// Everything on heap (except primitives)\nint x = 42;               // Stack (primitive)\nString s = "hello";        // Heap (object)\nInteger boxed = 42;        // Heap (autoboxed)\n\n// GC is automatic\nSystem.gc();  // Request GC (not guaranteed)\nRuntime.getRuntime().freeMemory();\nRuntime.getRuntime().totalMemory();\n\n// try-with-resources for cleanup\ntry (var conn = getConnection()) {\n  // Use connection\n}  // Auto-closed via AutoCloseable\n\n// Weak references\nWeakReference<Object> weak = new WeakReference<>(obj);\nObject ref = weak.get();  // null if GC\'d\n\n// SoftReference (cleared before OOM)\nSoftReference<byte[]> cache = new SoftReference<>(data);\n\n// JVM options\n// -Xms256m  (initial heap)\n// -Xmx1024m (max heap)\n// -XX:+UseG1GC (GC algorithm)\n\n// Off-heap memory (ByteBuffer)\nByteBuffer buffer = ByteBuffer.allocateDirect(1024);'},{name:"Ruby",lang:"ruby",code:'# GARBAGE COLLECTED (mark-and-sweep + generational)\n\n# Everything is an object (heap-allocated)\nx = 42\ns = "hello"\n\n# GC control\nGC.start           # Force collection\nGC.disable         # Disable GC\nGC.enable          # Re-enable GC\nGC.stat            # GC statistics\n\n# ObjectSpace (inspect heap)\nObjectSpace.count_objects\nObjectSpace.each_object(String) { |s| puts s }\n\n# Weak references\nrequire \'weakref\'\nobj = Object.new\nweak = WeakRef.new(obj)\nweak.weakref_alive?  # true\n\n# Finalizers\ndestructor = proc { |id| puts "Object #{id} collected" }\nObjectSpace.define_finalizer(obj, destructor)\n\n# Memory-efficient patterns\n# Symbols are interned (shared, not GC\'d)\n:my_symbol  # Single allocation, reused\n"my_string" # New allocation each time\n\n# Frozen strings (shared)\n# frozen_string_literal: true\n"hello".freeze'},{name:"Swift",lang:"swift",code:'// ARC (Automatic Reference Counting, compile-time)\n\n// Value types (stack): struct, enum, tuple\nstruct Point { var x: Int; var y: Int }\nvar p1 = Point(x: 1, y: 2)\nvar p2 = p1  // Copy (independent)\n\n// Reference types (heap): class\nclass Person {\n  var name: String\n  init(name: String) { self.name = name }\n  deinit { print("\\(name) deallocated") }\n}\n\nvar a: Person? = Person(name: "John")  // refcount: 1\nvar b = a   // refcount: 2\na = nil     // refcount: 1\nb = nil     // refcount: 0 -> deallocated\n\n// Weak references (breaks retain cycles)\nclass View {\n  weak var delegate: ViewDelegate?\n}\n\n// Unowned references (non-optional, assumed valid)\nclass Customer {\n  unowned let store: Store\n}\n\n// Retain cycle example\nclass A {\n  var b: B?\n}\nclass B {\n  weak var a: A?  // Break cycle with weak\n}\n\n// Closure capture lists\nlet closure = { [weak self] in\n  self?.doSomething()\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"GC vs ownership vs manual"})," -- Most languages (JavaScript, Python, Go, Java, C#, Ruby, PHP) use garbage collection: you allocate, and the runtime reclaims when objects are unreachable. Rust uses compile-time ownership: each value has one owner, and the compiler enforces borrowing rules. C, C++, and Zig use manual memory: you call ",(0,r.jsx)(n.code,{children:"malloc"}),"/",(0,r.jsx)(n.code,{children:"free"}),", ",(0,r.jsx)(n.code,{children:"new"}),"/",(0,r.jsx)(n.code,{children:"delete"}),", or ",(0,r.jsx)(n.code,{children:"allocator.alloc()"}),"/",(0,r.jsx)(n.code,{children:"allocator.free()"}),". GC simplifies development but adds latency and non-determinism; ownership (Rust) gives safety without GC; manual management gives full control but demands discipline. Choose GC for productivity; Rust for safety and performance; C/C++/Zig for systems, embedded, or when you need predictable allocation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reference counting"})," -- Swift uses ARC (compile-time): the compiler inserts retain/release calls, and ",(0,r.jsx)(n.code,{children:"weak"}),"/",(0,r.jsx)(n.code,{children:"unowned"})," break cycles. C++ has ",(0,r.jsx)(n.code,{children:"std::shared_ptr"})," for shared ownership: ",(0,r.jsx)(n.code,{children:"auto sptr = std::make_shared<int>(42)"}),"; Rust offers ",(0,r.jsx)(n.code,{children:"Rc<T>"})," (single-threaded) and ",(0,r.jsx)(n.code,{children:"Arc<T>"})," (thread-safe) for shared ownership. PHP and Python use refcounting as part of GC (plus cycle detection). Reference counting provides deterministic cleanup when the last reference is released but can incur overhead and cycles. Use ARC/share_ptr/Rc when you need shared ownership; prefer Rust's ownership when single ownership is sufficient."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Memory safety guarantees"})," -- Rust provides memory safety without GC via ownership and borrowing: the compiler rejects use-after-free, double-free, and data races. For example, ",(0,r.jsx)(n.code,{children:"let s2 = s1;"})," moves ",(0,r.jsx)(n.code,{children:"s1"}),", so ",(0,r.jsx)(n.code,{children:"s1"})," is not usable afterward. C and C++ have no such guarantees; bugs like ",(0,r.jsx)(n.code,{children:"free(ptr); use(ptr)"})," or buffer overflows are common. Zig's manual model is safer than C (no undefined behavior in safe code, explicit allocators) but does not prevent use-after-free. Choose Rust when memory safety is critical; use C/C++ only when you need low-level control and accept the risk; Zig sits between them."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resource cleanup patterns"})," -- RAII (C++), ",(0,r.jsx)(n.code,{children:"defer"})," (Go, Zig), ",(0,r.jsx)(n.code,{children:"using"})," (C#), and ",(0,r.jsx)(n.code,{children:"with"})," (Python) tie resource lifetime to scope. C++: ",(0,r.jsx)(n.code,{children:'std::ifstream file("data.txt");'})," -- closed when scope exits. Zig: ",(0,r.jsx)(n.code,{children:"defer file.close();"}),". C has no built-in pattern; you must manually pair allocate/free and handle errors. These patterns prevent leaks and simplify error paths. Prefer languages with structured cleanup when managing files, connections, or custom resources."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Heap vs stack allocation"})," -- Value types (primitives, structs in C#/Swift/Rust) often live on the stack; reference types and dynamic allocations go on the heap. Go uses escape analysis to decide: ",(0,r.jsx)(n.code,{children:"return &x"})," forces heap allocation. Zig requires an explicit allocator for heap allocation: ",(0,r.jsx)(n.code,{children:"allocator.create(i32)"})," and ",(0,r.jsx)(n.code,{children:"allocator.destroy(ptr)"}),". C#'s ",(0,r.jsx)(n.code,{children:"stackalloc"})," and ",(0,r.jsx)(n.code,{children:"Span<T>"})," allow stack allocation for performance. Understanding allocation helps with performance and predictability. For hot paths, prefer stack allocation when possible; use Zig or C when you need explicit control over allocation strategy."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);