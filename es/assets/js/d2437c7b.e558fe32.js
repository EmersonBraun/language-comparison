"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[299],{8252(n,e,a){a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"json-serialization","title":"JSON y Serializaci\xf3n","description":"Parseo, serializaci\xf3n y deserializaci\xf3n de JSON comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/json-serialization.md","sourceDirName":".","slug":"/json-serialization","permalink":"/language-comparison/es/docs/json-serialization","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/json-serialization.md","tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"description":"Parseo, serializaci\xf3n y deserializaci\xf3n de JSON comparados en 12 lenguajes de programaci\xf3n","keywords":["JSON","serializaci\xf3n","deserializaci\xf3n","parseo","intercambio de datos"]},"sidebar":"tutorialSidebar","previous":{"title":"File I/O","permalink":"/language-comparison/es/docs/file-io"},"next":{"title":"CRUD Operations","permalink":"/language-comparison/es/docs/crud"}}');var o=a(4848),r=a(8453),t=a(6153);const i={sidebar_position:20,description:"Parseo, serializaci\xf3n y deserializaci\xf3n de JSON comparados en 12 lenguajes de programaci\xf3n",keywords:["JSON","serializaci\xf3n","deserializaci\xf3n","parseo","intercambio de datos"]},d="JSON y Serializaci\xf3n",c={},l=[{value:"Parseo y Serializaci\xf3n de JSON",id:"parseo-y-serializaci\xf3n-de-json",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"json-y-serializaci\xf3n",children:"JSON y Serializaci\xf3n"})}),"\n",(0,o.jsx)(e.p,{children:"JSON es el formato de intercambio de datos m\xe1s com\xfan. As\xed es como los diferentes lenguajes manejan el parseo y la serializaci\xf3n de JSON."}),"\n","\n",(0,o.jsx)(e.h2,{id:"parseo-y-serializaci\xf3n-de-json",children:"Parseo y Serializaci\xf3n de JSON"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Parse JSON string to object\nconst data = JSON.parse(\'{"name":"John","age":30}\');\nconsole.log(data.name);  // "John"\n\n// Serialize object to JSON string\nconst json = JSON.stringify({ name: "John", age: 30 });\n// \'{"name":"John","age":30}\'\n\n// Pretty print\nconst pretty = JSON.stringify(data, null, 2);\n\n// Custom serialization (replacer)\nconst json2 = JSON.stringify(data, (key, value) => {\n  if (key === "age") return undefined;  // Exclude\n  return value;\n});\n\n// Parse with reviver\nconst data2 = JSON.parse(json, (key, value) => {\n  if (key === "date") return new Date(value);\n  return value;\n});\n\n// Fetch JSON from API\nconst response = await fetch(\'/api/data\');\nconst apiData = await response.json();'},{name:"PHP",lang:"php",code:'<?php\n// Parse JSON string to array/object\n$data = json_decode(\'{"name":"John","age":30}\');\necho $data->name;  // "John"\n\n// As associative array\n$arr = json_decode(\'{"name":"John","age":30}\', true);\necho $arr[\'name\'];  // "John"\n\n// Serialize to JSON string\n$json = json_encode([\'name\' => \'John\', \'age\' => 30]);\n// \'{"name":"John","age":30}\'\n\n// Pretty print\n$pretty = json_encode($data, JSON_PRETTY_PRINT);\n\n// Options\n$json = json_encode($data,\n  JSON_PRETTY_PRINT |\n  JSON_UNESCAPED_UNICODE |\n  JSON_UNESCAPED_SLASHES\n);\n\n// Error handling\n$result = json_decode($input);\nif (json_last_error() !== JSON_ERROR_NONE) {\n  echo json_last_error_msg();\n}'},{name:"Rust",lang:"rust",code:'// serde + serde_json (standard)\nuse serde::{Deserialize, Serialize};\nuse serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\n// Parse JSON to struct\nlet json = r#"{"name":"John","age":30}"#;\nlet person: Person = serde_json::from_str(json)?;\nprintln!("{}", person.name);  // "John"\n\n// Serialize struct to JSON\nlet json = serde_json::to_string(&person)?;\nlet pretty = serde_json::to_string_pretty(&person)?;\n\n// Dynamic JSON (serde_json::Value)\nlet value: serde_json::Value = serde_json::from_str(json)?;\nvalue["name"].as_str();  // Some("John")\n\n// Build JSON dynamically\nlet data = serde_json::json!({\n  "name": "John",\n  "age": 30,\n  "scores": [85, 92, 78]\n});'},{name:"Go",lang:"go",code:'import "encoding/json"\n\ntype Person struct {\n  Name string `json:"name"`\n  Age  int    `json:"age"`\n}\n\n// Parse JSON to struct\njsonStr := `{"name":"John","age":30}`\nvar person Person\njson.Unmarshal([]byte(jsonStr), &person)\nfmt.Println(person.Name)  // "John"\n\n// Serialize struct to JSON\ndata, _ := json.Marshal(person)\n// {"name":"John","age":30}\n\n// Pretty print\npretty, _ := json.MarshalIndent(person, "", "  ")\n\n// Dynamic JSON (map)\nvar result map[string]interface{}\njson.Unmarshal([]byte(jsonStr), &result)\nresult["name"].(string)  // "John"\n\n// Streaming JSON\ndecoder := json.NewDecoder(reader)\ndecoder.Decode(&person)\n\nencoder := json.NewEncoder(writer)\nencoder.Encode(person)'},{name:"Python",lang:"python",code:'import json\n\n# Parse JSON string to dict\ndata = json.loads(\'{"name": "John", "age": 30}\')\nprint(data["name"])  # "John"\n\n# Serialize dict to JSON string\njson_str = json.dumps({"name": "John", "age": 30})\n\n# Pretty print\npretty = json.dumps(data, indent=2, sort_keys=True)\n\n# Read/write JSON files\nwith open("data.json", "r") as f:\n  data = json.load(f)\n\nwith open("data.json", "w") as f:\n  json.dump(data, f, indent=2)\n\n# Custom serialization\nclass DateEncoder(json.JSONEncoder):\n  def default(self, obj):\n      if isinstance(obj, datetime):\n          return obj.isoformat()\n      return super().default(obj)\n\njson.dumps(data, cls=DateEncoder)\n\n# Pydantic (typed models)\n# from pydantic import BaseModel\n# class Person(BaseModel):\n#     name: str\n#     age: int'},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\nconst Person = struct {\n  name: []const u8,\n  age: u32,\n};\n\n// Parse JSON\nconst json_str =\n  \\\\{"name":"John","age":30}\n;\n\nconst parsed = try std.json.parseFromSlice(\n  Person, allocator, json_str, .{}\n);\ndefer parsed.deinit();\nconst person = parsed.value;\n\n// Serialize to JSON\nvar buf = std.ArrayList(u8).init(allocator);\ndefer buf.deinit();\ntry std.json.stringify(person, .{}, buf.writer());\n\n// Dynamic JSON parsing\nconst tree = try std.json.parseFromSlice(\n  std.json.Value, allocator, json_str, .{}\n);\ndefer tree.deinit();\n\nconst name = tree.value.object.get("name").?.string;'},{name:"C#",lang:"csharp",code:'using System.Text.Json;\n\npublic record Person(string Name, int Age);\n\n// Parse JSON to object\nstring json = "{"name":"John","age":30}";\nvar person = JsonSerializer.Deserialize<Person>(json,\n  new JsonSerializerOptions { PropertyNameCaseInsensitive = true });\n\n// Serialize object to JSON\nstring output = JsonSerializer.Serialize(person);\n\n// Pretty print\nstring pretty = JsonSerializer.Serialize(person,\n  new JsonSerializerOptions { WriteIndented = true });\n\n// Dynamic JSON (JsonDocument)\nusing var doc = JsonDocument.Parse(json);\nstring name = doc.RootElement\n  .GetProperty("name").GetString();\n\n// Newtonsoft.Json (popular alternative)\n// var person = JsonConvert.DeserializeObject<Person>(json);\n// var json = JsonConvert.SerializeObject(person);'},{name:"C++",lang:"cpp",code:'// nlohmann/json (most popular)\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\n\n// Parse JSON string\nauto data = json::parse(R"({"name":"John","age":30})");\nstd::string name = data["name"];  // "John"\nint age = data["age"];            // 30\n\n// Create JSON\njson j;\nj["name"] = "John";\nj["age"] = 30;\nj["scores"] = {85, 92, 78};\n\n// Serialize to string\nstd::string output = j.dump();      // Compact\nstd::string pretty = j.dump(2);     // Indented\n\n// Structured binding\nstruct Person { std::string name; int age; };\nNLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Person, name, age)\n\nPerson p = data.get<Person>();\njson j2 = p;'},{name:"C",lang:"c",code:'// cJSON (popular C JSON library)\n#include <cjson/cJSON.h>\n\n// Parse JSON\nconst char* json_str = "{"name":"John","age":30}";\ncJSON* root = cJSON_Parse(json_str);\n\ncJSON* name = cJSON_GetObjectItem(root, "name");\nprintf("%s\\n", name->valuestring);  // "John"\n\ncJSON* age = cJSON_GetObjectItem(root, "age");\nprintf("%d\\n", age->valueint);      // 30\n\ncJSON_Delete(root);\n\n// Create JSON\ncJSON* obj = cJSON_CreateObject();\ncJSON_AddStringToObject(obj, "name", "John");\ncJSON_AddNumberToObject(obj, "age", 30);\n\nchar* output = cJSON_Print(obj);     // Pretty\nchar* compact = cJSON_PrintUnformatted(obj);\nprintf("%s\\n", output);\n\nfree(output);\nfree(compact);\ncJSON_Delete(obj);'},{name:"Java",lang:"java",code:'// Jackson (most popular)\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nObjectMapper mapper = new ObjectMapper();\n\n// Parse JSON to object\nString json = "{"name":"John","age":30}";\nPerson person = mapper.readValue(json, Person.class);\n\n// Serialize to JSON\nString output = mapper.writeValueAsString(person);\nString pretty = mapper.writerWithDefaultPrettyPrinter()\n  .writeValueAsString(person);\n\n// Dynamic JSON (JsonNode)\nJsonNode node = mapper.readTree(json);\nString name = node.get("name").asText();\n\n// Gson (Google alternative)\n// Gson gson = new Gson();\n// Person p = gson.fromJson(json, Person.class);\n// String s = gson.toJson(person);\n\n// Record (Java 16+)\nrecord Person(String name, int age) {}'},{name:"Ruby",lang:"ruby",code:'require \'json\'\n\n# Parse JSON string to hash\ndata = JSON.parse(\'{"name":"John","age":30}\')\nputs data["name"]  # "John"\n\n# Serialize to JSON string\njson = JSON.generate({ name: "John", age: 30 })\n# or\njson = { name: "John", age: 30 }.to_json\n\n# Pretty print\npretty = JSON.pretty_generate(data)\n\n# Read/write JSON files\ndata = JSON.parse(File.read("data.json"))\nFile.write("data.json", JSON.pretty_generate(data))\n\n# Parse with symbolize names\ndata = JSON.parse(json, symbolize_names: true)\ndata[:name]  # "John"\n\n# Custom serialization\nclass Person\ndef to_json(*args)\n  { name: @name, age: @age }.to_json(*args)\nend\nend'},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Codable protocol (built-in)\nstruct Person: Codable {\n  let name: String\n  let age: Int\n}\n\nlet json = #"{"name":"John","age":30}"#.data(using: .utf8)!\n\n// Parse JSON to struct\nlet decoder = JSONDecoder()\nlet person = try decoder.decode(Person.self, from: json)\nprint(person.name)  // "John"\n\n// Serialize struct to JSON\nlet encoder = JSONEncoder()\nencoder.outputFormatting = .prettyPrinted\nlet data = try encoder.encode(person)\nlet jsonString = String(data: data, encoding: .utf8)!\n\n// Custom key mapping\nstruct User: Codable {\n  let firstName: String\n  enum CodingKeys: String, CodingKey {\n      case firstName = "first_name"\n  }\n}\n\n// Dynamic JSON\nlet obj = try JSONSerialization.jsonObject(\n  with: json) as! [String: Any]\nlet name = obj["name"] as! String'}]}),"\n",(0,o.jsx)(e.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Soporte incorporado vs bibliotecas"})," \u2014 JavaScript (",(0,o.jsx)(e.code,{children:"JSON.parse"}),"/",(0,o.jsx)(e.code,{children:"JSON.stringify"}),"), Python (m\xf3dulo ",(0,o.jsx)(e.code,{children:"json"}),"), PHP (",(0,o.jsx)(e.code,{children:"json_decode"}),"/",(0,o.jsx)(e.code,{children:"json_encode"}),") y Ruby (",(0,o.jsx)(e.code,{children:"JSON.parse"}),"/",(0,o.jsx)(e.code,{children:"to_json"}),") incluyen JSON en la biblioteca est\xe1ndar. Rust usa los crates ",(0,o.jsx)(e.code,{children:"serde"})," + ",(0,o.jsx)(e.code,{children:"serde_json"}),"; Go usa ",(0,o.jsx)(e.code,{children:"encoding/json"}),"; C y C++ requieren bibliotecas externas como cJSON o nlohmann/json. Para APIs web y parseo de configuraci\xf3n, el soporte incorporado es conveniente; para trabajo embebido o de sistemas, ten en cuenta la dependencia y el tama\xf1o del binario de las bibliotecas JSON."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Deserializaci\xf3n tipada"})," \u2014 El serde de Rust mapea JSON a structs con ",(0,o.jsx)(e.code,{children:"#[derive(Deserialize)]"}),"; Go usa etiquetas de struct: ",(0,o.jsx)(e.code,{children:"type Person struct { Name string \\"}),'json:"name"` }',(0,o.jsx)(e.code,{children:"; el "}),"Codable",(0,o.jsx)(e.code,{children:"de Swift y el"}),"System.Text.Json",(0,o.jsx)(e.code,{children:"de C# hacen lo mismo. Cuando necesitas trabajar con estructura desconocida, usa tipos din\xe1micos:"}),"serde_json::Value",(0,o.jsx)(e.code,{children:", "}),"map[string]interface",(0,o.jsx)(e.code,{children:", "}),"JsonNode",(0,o.jsx)(e.code,{children:"o"}),"JsonDocument`. Prefiere deserializaci\xf3n tipada para APIs internas y configuraciones; usa parseo din\xe1mico cuando el esquema es flexible o controlado externamente."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Patrones derive/Codable"})," \u2014 El ",(0,o.jsx)(e.code,{children:"#[derive(Serialize, Deserialize)]"})," de Rust, el ",(0,o.jsx)(e.code,{children:"Codable"})," de Swift y los tipos record de C# habilitan serializaci\xf3n autom\xe1tica con m\xednimo c\xf3digo repetitivo. Defines el struct y obtienes ida y vuelta JSON gratis; la serializaci\xf3n personalizada usa implementaciones de ",(0,o.jsx)(e.code,{children:"Serialize"}),"/",(0,o.jsx)(e.code,{children:"Deserialize"})," o atributos como ",(0,o.jsx)(e.code,{children:'#[serde(rename = "first_name")]'}),". Esto reduce el c\xf3digo repetitivo y mantiene el esquema y el c\xf3digo sincronizados. Para proyectos nuevos, prefiere lenguajes con fuerte soporte derive/Codable; evita el marshalling manual a menos que necesites l\xf3gica personalizada."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Serializaci\xf3n personalizada y casos especiales"})," \u2014 El ",(0,o.jsx)(e.code,{children:"JSONEncoder"})," de Python y el ",(0,o.jsx)(e.code,{children:"replacer"}),"/",(0,o.jsx)(e.code,{children:"reviver"})," de JavaScript permiten manejo personalizado de fechas, BigInt u otros tipos no-JSON. El ",(0,o.jsx)(e.code,{children:"encoding/json"})," de Go requiere ",(0,o.jsx)(e.code,{children:"MarshalJSON"}),"/",(0,o.jsx)(e.code,{children:"UnmarshalJSON"})," personalizados para tipos no est\xe1ndar. El serde de Rust soporta ",(0,o.jsx)(e.code,{children:'#[serde(serialize_with = "...")]'})," para l\xf3gica personalizada. Cuando trabajes con fechas, decimales o tipos especiales, revisa las opciones de personalizaci\xf3n de la biblioteca; JavaScript y Python ofrecen hooks flexibles, mientras que Go y Rust requieren implementaciones m\xe1s expl\xedcitas."]}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}}}]);