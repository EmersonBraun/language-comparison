"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[331],{7242(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"generics-templates","title":"Generics & Templates","description":"Generics, templates, and type constraints compared across 12 programming languages","source":"@site/docs/generics-templates.md","sourceDirName":".","slug":"/generics-templates","permalink":"/language-comparison/es/docs/generics-templates","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/generics-templates.md","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16,"description":"Generics, templates, and type constraints compared across 12 programming languages","keywords":["generics","templates","type parameters","constraints","type-safe"]},"sidebar":"tutorialSidebar","previous":{"title":"Classes & OOP","permalink":"/language-comparison/es/docs/classes-oop"},"next":{"title":"Regex","permalink":"/language-comparison/es/docs/regex"}}');var r=t(4848),i=t(8453),s=t(2531);const o={sidebar_position:16,description:"Generics, templates, and type constraints compared across 12 programming languages",keywords:["generics","templates","type parameters","constraints","type-safe"]},l="Generics & Templates",c={},u=[{value:"Basic Generics",id:"basic-generics",level:2},{value:"Type Constraints",id:"type-constraints",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"generics--templates",children:"Generics & Templates"})}),"\n",(0,r.jsx)(e.p,{children:"Generics allow you to write type-safe, reusable code. Here's how different languages handle generic programming."}),"\n","\n",(0,r.jsx)(e.h2,{id:"basic-generics",children:"Basic Generics"}),"\n",(0,r.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// JavaScript has no built-in generics\n// Use TypeScript for generic support\n\n// TypeScript generics:\n// function identity<T>(value: T): T {\n//     return value;\n// }\n// identity<string>("hello");\n// identity<number>(42);\n\n// Generic interface (TypeScript)\n// interface Container<T> {\n//     value: T;\n//     getValue(): T;\n// }\n\n// Generic class (TypeScript)\n// class Box<T> {\n//     constructor(private value: T) {}\n//     get(): T { return this.value; }\n// }\n// const box = new Box<string>("hello");'},{name:"PHP",lang:"php",code:'<?php\n// PHP has limited generics (PHPStan/Psalm annotations)\n\n// Template annotation (PHPStan)\n/**\n* @template T\n* @param T $value\n* @return T\n*/\nfunction identity($value) {\n  return $value;\n}\n\n/**\n* @template T\n*/\nclass Box {\n  /** @var T */\n  private $value;\n\n  /** @param T $value */\n  public function __construct($value) {\n      $this->value = $value;\n  }\n\n  /** @return T */\n  public function get() {\n      return $this->value;\n  }\n}\n\n// Usage analyzed by static analysis tools\n$box = new Box("hello");  // Box<string>'},{name:"Rust",lang:"rust",code:'// Generic function\nfn identity<T>(value: T) -> T {\n  value\n}\n\nlet s = identity("hello");\nlet n = identity(42);\n\n// Generic struct\nstruct Box<T> {\n  value: T,\n}\n\nimpl<T> Box<T> {\n  fn new(value: T) -> Self {\n      Box { value }\n  }\n\n  fn get(&self) -> &T {\n      &self.value\n  }\n}\n\nlet box_str = Box::new("hello");\nlet box_num = Box::new(42);\n\n// Multiple type parameters\nstruct Pair<A, B> {\n  first: A,\n  second: B,\n}\n\nlet pair = Pair { first: "key", second: 42 };'},{name:"Go",lang:"go",code:'// Generic function (Go 1.18+)\nfunc Identity[T any](value T) T {\n  return value\n}\n\ns := Identity("hello")\nn := Identity(42)\n\n// Generic struct\ntype Box[T any] struct {\n  Value T\n}\n\nfunc NewBox[T any](value T) Box[T] {\n  return Box[T]{Value: value}\n}\n\nbox := NewBox("hello")\n\n// Multiple type parameters\ntype Pair[A any, B any] struct {\n  First  A\n  Second B\n}\n\npair := Pair[string, int]{First: "key", Second: 42}\n\n// Generic interface\ntype Container[T any] interface {\n  Get() T\n  Set(value T)\n}'},{name:"Python",lang:"python",code:"# Type hints with generics (Python 3.12+)\ndef identity[T](value: T) -> T:\n  return value\n\n# Older syntax (Python 3.9+)\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\ndef identity(value: T) -> T:\n  return value\n\n# Generic class\nclass Box(Generic[T]):\n  def __init__(self, value: T) -> None:\n      self.value = value\n\n  def get(self) -> T:\n      return self.value\n\nbox: Box[str] = Box(\"hello\")\nbox_num: Box[int] = Box(42)\n\n# Multiple type parameters\nfrom typing import Tuple\nK = TypeVar('K')\nV = TypeVar('V')\n\nclass Pair(Generic[K, V]):\n  def __init__(self, key: K, value: V):\n      self.key = key\n      self.value = value"},{name:"Zig",lang:"zig",code:'// Comptime generics\nfn identity(comptime T: type, value: T) T {\n  return value;\n}\n\nconst s = identity([]const u8, "hello");\nconst n = identity(i32, 42);\n\n// Generic struct (function returning type)\nfn Box(comptime T: type) type {\n  return struct {\n      value: T,\n\n      const Self = @This();\n\n      pub fn init(value: T) Self {\n          return .{ .value = value };\n      }\n\n      pub fn get(self: Self) T {\n          return self.value;\n      }\n  };\n}\n\nconst StringBox = Box([]const u8);\nconst box = StringBox.init("hello");\n\n// Generic with multiple types\nfn Pair(comptime A: type, comptime B: type) type {\n  return struct { first: A, second: B };\n}'},{name:"C#",lang:"csharp",code:'// Generic method\nT Identity<T>(T value) => value;\n\nstring s = Identity("hello");\nint n = Identity(42);\n\n// Generic class\nclass Box<T>\n{\n  public T Value { get; }\n  public Box(T value) => Value = value;\n  public T Get() => Value;\n}\n\nvar box = new Box<string>("hello");\n\n// Multiple type parameters\nclass Pair<TKey, TValue>\n{\n  public TKey Key { get; }\n  public TValue Value { get; }\n  public Pair(TKey key, TValue value)\n  {\n      Key = key;\n      Value = value;\n  }\n}\n\n// Generic interface\ninterface IContainer<T>\n{\n  T Get();\n  void Set(T value);\n}'},{name:"C++",lang:"cpp",code:'// Function template\ntemplate<typename T>\nT identity(T value) {\n  return value;\n}\n\nauto s = identity(std::string("hello"));\nauto n = identity(42);\n\n// Class template\ntemplate<typename T>\nclass Box {\n  T value_;\npublic:\n  Box(T value) : value_(value) {}\n  T get() const { return value_; }\n};\n\nBox<std::string> box("hello");\nBox<int> boxNum(42);\n\n// Multiple type parameters\ntemplate<typename A, typename B>\nstruct Pair {\n  A first;\n  B second;\n};\n\nPair<std::string, int> pair{"key", 42};\n\n// Variadic templates\ntemplate<typename... Args>\nvoid print(Args... args) {\n  ((std::cout << args << " "), ...);\n}'},{name:"C",lang:"c",code:'// C has no generics\n// Use void pointers for generic-like behavior\n\n// Generic swap using void*\nvoid swap(void* a, void* b, size_t size) {\n  void* temp = malloc(size);\n  memcpy(temp, a, size);\n  memcpy(a, b, size);\n  memcpy(b, temp, size);\n  free(temp);\n}\n\nint a = 1, b = 2;\nswap(&a, &b, sizeof(int));\n\n// _Generic (C11 type-generic expressions)\n#define print_val(x) _Generic((x), \\\n  int: printf("%d\\n", x),          \\\n  double: printf("%f\\n", x),       \\\n  char*: printf("%s\\n", x)         \\\n)\n\nprint_val(42);       // prints int\nprint_val(3.14);     // prints double\nprint_val("hello");  // prints string'},{name:"Java",lang:"java",code:'// Generic method\n<T> T identity(T value) {\n  return value;\n}\n\nString s = identity("hello");\nInteger n = identity(42);\n\n// Generic class\nclass Box<T> {\n  private T value;\n\n  public Box(T value) { this.value = value; }\n  public T get() { return value; }\n}\n\nBox<String> box = new Box<>("hello");\n\n// Multiple type parameters\nclass Pair<K, V> {\n  private K key;\n  private V value;\n  public Pair(K key, V value) {\n      this.key = key;\n      this.value = value;\n  }\n}\n\n// Wildcards\nvoid printList(List<?> list) { }\nvoid addNumbers(List<? super Integer> list) { }\nvoid readNumbers(List<? extends Number> list) { }'},{name:"Ruby",lang:"ruby",code:'# Ruby is dynamically typed, no generics needed\n# Duck typing serves a similar purpose\n\n# Generic-like behavior via duck typing\nclass Box\nattr_reader :value\n\ndef initialize(value)\n  @value = value\nend\n\ndef get\n  @value\nend\nend\n\nbox_str = Box.new("hello")\nbox_num = Box.new(42)\n\n# RBS type signatures (for type checking)\n# class Box[T]\n#   attr_reader value: T\n#   def initialize: (T) -> void\n#   def get: () -> T\n# end\n\n# Sorbet (static type checker)\n# sig { type_parameters(:T).params(value: T).returns(T) }\n# def identity(value); value; end'},{name:"Swift",lang:"swift",code:'// Generic function\nfunc identity<T>(_ value: T) -> T {\n  return value\n}\n\nlet s = identity("hello")\nlet n = identity(42)\n\n// Generic struct\nstruct Box<T> {\n  let value: T\n\n  func get() -> T {\n      return value\n  }\n}\n\nlet box = Box(value: "hello")\n\n// Multiple type parameters\nstruct Pair<A, B> {\n  let first: A\n  let second: B\n}\n\nlet pair = Pair(first: "key", second: 42)\n\n// Generic enum\nenum Result<Success, Failure: Error> {\n  case success(Success)\n  case failure(Failure)\n}'}]}),"\n",(0,r.jsx)(e.h2,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,r.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// TypeScript constraints\n// function max<T extends number>(a: T, b: T): T {\n//     return a > b ? a : b;\n// }\n\n// Interface constraint\n// interface HasLength { length: number; }\n// function logLength<T extends HasLength>(item: T): void {\n//     console.log(item.length);\n// }\n// logLength("hello");     // OK\n// logLength([1, 2, 3]);   // OK\n// logLength(42);           // Error\n\n// keyof constraint\n// function getProperty<T, K extends keyof T>(\n//     obj: T, key: K\n// ): T[K] {\n//     return obj[key];\n// }'},{name:"PHP",lang:"php",code:"<?php\n// PHPStan template bounds\n\n/**\n* @template T of Comparable\n* @param T $a\n* @param T $b\n* @return T\n*/\nfunction max_val($a, $b) {\n  return $a->compareTo($b) > 0 ? $a : $b;\n}\n\n/**\n* @template T of \\Countable\n* @param T $item\n* @return int\n*/\nfunction getCount($item): int {\n  return count($item);\n}\n\n// Runtime: use interfaces for constraints\ninterface Printable {\n  public function toString(): string;\n}\n\nfunction printItem(Printable $item): void {\n  echo $item->toString();\n}"},{name:"Rust",lang:"rust",code:'// Trait bounds\nfn max<T: PartialOrd>(a: T, b: T) -> T {\n  if a > b { a } else { b }\n}\n\n// Multiple bounds\nfn print_debug<T: std::fmt::Debug + Clone>(value: T) {\n  println!("{:?}", value);\n}\n\n// Where clause (cleaner for complex bounds)\nfn process<T>(value: T) -> String\nwhere\n  T: std::fmt::Display + Clone + Send,\n{\n  format!("{}", value)\n}\n\n// Associated type bounds\nfn sum<I>(iter: I) -> i32\nwhere\n  I: Iterator<Item = i32>,\n{\n  iter.fold(0, |acc, x| acc + x)\n}'},{name:"Go",lang:"go",code:"// Type constraints with interfaces\ntype Number interface {\n  ~int | ~int64 | ~float64\n}\n\nfunc Max[T Number](a, b T) T {\n  if a > b {\n      return a\n  }\n  return b\n}\n\n// comparable constraint\nfunc Contains[T comparable](slice []T, item T) bool {\n  for _, v := range slice {\n      if v == item {\n          return true\n      }\n  }\n  return false\n}\n\n// Custom constraint interface\ntype Stringer interface {\n  String() string\n}\n\nfunc PrintAll[T Stringer](items []T) {\n  for _, item := range items {\n      fmt.Println(item.String())\n  }\n}"},{name:"Python",lang:"python",code:"from typing import TypeVar, Protocol\n\n# Bound type variable\nfrom typing import Comparable\nT = TypeVar('T', bound=int)\n\ndef max_val(a: T, b: T) -> T:\n  return a if a > b else b\n\n# Protocol (structural typing)\nclass HasLength(Protocol):\n  def __len__(self) -> int: ...\n\ndef log_length(item: HasLength) -> None:\n  print(len(item))\n\nlog_length(\"hello\")    # OK\nlog_length([1, 2, 3])  # OK\n\n# Constrained TypeVar\nT = TypeVar('T', int, float, str)\n\ndef add(a: T, b: T) -> T:\n  return a + b"},{name:"Zig",lang:"zig",code:'// Comptime constraints via compile errors\nfn max(comptime T: type, a: T, b: T) T {\n  // Check for ordering support at comptime\n  switch (@typeInfo(T)) {\n      .Int, .Float => {},\n      else => @compileError("Type must be numeric"),\n  }\n  return if (a > b) a else b;\n}\n\n// Interface-like via function pointers\nfn Sortable(comptime T: type) type {\n  return struct {\n      lessThan: fn (T, T) bool,\n  };\n}\n\n// Trait-like pattern\nfn print(value: anytype) void {\n  // Works with any type that supports formatting\n  std.debug.print("{any}\\n", .{value});\n}'},{name:"C#",lang:"csharp",code:"// Interface constraint\nT Max<T>(T a, T b) where T : IComparable<T>\n{\n  return a.CompareTo(b) > 0 ? a : b;\n}\n\n// Multiple constraints\nvoid Process<T>(T value)\n  where T : class, IDisposable, new()\n{\n  using (value) { /* work */ }\n}\n\n// Constraint types:\n// where T : struct        // Value type\n// where T : class         // Reference type\n// where T : new()         // Has parameterless ctor\n// where T : BaseClass     // Derives from class\n// where T : IInterface    // Implements interface\n// where T : notnull       // Non-nullable (C# 8+)\n\n// Generic math (C# 11+)\nT Sum<T>(T[] values) where T : INumber<T>\n{\n  T sum = T.Zero;\n  foreach (var v in values) sum += v;\n  return sum;\n}"},{name:"C++",lang:"cpp",code:"// Concepts (C++20)\ntemplate<typename T>\nconcept Comparable = requires(T a, T b) {\n  { a < b } -> std::convertible_to<bool>;\n  { a > b } -> std::convertible_to<bool>;\n};\n\ntemplate<Comparable T>\nT max_val(T a, T b) {\n  return a > b ? a : b;\n}\n\n// requires clause\ntemplate<typename T>\n  requires std::is_arithmetic_v<T>\nT add(T a, T b) {\n  return a + b;\n}\n\n// SFINAE (pre-C++20)\ntemplate<typename T,\n  typename = std::enable_if_t<std::is_integral_v<T>>>\nT square(T x) {\n  return x * x;\n}"},{name:"C",lang:"c",code:'// C has no type constraints\n// Use preprocessor macros for type-generic code\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\nint max_int = MAX(3, 5);\ndouble max_double = MAX(3.14, 2.71);\n\n// Type-generic math (C11)\n#include <tgmath.h>\n\n// sqrt works for float, double, long double\ndouble d = sqrt(16.0);\nfloat f = sqrt(16.0f);\n\n// _Static_assert for compile-time checks\n#define ASSERT_NUMERIC(x) _Static_assert( \\\n  _Generic((x),                          \\\n      int: 1, float: 1, double: 1,      \\\n      default: 0                         \\\n  ), "Must be numeric")'},{name:"Java",lang:"java",code:"// Upper bound\n<T extends Comparable<T>> T max(T a, T b) {\n  return a.compareTo(b) > 0 ? a : b;\n}\n\n// Multiple bounds\n<T extends Comparable<T> & Serializable>\nvoid process(T value) { }\n\n// Bounded wildcards\n// Upper bound: read-only\nvoid printAll(List<? extends Number> list) {\n  for (Number n : list) System.out.println(n);\n}\n\n// Lower bound: write-only\nvoid addIntegers(List<? super Integer> list) {\n  list.add(42);\n}\n\n// Type erasure: generics are compile-time only\n// At runtime, Box<String> and Box<Integer>\n// are both just Box"},{name:"Ruby",lang:"ruby",code:'# Ruby uses duck typing instead of constraints\n# No compile-time type checking\n\n# Convention: check capabilities at runtime\ndef process(item)\nunless item.respond_to?(:length)\n  raise ArgumentError, "must have length"\nend\nitem.length\nend\n\n# RBS type signatures\n# interface _Comparable\n#   def <=>: (untyped) -> Integer\n# end\n#\n# def max: [T < _Comparable] (T, T) -> T\n\n# Sorbet generics with bounds\n# sig do\n#   type_parameters(:T)\n#     .params(a: T, b: T)\n#     .returns(T)\n#     .where(T: Comparable)\n# end\n# def max(a, b); a > b ? a : b; end'},{name:"Swift",lang:"swift",code:"// Protocol constraint\nfunc max<T: Comparable>(_ a: T, _ b: T) -> T {\n  return a > b ? a : b\n}\n\n// Multiple constraints\nfunc process<T: Hashable & Codable>(_ value: T) {\n  // T must be both Hashable and Codable\n}\n\n// Where clause\nfunc allEqual<T>(_ a: T, _ b: T) -> Bool\n  where T: Equatable {\n  return a == b\n}\n\n// Associated type constraints\nprotocol Container {\n  associatedtype Item: Equatable\n  func contains(_ item: Item) -> Bool\n}\n\n// Protocol with Self constraint\nprotocol Copyable {\n  func copy() -> Self\n}"}]}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Type erasure vs monomorphization"})," -- Java and TypeScript erase generics at runtime (one shared representation); C++, Rust, Swift, and Go generate specialized code per type (monomorphization) for zero-cost abstraction."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Constraint systems vary in expressiveness"})," -- Rust's traits and C++ concepts offer rich bounds; Go's type sets (",(0,r.jsx)(e.code,{children:"~int | ~float64"}),") and Swift's protocol constraints are simpler; Java's ",(0,r.jsx)(e.code,{children:"extends"})," and wildcards are more limited."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Languages without generics use workarounds"})," -- C uses ",(0,r.jsx)(e.code,{children:"void*"})," and macros; JavaScript/Ruby rely on duck typing; PHP uses docblock annotations for static analysis; Zig uses comptime type parameters."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Comptime generics (Zig) are unique"})," -- Zig passes types as compile-time values, enabling zero-cost generics without a separate type parameter syntax; types are first-class at compile time."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Python and PHP have late generics"})," -- Python 3.12+ and PHPStan/Psalm add generic syntax; type checking is static only\u2014runtime behavior is unchanged\u2014unlike compiled languages."]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}}}]);