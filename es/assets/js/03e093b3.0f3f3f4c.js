"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[978],{1225(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"variables-types","title":"Variables y Tipos","description":"Variables, tipos de datos y sistemas de tipos comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/variables-types.md","sourceDirName":".","slug":"/variables-types","permalink":"/language-comparison/es/docs/variables-types","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/variables-types.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"description":"Variables, tipos de datos y sistemas de tipos comparados en 12 lenguajes de programaci\xf3n","keywords":["variables","tipos","tipos de datos","tipado","tipado est\xe1tico","tipado din\xe1mico"]},"sidebar":"tutorialSidebar","previous":{"title":"Comments & Documentation","permalink":"/language-comparison/es/docs/comments-documentation"},"next":{"title":"Operators","permalink":"/language-comparison/es/docs/operators"}}');var a=t(4848),s=t(8453),r=t(6153);const o={sidebar_position:3,description:"Variables, tipos de datos y sistemas de tipos comparados en 12 lenguajes de programaci\xf3n",keywords:["variables","tipos","tipos de datos","tipado","tipado est\xe1tico","tipado din\xe1mico"]},c="Variables y Tipos",l={},p=[{value:"Declaraci\xf3n de Variables",id:"declaraci\xf3n-de-variables",level:2},{value:"Sistema de Tipos",id:"sistema-de-tipos",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"variables-y-tipos",children:"Variables y Tipos"})}),"\n",(0,a.jsx)(e.p,{children:"Los diferentes lenguajes manejan la declaraci\xf3n de variables y el tipado de diversas maneras. Comparemos c\xf3mo cada lenguaje declara variables y maneja los tipos."}),"\n","\n",(0,a.jsx)(e.h2,{id:"declaraci\xf3n-de-variables",children:"Declaraci\xf3n de Variables"}),"\n",(0,a.jsx)(r.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Primitives\nlet name = "John";\nconst age = 30;\nlet isActive = true;\n\n// Arrays\nlet numbers = [1, 2, 3];\nlet items = ["apple", "banana"];\n\n// Objects\nlet person = { name: "John", age: 30 };\nlet user = new Object();\n\n// Maps\nlet map = new Map();\nmap.set("key", "value");\n\n// Sets\nlet set = new Set([1, 2, 3]);\n\n// Dynamic typing\nlet value = 42;\nvalue = "now a string"; // allowed'},{name:"PHP",lang:"php",code:'<?php\n// Primitives\n$name = "John";\n$age = 30;\n$isActive = true;\n\n// Arrays\n$numbers = [1, 2, 3];\n$items = array("apple", "banana");\n\n// Associative arrays (maps)\n$map = ["key" => "value"];\n$person = ["name" => "John", "age" => 30];\n\n// Objects\n$obj = new stdClass();\n$obj->name = "John";\n\n// Type hints (optional)\nfunction greet(string $name): string {\n  return "Hello, " . $name;\n}'},{name:"Rust",lang:"rust",code:'// Primitives\nlet name = "John";\nlet age: i32 = 30;\nlet is_active: bool = true;\n\n// Arrays\nlet numbers: [i32; 3] = [1, 2, 3];\nlet items = vec!["apple", "banana"];\n\n// Structs\nstruct Person {\n  name: String,\n  age: i32,\n}\nlet person = Person { name: String::from("John"), age: 30 };\n\n// HashMaps (Maps)\nuse std::collections::HashMap;\nlet mut map = HashMap::new();\nmap.insert("key", "value");\n\n// HashSets (Sets)\nuse std::collections::HashSet;\nlet mut set = HashSet::new();\nset.insert(1);\n\n// Mutable variables\nlet mut count = 0;\ncount += 1;'},{name:"Go",lang:"go",code:'package main\n\n// Primitives\nvar name string = "John"\nvar age = 30  // type inferred\nvar isActive bool = true\n\n// Arrays\nvar numbers [3]int = [3]int{1, 2, 3}\nvar items []string = []string{"apple", "banana"}\n\n// Structs\ntype Person struct {\n  Name string\n  Age  int\n}\nvar person Person = Person{Name: "John", Age: 30}\n\n// Maps\nvar m map[string]string = make(map[string]string)\nm["key"] = "value"\n\n// Short declaration\nname := "John"\nnumbers := []int{1, 2, 3}\n\n// Multiple variables\nvar x, y int = 1, 2'},{name:"Python",lang:"python",code:'# Primitives\nname = "John"\nage = 30\nis_active = True\n\n# Lists (arrays)\nnumbers = [1, 2, 3]\nitems = ["apple", "banana"]\n\n# Tuples\npoint = (1, 2)\ncoordinates = (10, 20, 30)\n\n# Dictionaries (maps)\nperson = {"name": "John", "age": 30}\nmap_dict = {"key": "value"}\n\n# Sets\nnumbers_set = {1, 2, 3}\nitems_set = set(["apple", "banana"])\n\n# Type hints (optional, Python 3.5+)\nname: str = "John"\nage: int = 30\n\n# Multiple assignment\nx, y = 1, 2'},{name:"Zig",lang:"zig",code:'// Primitives\nconst name = "John";\nvar age: i32 = 30;\nvar is_active: bool = true;\n\n// Arrays\nvar numbers: [3]i32 = [3]i32{ 1, 2, 3 };\nvar items = [_][]const u8{ "apple", "banana" };\n\n// Slices\nvar slice: []i32 = &numbers;\n\n// Structs\nconst Person = struct {\n  name: []const u8,\n  age: i32,\n};\nvar person = Person{ .name = "John", .age = 30 };\n\n// Type inference with const\nconst count = 42; // comptime_int\n\n// Mutable\nvar mutable: i32 = 10;'},{name:"C#",lang:"csharp",code:'// Primitives\nstring name = "John";\nint age = 30;\nbool isActive = true;\n\n// Arrays\nint[] numbers = {1, 2, 3};\nstring[] items = {"apple", "banana"};\n\n// Lists\nList<int> numbersList = new List<int> {1, 2, 3};\n\n// Objects/Classes\nclass Person {\n  public string Name { get; set; }\n  public int Age { get; set; }\n}\nvar person = new Person { Name = "John", Age = 30 };\n\n// Dictionaries (Maps)\nDictionary<string, string> map = new Dictionary<string, string>();\nmap["key"] = "value";\n\n// HashSet (Sets)\nHashSet<int> set = new HashSet<int> {1, 2, 3};\n\n// var keyword (type inference)\nvar city = "New York";\n\n// Multiple declaration\nint x = 1, y = 2;'},{name:"C++",lang:"cpp",code:'// Primitives\nstd::string name = "John";\nint age = 30;\nbool isActive = true;\n\n// Arrays\nint numbers[3] = {1, 2, 3};\nstd::vector<int> numbersVec = {1, 2, 3};\n\n// Structs\nstruct Person {\n  std::string name;\n  int age;\n};\nPerson person = {"John", 30};\n\n// Maps\nstd::map<std::string, std::string> map;\nmap["key"] = "value";\n\n// Sets\nstd::set<int> set = {1, 2, 3};\n\n// auto keyword (C++11+)\nauto city = "New York";\n\n// Multiple declaration\nint x = 1, y = 2;'},{name:"C",lang:"c",code:'// Primitives\nchar name[] = "John";\nint age = 30;\nint isActive = 1;  // boolean as int\n\n// Arrays\nint numbers[3] = {1, 2, 3};\nchar items[][10] = {"apple", "banana"};\n\n// Structs\nstruct Person {\n  char name[50];\n  int age;\n};\nstruct Person person = {"John", 30};\n\n// Pointers\nint* ptr = &age;\n\n// Multiple declaration\nint x = 1, y = 2;'},{name:"Java",lang:"java",code:'// Primitives\nString name = "John";\nint age = 30;\nboolean isActive = true;\n\n// Arrays\nint[] numbers = {1, 2, 3};\nString[] items = {"apple", "banana"};\n\n// Lists\nList<Integer> numbersList = new ArrayList<>();\nnumbersList.add(1);\n\n// Objects/Classes\nclass Person {\n  String name;\n  int age;\n}\nPerson person = new Person();\nperson.name = "John";\n\n// Maps\nMap<String, String> map = new HashMap<>();\nmap.put("key", "value");\n\n// Sets\nSet<Integer> set = new HashSet<>();\nset.add(1);\n\n// var keyword (Java 10+)\nvar city = "New York";'},{name:"Ruby",lang:"ruby",code:'# Primitives\nname = "John"\nage = 30\nis_active = true\n\n# Arrays\nnumbers = [1, 2, 3]\nitems = ["apple", "banana"]\n\n# Hashes (maps)\nperson = {name: "John", age: 30}\nmap = {"key" => "value"}\n\n# Sets\nrequire \'set\'\nset = Set.new([1, 2, 3])\n\n# Constants (convention: uppercase)\nNAME = "John"\n\n# Multiple assignment\nx, y = 1, 2'},{name:"Swift",lang:"swift",code:'// Primitives\nlet name = "John"  // String\nvar age = 30       // Int\nvar isActive = true  // Bool\n\n// Arrays\nvar numbers = [1, 2, 3]\nvar items: [String] = ["apple", "banana"]\n\n// Structs\nstruct Person {\n  var name: String\n  var age: Int\n}\nvar person = Person(name: "John", age: 30)\n\n// Dictionaries (Maps)\nvar map: [String: String] = ["key": "value"]\nvar personDict = ["name": "John", "age": "30"]\n\n// Sets\nvar set: Set<Int> = [1, 2, 3]\n\n// Explicit types\nlet city: String = "New York"\nvar count: Int = 0\n\n// Multiple declaration\nvar (x, y) = (1, 2)'}]}),"\n",(0,a.jsx)(e.h2,{id:"sistema-de-tipos",children:"Sistema de Tipos"}),"\n",(0,a.jsx)(r.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Type checking - primitives\ntypeof 42;           // "number"\ntypeof "hello";      // "string"\ntypeof true;         // "boolean"\ntypeof undefined;    // "undefined"\n\n// Type checking - advanced\nArray.isArray([1, 2]);        // true\ninstanceof Date;              // check instance\nObject.prototype.toString.call([]);  // "[object Array]"\n\n// Implicit conversions\n"5" + 3;        // "53" (string concatenation)\n"5" - 3;        // 2 (numeric conversion)\ntrue + 1;       // 2 (boolean to number)\n\n// Explicit conversions\nNumber("42");           // 42\nString(42);             // "42"\nBoolean(1);             // true\nparseInt("42px");       // 42\nparseFloat("3.14");     // 3.14'},{name:"PHP",lang:"php",code:'// Type checking - primitives\ngettype(42);        // "integer"\ngettype("hello");   // "string"\ngettype(true);      // "boolean"\nis_int(42);         // true\nis_string("hello"); // true\nis_array([1, 2]);   // true\n\n// Type checking - advanced\nis_array([1, 2]);           // true\nis_object(new stdClass());   // true\ninstanceof DateTime;         // check instance\n\n// Implicit conversions (type juggling)\n"5" + 3;        // 8 (numeric conversion)\n"5" . 3;        // "53" (string concatenation)\ntrue + 1;       // 2 (boolean to number)\n\n// Explicit conversions\n(int)"42";              // 42\n(string)42;             // "42"\n(bool)1;                // true\n(float)"3.14";          // 3.14\narray(1, 2, 3);         // [1, 2, 3]'},{name:"Rust",lang:"rust",code:'// Type checking\nuse std::any::TypeId;\nTypeId::of::<i32>() == value.type_id();  // check type\nstd::mem::size_of::<i32>();               // size check\n\n// Pattern matching for types\nmatch value {\n  n if n is i32 => println!("integer"),\n  _ => println!("other"),\n}\n\n// No implicit conversions - compile error\n// let x: i32 = 42.5;  // error\n\n// Explicit conversions\nlet num: i32 = "42".parse().unwrap();\nlet float: f64 = 42.0;\nlet int_from_float: i32 = 42.5 as i32;      // 42\nlet float_from_int: f64 = 42 as f64;        // 42.0\nlet string: String = 42.to_string();         // "42"'},{name:"Go",lang:"go",code:'// Type checking\nimport "reflect"\nreflect.TypeOf(42)           // reflect.Type\nreflect.ValueOf(42).Kind()   // reflect.Int\n_, ok := value.(int)         // type assertion\n\n// No implicit conversions\n// var x int = 42.5  // compile error\n\n// Explicit conversions\nvar num int = int(42.5)              // 42\nvar float float64 = float64(42)      // 42.0\nvar str string = string(65)          // "A" (rune to string)\nvar str2 string = strconv.Itoa(42)  // "42" (int to string)\nvar num2, _ = strconv.Atoi("42")    // 42 (string to int)'},{name:"Python",lang:"python",code:'# Type checking - primitives\ntype(42)              # <class \'int\'>\ntype("hello")          # <class \'str\'>\nisinstance(42, int)    # True\nisinstance("hello", str)  # True\n\n# Type checking - advanced\nisinstance([1, 2], list)      # True\nisinstance({"key": "value"}, dict)  # True\nisinstance({1, 2}, set)       # True\nhasattr(obj, \'__iter__\')      # check if iterable\n\n# Implicit conversions\n"5" + str(3)          # "53" (explicit needed for +)\n5 + 3.0               # 8.0 (int to float)\nTrue + 1              # 2 (bool to int)\n\n# Explicit conversions\nint("42")             # 42\nstr(42)               # "42"\nfloat("3.14")         # 3.14\nbool(1)               # True\nlist("hello")         # [\'h\', \'e\', \'l\', \'l\', \'o\']'},{name:"Zig",lang:"zig",code:'// Type checking at compile time\n@TypeOf(42)           // comptime type\n@typeInfo(@TypeOf(42))  // type information\n\n// No implicit conversions\n// var x: i32 = 42.5;  // compile error\n\n// Explicit conversions\nvar num: i32 = @intFromFloat(42.5);      // 42\nvar float: f64 = @floatFromInt(42);      // 42.0\nvar int_from_float: i32 = @intCast(42.5);  // 42\nvar string = try std.fmt.allocPrint(allocator, "{d}", 42);  // "42"'},{name:"C#",lang:"csharp",code:'// Type checking\n42.GetType()              // System.Int32\ntypeof(int)               // System.Type\nvalue is int              // true\nvalue.GetType() == typeof(int)  // true\n\n// Type checking - advanced\narr is Array              // true\nobj is List<int>          // type check\nobj.GetType().IsArray     // check if array\n\n// Implicit conversions (widening)\nint x = 42;\nlong y = x;               // implicit (int to long)\nfloat f = 42;             // implicit (int to float)\n\n// Explicit conversions\nint num = (int)42.5;              // 42 (cast)\nint num2 = Convert.ToInt32(42.5); // 42\nstring str = value.ToString();    // "42"\nint parsed = int.Parse("42");     // 42\nbool success = int.TryParse("42", out int result);'},{name:"C++",lang:"cpp",code:'// Type checking\n#include <typeinfo>\ntypeid(42).name()         // type name\ntypeid(value) == typeid(int)  // type comparison\n\n// Type checking - advanced\n#include <type_traits>\nstd::is_array<int[5]>::value  // true\nstd::is_integral<int>::value  // true\n\n// Implicit conversions (promotions)\nint x = 42;\nlong y = x;               // implicit (int to long)\nfloat f = 42;             // implicit (int to float)\n\n// Explicit conversions\nint num = static_cast<int>(42.5);        // 42 (safe cast)\nint num2 = (int)42.5;                    // 42 (C-style cast)\nstd::string str = std::to_string(42);    // "42"\nint parsed = std::stoi("42");            // 42'},{name:"C",lang:"c",code:'// Type checking (limited at runtime)\nsizeof(int)              // size of type\n_Generic(value, int: 1, default: 0)  // type selection (C11)\n\n// Implicit conversions (promotions)\nint x = 42;\nlong y = x;              // implicit (int to long)\nfloat f = 42;            // implicit (int to float)\n\n// Explicit conversions (casting)\nint num = (int)42.5;              // 42\nfloat fnum = (float)42;           // 42.0\nchar str[20];\nsprintf(str, "%d", value);        // "42"\nint parsed = atoi("42");          // 42\ndouble parsed_d = atof("3.14");   // 3.14'},{name:"Java",lang:"java",code:'// Type checking\nvalue.getClass()              // Class<?>\nvalue instanceof Integer      // true\nInteger.class.isInstance(value)  // true\n\n// Type checking - advanced\narr instanceof int[]          // array check\nobj instanceof List           // interface check\nobj.getClass().isArray()      // check if array\n\n// Implicit conversions (widening)\nint x = 42;\nlong y = x;                   // implicit (int to long)\nfloat f = 42;                 // implicit (int to float)\n\n// Explicit conversions\nint num = (int)42.5;                  // 42 (cast)\nint num2 = Integer.valueOf("42");     // 42 (boxing)\nString str = String.valueOf(42);     // "42"\nint parsed = Integer.parseInt("42");  // 42\nInteger boxed = 42;                  // autoboxing'},{name:"Ruby",lang:"ruby",code:'# Type checking - primitives\n42.class              # Integer\n"hello".class          # String\ntrue.class             # TrueClass\n[1, 2].class           # Array\n\n# Type checking - advanced\nvalue.is_a?(Integer)   # true\nvalue.is_a?(Array)     # check if array\nvalue.is_a?(Hash)      # check if hash\nvalue.respond_to?(:each)  # check if iterable\n\n# Implicit conversions\n"5" + 3.to_s           # "53" (explicit needed)\n5 + 3.0                # 8.0 (int to float)\ntrue.to_i              # 1 (bool to int)\n\n# Explicit conversions\n"42".to_i              # 42\n42.to_s                # "42"\n"3.14".to_f            # 3.14\n1.to_bool              # true (if defined)\n[1, 2, 3].to_a         # [1, 2, 3]'},{name:"Swift",lang:"swift",code:'// Type checking\ntype(of: 42)           // Int.Type\nvalue is Int           // true\nvalue is String        // false\n\n// Type checking - advanced\narr is [Int]           // array type check\nobj is [String: Any]   // dictionary check\nvalue is AnyCollection // protocol check\n\n// Implicit conversions (limited)\nlet x: Int = 42\nlet y: Double = Double(x)  // explicit needed\n\n// Explicit conversions\nlet num = Int(42.5)              // 42\nlet float = Double(42)            // 42.0\nlet str = String(42)              // "42"\nlet parsed = Int("42")            // Optional(42)\nif let num = Int("42") {          // safe unwrap\n  // use num\n}'}]}),"\n",(0,a.jsx)(e.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Tipado est\xe1tico vs din\xe1mico"})," -- Los lenguajes est\xe1ticos (Rust, Go, Java, C#, Swift) imponen tipos en tiempo de compilaci\xf3n, por lo que los errores de tipo se detectan antes de que el programa se ejecute. Los lenguajes din\xe1micos (JavaScript, Python, PHP, Ruby) permiten que las variables cambien de tipo en tiempo de ejecuci\xf3n: ",(0,a.jsx)(e.code,{children:'let x = 42; x = "hello"'})," es v\xe1lido en JavaScript. El tipado est\xe1tico ofrece garant\xedas m\xe1s fuertes y mejores herramientas; el tipado din\xe1mico acelera la creaci\xf3n de prototipos. Para bases de c\xf3digo grandes o proyectos en equipo, prefiere el tipado est\xe1tico; para scripts r\xe1pidos o trabajo exploratorio, el tipado din\xe1mico puede ser m\xe1s flexible."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Inferencia de tipos"})," -- Muchos lenguajes est\xe1ticos infieren tipos para que escribas menos c\xf3digo repetitivo. C# y Java 10+ usan ",(0,a.jsx)(e.code,{children:"var"}),"; C++ usa ",(0,a.jsx)(e.code,{children:"auto"}),"; Rust y Swift usan ",(0,a.jsx)(e.code,{children:"let"}),"; Go usa ",(0,a.jsx)(e.code,{children:":="})," para declaraci\xf3n corta. Por ejemplo, ",(0,a.jsx)(e.code,{children:"let x = 42"})," en Rust infiere ",(0,a.jsx)(e.code,{children:"i32"}),", y ",(0,a.jsx)(e.code,{children:'name := "John"'})," en Go infiere ",(0,a.jsx)(e.code,{children:"string"}),". Zig y C generalmente requieren tipos expl\xedcitos. Usa inferencia donde mejore la legibilidad, pero agrega tipos expl\xedcitos cuando aclare la intenci\xf3n o cuando la inferencia produzca resultados sorprendentes."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Seguridad de tipos y conversiones"})," -- Rust y Go evitan conversiones impl\xedcitas; mezclar ",(0,a.jsx)(e.code,{children:"i32"})," y ",(0,a.jsx)(e.code,{children:"f64"})," en aritm\xe9tica requiere casts expl\xedcitos. JavaScript y PHP realizan coerci\xf3n de tipos: ",(0,a.jsx)(e.code,{children:'"5" + 3'})," produce ",(0,a.jsx)(e.code,{children:'"53"'})," en JavaScript (concatenaci\xf3n de strings) pero ",(0,a.jsx)(e.code,{children:"8"})," en PHP (conversi\xf3n num\xe9rica). C, C++ y Java permiten conversiones de ampliaci\xf3n (por ejemplo, ",(0,a.jsx)(e.code,{children:"int"})," a ",(0,a.jsx)(e.code,{children:"long"}),") impl\xedcitamente. Prefiere lenguajes con reglas de conversi\xf3n estrictas para mayor robustez; ten cuidado con las conversiones impl\xedcitas en JavaScript y PHP para evitar bugs sutiles."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Estilos de declaraci\xf3n de variables"})," -- JavaScript usa ",(0,a.jsx)(e.code,{children:"let"})," y ",(0,a.jsx)(e.code,{children:"const"}),"; PHP usa ",(0,a.jsx)(e.code,{children:"$variable"}),"; Go usa ",(0,a.jsx)(e.code,{children:"var"})," o ",(0,a.jsx)(e.code,{children:":="}),"; Python y Ruby usan nombres simples. Rust distingue ",(0,a.jsx)(e.code,{children:"let"})," (inmutable) de ",(0,a.jsx)(e.code,{children:"let mut"})," (mutable); Zig usa ",(0,a.jsx)(e.code,{children:"const"})," y ",(0,a.jsx)(e.code,{children:"var"}),". Swift usa ",(0,a.jsx)(e.code,{children:"let"})," para constantes y ",(0,a.jsx)(e.code,{children:"var"})," para variables. Adaptar tu modelo mental al estilo de declaraci\xf3n del lenguaje ayuda a evitar errores\u2014por ejemplo, olvidar que ",(0,a.jsx)(e.code,{children:"const"})," en JavaScript solo previene la reasignaci\xf3n, no la mutaci\xf3n de objetos."]}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);