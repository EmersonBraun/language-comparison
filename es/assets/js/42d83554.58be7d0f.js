"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[806],{846(e,n,a){a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"memory-management","title":"Gesti\xf3n de Memoria","description":"Gesti\xf3n de memoria -- recolecci\xf3n de basura, propiedad y memoria manual en 12 lenguajes","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/memory-management.md","sourceDirName":".","slug":"/memory-management","permalink":"/language-comparison/es/docs/memory-management","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/memory-management.md","tags":[],"version":"current","sidebarPosition":25,"frontMatter":{"sidebar_position":25,"description":"Gesti\xf3n de memoria -- recolecci\xf3n de basura, propiedad y memoria manual en 12 lenguajes","keywords":["gesti\xf3n de memoria","recolecci\xf3n de basura","propiedad","RAII","punteros inteligentes","ARC"]},"sidebar":"tutorialSidebar","previous":{"title":"Concurrency & Async","permalink":"/language-comparison/es/docs/concurrency-async"},"next":{"title":"Modules & Imports","permalink":"/language-comparison/es/docs/modules-imports"}}');var o=a(4848),t=a(8453),s=a(6153);const i={sidebar_position:25,description:"Gesti\xf3n de memoria -- recolecci\xf3n de basura, propiedad y memoria manual en 12 lenguajes",keywords:["gesti\xf3n de memoria","recolecci\xf3n de basura","propiedad","RAII","punteros inteligentes","ARC"]},l="Gesti\xf3n de Memoria",c={},d=[{value:"Descripci\xf3n General del Modelo de Memoria",id:"descripci\xf3n-general-del-modelo-de-memoria",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"gesti\xf3n-de-memoria",children:"Gesti\xf3n de Memoria"})}),"\n",(0,o.jsx)(n.p,{children:"C\xf3mo un lenguaje gestiona la memoria es una de las decisiones de dise\xf1o m\xe1s fundamentales. As\xed es como los diferentes lenguajes manejan la asignaci\xf3n, liberaci\xf3n y seguridad de la memoria."}),"\n","\n",(0,o.jsx)(n.h2,{id:"descripci\xf3n-general-del-modelo-de-memoria",children:"Descripci\xf3n General del Modelo de Memoria"}),"\n",(0,o.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// GARBAGE COLLECTED (automatic)\n// V8 engine uses generational GC\n\n// Objects are heap-allocated, GC handles cleanup\nlet obj = { name: "John" };\nobj = null;  // Eligible for garbage collection\n\n// WeakRef (allows GC to collect)\nlet target = { data: "important" };\nlet weakRef = new WeakRef(target);\nweakRef.deref();  // target or undefined\n\n// WeakMap / WeakSet (weak references)\nconst cache = new WeakMap();\ncache.set(obj, "cached");\n// When obj is GC\'d, entry is removed\n\n// FinalizationRegistry (cleanup callback)\nconst registry = new FinalizationRegistry((value) => {\n  console.log("Object collected:", value);\n});\nregistry.register(obj, "my object");\n\n// Memory leaks to watch for:\n// - Forgotten timers/intervals\n// - Closures holding references\n// - Detached DOM nodes\n// - Global variables'},{name:"PHP",lang:"php",code:"<?php\n// GARBAGE COLLECTED (reference counting + cycle collector)\n\n// Objects use reference counting\n$a = new stdClass();  // refcount = 1\n$b = $a;              // refcount = 2\nunset($a);            // refcount = 1\nunset($b);            // refcount = 0 -> freed\n\n// Circular reference detection\n$a = new stdClass();\n$b = new stdClass();\n$a->ref = $b;\n$b->ref = $a;\nunset($a, $b);  // Cycle collector handles this\n\n// Manual cleanup\nunset($variable);\n$variable = null;\n\n// Memory functions\nmemory_get_usage();       // Current memory\nmemory_get_peak_usage();  // Peak memory\n\n// PHP is request-scoped: all memory freed after request\n\n// Generators for memory-efficient iteration\nfunction bigRange($start, $end) {\n  for ($i = $start; $i <= $end; $i++) {\n      yield $i;  // Only one value in memory at a time\n  }\n}"},{name:"Rust",lang:"rust",code:'// OWNERSHIP SYSTEM (no GC, no manual free)\n// Zero-cost abstractions, compile-time safety\n\n// Ownership: each value has exactly one owner\nlet s1 = String::from("hello");\nlet s2 = s1;  // s1 is MOVED, no longer usable\n// println!("{}", s1);  // Compile error!\n\n// Borrowing: references without ownership\nfn print_len(s: &String) {  // Immutable borrow\n  println!("{}", s.len());\n}\n\nlet s = String::from("hello");\nprint_len(&s);  // s still valid\n\n// Mutable borrow (only one at a time)\nfn push_char(s: &mut String) {\n  s.push(\'!\');\n}\n\n// Lifetimes (compiler tracks reference validity)\nfn longest<\'a>(x: &\'a str, y: &\'a str) -> &\'a str {\n  if x.len() > y.len() { x } else { y }\n}\n\n// Smart pointers\nuse std::rc::Rc;      // Reference counted\nuse std::cell::RefCell; // Interior mutability\n\nlet shared = Rc::new(42);\nlet clone = Rc::clone(&shared);  // Rc count: 2\n\n// Box: heap allocation\nlet boxed = Box::new(42);\n// Automatically freed when Box goes out of scope'},{name:"Go",lang:"go",code:'// GARBAGE COLLECTED (concurrent, tri-color mark-sweep)\n\n// Stack vs Heap (escape analysis decides)\nfunc example() {\n  x := 42         // Likely stack-allocated\n  y := new(int)   // Likely heap-allocated\n  *y = 42\n\n  // Compiler decides allocation via escape analysis\n  return y  // y escapes to heap\n}\n\n// Pointers (but no pointer arithmetic)\nx := 42\nptr := &x\nfmt.Println(*ptr)  // 42\n\n// Make vs New\nslice := make([]int, 0, 100)  // make: slices, maps, channels\nptr := new(int)                // new: returns pointer\n\n// Defer for cleanup (not memory, but resources)\nfile, _ := os.Open("data.txt")\ndefer file.Close()\n\n// Finalizers (not recommended)\nruntime.SetFinalizer(obj, func(o *MyType) {\n  o.Cleanup()\n})\n\n// Memory stats\nvar m runtime.MemStats\nruntime.ReadMemStats(&m)\nfmt.Printf("Alloc: %d MB\\n", m.Alloc/1024/1024)\n\n// Manual GC trigger (rarely needed)\nruntime.GC()'},{name:"Python",lang:"python",code:"# GARBAGE COLLECTED (reference counting + generational GC)\n\nimport gc\nimport sys\n\n# Reference counting\na = [1, 2, 3]\nsys.getrefcount(a)  # Reference count\n\nb = a    # refcount increases\ndel b    # refcount decreases\n\n# Garbage collector for cycles\ngc.collect()           # Manual collection\ngc.get_count()         # Generation counts\ngc.disable()           # Disable GC (rare)\n\n# Weak references\nimport weakref\nobj = SomeClass()\nweak = weakref.ref(obj)\nweak()  # Returns obj or None\n\n# Context managers for resource cleanup\nwith open('file.txt') as f:\n  data = f.read()\n# File automatically closed\n\n# __del__ (destructor, unreliable)\nclass Resource:\n  def __del__(self):\n      self.cleanup()\n\n# Memory-efficient patterns\n# Generators instead of lists\nsquares = (x**2 for x in range(1000000))\n\n# __slots__ to reduce memory\nclass Point:\n  __slots__ = ['x', 'y']\n  def __init__(self, x, y):\n      self.x = x\n      self.y = y"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// MANUAL MEMORY (with allocator abstraction)\n// No GC, no hidden allocations\n\n// Allocator pattern\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\ndefer _ = gpa.deinit();  // Detect leaks in debug\n\n// Allocate and free\nconst ptr = try allocator.create(i32);\ndefer allocator.destroy(ptr);\nptr.* = 42;\n\n// Allocate slice\nconst slice = try allocator.alloc(u8, 100);\ndefer allocator.free(slice);\n\n// Arena allocator (bulk free)\nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\ndefer arena.deinit();  // Frees everything at once\n\n// Defer for cleanup (runs at scope exit)\nconst file = try std.fs.cwd().openFile("data.txt", .{});\ndefer file.close();\n\n// No hidden heap allocations\n// String concatenation, etc. require explicit allocator\nconst result = try std.fmt.allocPrint(allocator, "{s} {s}", .{"hello", "world"});\ndefer allocator.free(result);'},{name:"C#",lang:"csharp",code:'// GARBAGE COLLECTED (.NET GC, generational)\n\n// Value types (stack) vs Reference types (heap)\nint x = 42;           // Stack (value type)\nstring s = "hello";   // Heap (reference type)\n\n// GC is generational (Gen 0, 1, 2)\nGC.Collect();              // Force collection\nGC.GetTotalMemory(false);  // Current memory\n\n// IDisposable for unmanaged resources\nclass Connection : IDisposable\n{\n  public void Dispose()\n  {\n      // Release unmanaged resources\n  }\n}\n\n// Using statement (automatic Dispose)\nusing var conn = new Connection();\n// Disposed at end of scope\n\n// Span<T> / Memory<T> (stack-allocated views)\nSpan<int> span = stackalloc int[100];\n\n// ArrayPool (reuse arrays)\nvar pool = ArrayPool<byte>.Shared;\nvar buffer = pool.Rent(1024);\ntry { /* use buffer */ }\nfinally { pool.Return(buffer); }\n\n// Weak references\nvar weak = new WeakReference<MyClass>(obj);\nif (weak.TryGetTarget(out var target)) { }'},{name:"C++",lang:"cpp",code:'// MANUAL MEMORY (with RAII and smart pointers)\n\n// Stack allocation (automatic)\nint x = 42;  // Freed when scope exits\n\n// Heap allocation (manual)\nint* ptr = new int(42);\ndelete ptr;\n\nint* arr = new int[100];\ndelete[] arr;\n\n// RAII: Resource Acquisition Is Initialization\n{\n  std::ifstream file("data.txt");\n  // Automatically closed when scope exits\n}\n\n// Smart pointers (C++11, preferred)\n// unique_ptr: exclusive ownership\nauto uptr = std::make_unique<int>(42);\n// Automatically freed when uptr goes out of scope\n\n// shared_ptr: shared ownership (reference counted)\nauto sptr = std::make_shared<int>(42);\nauto sptr2 = sptr;  // Refcount: 2\n\n// weak_ptr: non-owning reference\nstd::weak_ptr<int> wptr = sptr;\nif (auto locked = wptr.lock()) {\n  // Use locked (shared_ptr)\n}\n\n// Move semantics\nauto v1 = std::make_unique<int>(42);\nauto v2 = std::move(v1);  // v1 is now null'},{name:"C",lang:"c",code:'#include <stdlib.h>\n\n// MANUAL MEMORY (malloc/free)\n\n// Stack allocation\nint x = 42;  // Freed when function returns\n\n// Heap allocation\nint* ptr = (int*)malloc(sizeof(int));\n*ptr = 42;\nfree(ptr);\nptr = NULL;  // Prevent dangling pointer\n\n// Array allocation\nint* arr = (int*)calloc(100, sizeof(int));  // Zero-initialized\narr = (int*)realloc(arr, 200 * sizeof(int)); // Resize\nfree(arr);\n\n// Common errors:\n// - Memory leak (forget to free)\n// - Double free\n// - Use after free\n// - Buffer overflow\n\n// Struct allocation\ntypedef struct {\n  char* name;\n  int age;\n} Person;\n\nPerson* p = malloc(sizeof(Person));\np->name = strdup("John");  // Also allocates\np->age = 30;\n\n// Must free in reverse order\nfree(p->name);\nfree(p);'},{name:"Java",lang:"java",code:'// GARBAGE COLLECTED (generational, multiple GC algorithms)\n\n// Everything on heap (except primitives)\nint x = 42;               // Stack (primitive)\nString s = "hello";        // Heap (object)\nInteger boxed = 42;        // Heap (autoboxed)\n\n// GC is automatic\nSystem.gc();  // Request GC (not guaranteed)\nRuntime.getRuntime().freeMemory();\nRuntime.getRuntime().totalMemory();\n\n// try-with-resources for cleanup\ntry (var conn = getConnection()) {\n  // Use connection\n}  // Auto-closed via AutoCloseable\n\n// Weak references\nWeakReference<Object> weak = new WeakReference<>(obj);\nObject ref = weak.get();  // null if GC\'d\n\n// SoftReference (cleared before OOM)\nSoftReference<byte[]> cache = new SoftReference<>(data);\n\n// JVM options\n// -Xms256m  (initial heap)\n// -Xmx1024m (max heap)\n// -XX:+UseG1GC (GC algorithm)\n\n// Off-heap memory (ByteBuffer)\nByteBuffer buffer = ByteBuffer.allocateDirect(1024);'},{name:"Ruby",lang:"ruby",code:'# GARBAGE COLLECTED (mark-and-sweep + generational)\n\n# Everything is an object (heap-allocated)\nx = 42\ns = "hello"\n\n# GC control\nGC.start           # Force collection\nGC.disable         # Disable GC\nGC.enable          # Re-enable GC\nGC.stat            # GC statistics\n\n# ObjectSpace (inspect heap)\nObjectSpace.count_objects\nObjectSpace.each_object(String) { |s| puts s }\n\n# Weak references\nrequire \'weakref\'\nobj = Object.new\nweak = WeakRef.new(obj)\nweak.weakref_alive?  # true\n\n# Finalizers\ndestructor = proc { |id| puts "Object #{id} collected" }\nObjectSpace.define_finalizer(obj, destructor)\n\n# Memory-efficient patterns\n# Symbols are interned (shared, not GC\'d)\n:my_symbol  # Single allocation, reused\n"my_string" # New allocation each time\n\n# Frozen strings (shared)\n# frozen_string_literal: true\n"hello".freeze'},{name:"Swift",lang:"swift",code:'// ARC (Automatic Reference Counting, compile-time)\n\n// Value types (stack): struct, enum, tuple\nstruct Point { var x: Int; var y: Int }\nvar p1 = Point(x: 1, y: 2)\nvar p2 = p1  // Copy (independent)\n\n// Reference types (heap): class\nclass Person {\n  var name: String\n  init(name: String) { self.name = name }\n  deinit { print("\\(name) deallocated") }\n}\n\nvar a: Person? = Person(name: "John")  // refcount: 1\nvar b = a   // refcount: 2\na = nil     // refcount: 1\nb = nil     // refcount: 0 -> deallocated\n\n// Weak references (breaks retain cycles)\nclass View {\n  weak var delegate: ViewDelegate?\n}\n\n// Unowned references (non-optional, assumed valid)\nclass Customer {\n  unowned let store: Store\n}\n\n// Retain cycle example\nclass A {\n  var b: B?\n}\nclass B {\n  weak var a: A?  // Break cycle with weak\n}\n\n// Closure capture lists\nlet closure = { [weak self] in\n  self?.doSomething()\n}'}]}),"\n",(0,o.jsx)(n.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"GC vs propiedad vs manual"})," -- La mayor\xeda de los lenguajes (JavaScript, Python, Go, Java, C#, Ruby, PHP) usan recolecci\xf3n de basura: asignas memoria y el runtime la reclama cuando los objetos son inalcanzables. Rust usa propiedad en tiempo de compilaci\xf3n: cada valor tiene un propietario y el compilador impone reglas de pr\xe9stamo. C, C++ y Zig usan memoria manual: llamas ",(0,o.jsx)(n.code,{children:"malloc"}),"/",(0,o.jsx)(n.code,{children:"free"}),", ",(0,o.jsx)(n.code,{children:"new"}),"/",(0,o.jsx)(n.code,{children:"delete"})," o ",(0,o.jsx)(n.code,{children:"allocator.alloc()"}),"/",(0,o.jsx)(n.code,{children:"allocator.free()"}),". El GC simplifica el desarrollo pero agrega latencia y no-determinismo; la propiedad (Rust) da seguridad sin GC; la gesti\xf3n manual da control total pero exige disciplina. Elige GC para productividad; Rust para seguridad y rendimiento; C/C++/Zig para sistemas, embebidos o cuando necesites asignaci\xf3n predecible."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Conteo de referencias"})," -- Swift usa ARC (en tiempo de compilaci\xf3n): el compilador inserta llamadas retain/release, y ",(0,o.jsx)(n.code,{children:"weak"}),"/",(0,o.jsx)(n.code,{children:"unowned"})," rompen los ciclos. C++ tiene ",(0,o.jsx)(n.code,{children:"std::shared_ptr"})," para propiedad compartida: ",(0,o.jsx)(n.code,{children:"auto sptr = std::make_shared<int>(42)"}),"; Rust ofrece ",(0,o.jsx)(n.code,{children:"Rc<T>"})," (un solo hilo) y ",(0,o.jsx)(n.code,{children:"Arc<T>"})," (seguro entre hilos) para propiedad compartida. PHP y Python usan conteo de referencias como parte del GC (m\xe1s detecci\xf3n de ciclos). El conteo de referencias proporciona limpieza determinista cuando se libera la \xfaltima referencia, pero puede generar sobrecarga y ciclos. Usa ARC/shared_ptr/Rc cuando necesites propiedad compartida; prefiere la propiedad de Rust cuando la propiedad \xfanica sea suficiente."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Garant\xedas de seguridad de memoria"})," -- Rust proporciona seguridad de memoria sin GC mediante propiedad y pr\xe9stamo: el compilador rechaza uso despu\xe9s de liberar, doble liberaci\xf3n y carreras de datos. Por ejemplo, ",(0,o.jsx)(n.code,{children:"let s2 = s1;"})," mueve ",(0,o.jsx)(n.code,{children:"s1"}),", as\xed que ",(0,o.jsx)(n.code,{children:"s1"})," ya no es utilizable despu\xe9s. C y C++ no tienen tales garant\xedas; errores como ",(0,o.jsx)(n.code,{children:"free(ptr); use(ptr)"})," o desbordamientos de buffer son comunes. El modelo manual de Zig es m\xe1s seguro que C (sin comportamiento indefinido en c\xf3digo seguro, asignadores expl\xedcitos) pero no previene el uso despu\xe9s de liberar. Elige Rust cuando la seguridad de memoria sea cr\xedtica; usa C/C++ solo cuando necesites control de bajo nivel y aceptes el riesgo; Zig se sit\xfaa entre ellos."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Patrones de limpieza de recursos"})," -- RAII (C++), ",(0,o.jsx)(n.code,{children:"defer"})," (Go, Zig), ",(0,o.jsx)(n.code,{children:"using"})," (C#) y ",(0,o.jsx)(n.code,{children:"with"})," (Python) vinculan el tiempo de vida del recurso al \xe1mbito. C++: ",(0,o.jsx)(n.code,{children:'std::ifstream file("data.txt");'})," -- se cierra cuando sale del \xe1mbito. Zig: ",(0,o.jsx)(n.code,{children:"defer file.close();"}),". C no tiene un patr\xf3n incorporado; debes emparejar manualmente asignar/liberar y manejar errores. Estos patrones previenen fugas y simplifican rutas de error. Prefiere lenguajes con limpieza estructurada cuando gestiones archivos, conexiones o recursos personalizados."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Asignaci\xf3n en heap vs stack"})," -- Los tipos valor (primitivos, structs en C#/Swift/Rust) a menudo viven en el stack; los tipos referencia y asignaciones din\xe1micas van al heap. Go usa an\xe1lisis de escape para decidir: ",(0,o.jsx)(n.code,{children:"return &x"})," fuerza la asignaci\xf3n en heap. Zig requiere un asignador expl\xedcito para asignaci\xf3n en heap: ",(0,o.jsx)(n.code,{children:"allocator.create(i32)"})," y ",(0,o.jsx)(n.code,{children:"allocator.destroy(ptr)"}),". ",(0,o.jsx)(n.code,{children:"stackalloc"})," y ",(0,o.jsx)(n.code,{children:"Span<T>"})," de C# permiten asignaci\xf3n en stack para rendimiento. Entender la asignaci\xf3n ayuda con el rendimiento y la predictibilidad. Para rutas cr\xedticas, prefiere asignaci\xf3n en stack cuando sea posible; usa Zig o C cuando necesites control expl\xedcito sobre la estrategia de asignaci\xf3n."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);