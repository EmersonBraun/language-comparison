"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[705],{8854(n,e,a){a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"classes-oop","title":"Clases y POO","description":"Clases, herencia, interfaces y polimorfismo comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/classes-oop.md","sourceDirName":".","slug":"/classes-oop","permalink":"/language-comparison/es/docs/classes-oop","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/classes-oop.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"description":"Clases, herencia, interfaces y polimorfismo comparados en 12 lenguajes de programaci\xf3n","keywords":["clases","POO","herencia","interfaces","polimorfismo","orientado a objetos"]},"sidebar":"tutorialSidebar","previous":{"title":"Maps & Dictionaries","permalink":"/language-comparison/es/docs/maps-dictionaries"},"next":{"title":"Generics & Templates","permalink":"/language-comparison/es/docs/generics-templates"}}');var o=a(4848),i=a(8453),t=a(6153);const r={sidebar_position:15,description:"Clases, herencia, interfaces y polimorfismo comparados en 12 lenguajes de programaci\xf3n",keywords:["clases","POO","herencia","interfaces","polimorfismo","orientado a objetos"]},l="Clases y POO",c={},m=[{value:"Definici\xf3n de Clases e Instanciaci\xf3n",id:"definici\xf3n-de-clases-e-instanciaci\xf3n",level:2},{value:"Interfaces y Polimorfismo",id:"interfaces-y-polimorfismo",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"clases-y-poo",children:"Clases y POO"})}),"\n",(0,o.jsx)(e.p,{children:"Los conceptos de Programaci\xf3n Orientada a Objetos var\xedan entre lenguajes. As\xed es como funcionan las clases, la herencia, las interfaces y el polimorfismo en diferentes lenguajes."}),"\n","\n",(0,o.jsx)(e.h2,{id:"definici\xf3n-de-clases-e-instanciaci\xf3n",children:"Definici\xf3n de Clases e Instanciaci\xf3n"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// ES6 Classes\nclass Person {\n  constructor(name, age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  greet() {\n      return `Hello, I\'m ${this.name}`;\n  }\n}\n\n// Instantiation\nconst person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  constructor(name, age, school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  study() {\n      return `${this.name} is studying`;\n  }\n}'},{name:"PHP",lang:"php",code:'<?php\n// Class definition\nclass Person {\n  private $name;\n  private $age;\n  \n  public function __construct($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n  }\n  \n  public function greet() {\n      return "Hello, I\'m " . $this->name;\n  }\n}\n\n// Instantiation\n$person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  private $school;\n  \n  public function __construct($name, $age, $school) {\n      parent::__construct($name, $age);\n      $this->school = $school;\n  }\n  \n  public function study() {\n      return $this->name . " is studying";\n  }\n}'},{name:"Rust",lang:"rust",code:'// Structs with impl blocks\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n      Person { name, age }\n  }\n  \n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}\n\n// Traits (similar to interfaces)\ntrait Greetable {\n  fn greet(&self) -> String;\n}\n\nimpl Greetable for Person {\n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}'},{name:"Go",lang:"go",code:'// Structs with methods\ntype Person struct {\n  name string\n  age  int\n}\n\nfunc NewPerson(name string, age int) *Person {\n  return &Person{name: name, age: age}\n}\n\nfunc (p *Person) Greet() string {\n  return fmt.Sprintf("Hello, I\'m %s", p.name)\n}\n\n// Interfaces\ntype Greetable interface {\n  Greet() string\n}\n\n// Embedding (composition)\ntype Student struct {\n  Person\n  school string\n}'},{name:"Python",lang:"python",code:'# Class definition\nclass Person:\n  def __init__(self, name, age):\n      self.name = name\n      self.age = age\n  \n  def greet(self):\n      return f"Hello, I\'m {self.name}"\n\n# Instantiation\nperson = Person("John", 30)\n\n# Inheritance\nclass Student(Person):\n  def __init__(self, name, age, school):\n      super().__init__(name, age)\n      self.school = school\n  \n  def study(self):\n      return f"{self.name} is studying"'},{name:"Zig",lang:"zig",code:'// Structs with methods\nconst Person = struct {\n  name: []const u8,\n  age: u32,\n  \n  pub fn init(name: []const u8, age: u32) Person {\n      return Person{\n          .name = name,\n          .age = age,\n      };\n  }\n  \n  pub fn greet(self: Person) []const u8 {\n      return "Hello, I\'m " ++ self.name;\n  }\n};\n\n// Interfaces (using function pointers)\nconst Greetable = struct {\n  greet: fn (*const anyopaque) []const u8,\n};'},{name:"C#",lang:"csharp",code:'// Class definition\npublic class Person\n{\n  private string name;\n  private int age;\n  \n  public Person(string name, int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public virtual string Greet()\n  {\n      return $"Hello, I\'m {name}";\n  }\n}\n\n// Instantiation\nvar person = new Person("John", 30);\n\n// Inheritance\npublic class Student : Person\n{\n  private string school;\n  \n  public Student(string name, int age, string school) \n      : base(name, age)\n  {\n      this.school = school;\n  }\n  \n  public override string Greet()\n  {\n      return base.Greet() + $" and I study at {school}";\n  }\n}'},{name:"C++",lang:"cpp",code:'// Class definition\nclass Person {\nprivate:\n  std::string name;\n  int age;\n  \npublic:\n  Person(const std::string& name, int age) \n      : name(name), age(age) {}\n  \n  virtual std::string greet() const {\n      return "Hello, I\'m " + name;\n  }\n  \n  virtual ~Person() = default;\n};\n\n// Instantiation\nPerson person("John", 30);\n\n// Inheritance\nclass Student : public Person {\nprivate:\n  std::string school;\n  \npublic:\n  Student(const std::string& name, int age, \n          const std::string& school)\n      : Person(name, age), school(school) {}\n  \n  std::string greet() const override {\n      return Person::greet() + " and I study at " + school;\n  }\n};'},{name:"C",lang:"c",code:'// Struct with function pointers (OOP-like)\ntypedef struct {\n  char name[50];\n  int age;\n  void (*greet)(struct Person*);\n} Person;\n\nvoid person_greet(Person* self) {\n  printf("Hello, I\'m %s\\n", self->name);\n}\n\nPerson* person_new(const char* name, int age) {\n  Person* p = malloc(sizeof(Person));\n  strcpy(p->name, name);\n  p->age = age;\n  p->greet = person_greet;\n  return p;\n}'},{name:"Java",lang:"java",code:'// Class definition\npublic class Person {\n  private String name;\n  private int age;\n  \n  public Person(String name, int age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public String greet() {\n      return "Hello, I\'m " + name;\n  }\n}\n\n// Instantiation\nPerson person = new Person("John", 30);\n\n// Inheritance\npublic class Student extends Person {\n  private String school;\n  \n  public Student(String name, int age, String school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  @Override\n  public String greet() {\n      return super.greet() + " and I study at " + school;\n  }\n}'},{name:"Ruby",lang:"ruby",code:'# Class definition\nclass Person\n  def initialize(name, age)\n      @name = name\n      @age = age\n  end\n  \n  def greet\n      "Hello, I\'m #{@name}"\n  end\nend\n\n# Instantiation\nperson = Person.new("John", 30)\n\n# Inheritance\nclass Student < Person\n  def initialize(name, age, school)\n      super(name, age)\n      @school = school\n  end\n  \n  def study\n      "#{@name} is studying"\n  end\nend'},{name:"Swift",lang:"swift",code:'// Class definition\nclass Person {\n  private var name: String\n  private var age: Int\n  \n  init(name: String, age: Int) {\n      self.name = name\n      self.age = age\n  }\n  \n  func greet() -> String {\n      "Hello, I\'m \\(name)"\n  }\n}\n\n// Instantiation\nlet person = Person(name: "John", age: 30)\n\n// Inheritance\nclass Student: Person {\n  private var school: String\n  \n  init(name: String, age: Int, school: String) {\n      self.school = school\n      super.init(name: name, age: age)\n  }\n  \n  override func greet() -> String {\n      super.greet() + " and I study at \\(school)"\n  }\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"interfaces-y-polimorfismo",children:"Interfaces y Polimorfismo"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// No native interfaces, use duck typing\nclass Dog {\n  makeSound() {\n      return "Woof!";\n  }\n}\n\nclass Cat {\n  makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(animal) {\n  return animal.makeSound();\n}\n\n// TypeScript interfaces\ninterface Animal {\n  makeSound(): string;\n}'},{name:"PHP",lang:"php",code:'<?php\n// Interfaces\ninterface Animal {\n  public function makeSound(): string;\n}\n\nclass Dog implements Animal {\n  public function makeSound(): string {\n      return "Woof!";\n  }\n}\n\nclass Cat implements Animal {\n  public function makeSound(): string {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(Animal $animal): string {\n  return $animal->makeSound();\n}'},{name:"Rust",lang:"rust",code:'// Traits (interfaces)\ntrait Animal {\n  fn make_sound(&self) -> String;\n}\n\nstruct Dog;\nimpl Animal for Dog {\n  fn make_sound(&self) -> String {\n      "Woof!".to_string()\n  }\n}\n\nstruct Cat;\nimpl Animal for Cat {\n  fn make_sound(&self) -> String {\n      "Meow!".to_string()\n  }\n}\n\n// Polymorphism\nfn animal_sound(animal: &dyn Animal) -> String {\n  animal.make_sound()\n}'},{name:"Go",lang:"go",code:'// Interfaces\ntype Animal interface {\n  MakeSound() string\n}\n\ntype Dog struct{}\nfunc (d Dog) MakeSound() string {\n  return "Woof!"\n}\n\ntype Cat struct{}\nfunc (c Cat) MakeSound() string {\n  return "Meow!"\n}\n\n// Polymorphism\nfunc AnimalSound(a Animal) string {\n  return a.MakeSound()\n}'},{name:"Python",lang:"python",code:'# Duck typing (no explicit interfaces)\nclass Dog:\n  def make_sound(self):\n      return "Woof!"\n\nclass Cat:\n  def make_sound(self):\n      return "Meow!"\n\n# Polymorphism\ndef animal_sound(animal):\n  return animal.make_sound()\n\n# ABC (Abstract Base Classes)\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n  @abstractmethod\n  def make_sound(self):\n      pass'},{name:"Zig",lang:"zig",code:'// Function pointers (interface-like)\nconst Animal = struct {\n  make_sound: fn (*const anyopaque) []const u8,\n};\n\nconst Dog = struct {\n  pub fn make_sound(self: *const Dog) []const u8 {\n      return "Woof!";\n  }\n};\n\n// Polymorphism through function pointers\nfn animal_sound(animal: Animal) []const u8 {\n  return animal.make_sound(animal.self);\n}'},{name:"C#",lang:"csharp",code:'// Interfaces\npublic interface IAnimal\n{\n  string MakeSound();\n}\n\npublic class Dog : IAnimal\n{\n  public string MakeSound() => "Woof!";\n}\n\npublic class Cat : IAnimal\n{\n  public string MakeSound() => "Meow!";\n}\n\n// Polymorphism\npublic static string AnimalSound(IAnimal animal)\n{\n  return animal.MakeSound();\n}'},{name:"C++",lang:"cpp",code:'// Abstract classes\nclass Animal {\npublic:\n  virtual std::string makeSound() = 0;\n  virtual ~Animal() = default;\n};\n\nclass Dog : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Woof!";\n  }\n};\n\nclass Cat : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Meow!";\n  }\n};\n\n// Polymorphism\nstd::string animalSound(Animal* animal) {\n  return animal->makeSound();\n}'},{name:"C",lang:"c",code:'// Function pointers in structs\ntypedef struct {\n  void* self;\n  char* (*makeSound)(void*);\n} Animal;\n\nchar* dog_makeSound(void* self) {\n  return "Woof!";\n}\n\nchar* cat_makeSound(void* self) {\n  return "Meow!";\n}\n\n// Polymorphism\nchar* animalSound(Animal* animal) {\n  return animal->makeSound(animal->self);\n}'},{name:"Java",lang:"java",code:'// Interfaces\npublic interface Animal {\n  String makeSound();\n}\n\npublic class Dog implements Animal {\n  @Override\n  public String makeSound() {\n      return "Woof!";\n  }\n}\n\npublic class Cat implements Animal {\n  @Override\n  public String makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\npublic static String animalSound(Animal animal) {\n  return animal.makeSound();\n}'},{name:"Ruby",lang:"ruby",code:'# Modules as interfaces\nmodule Animal\n  def make_sound\n      raise NotImplementedError\n  end\nend\n\nclass Dog\n  include Animal\n  \n  def make_sound\n      "Woof!"\n  end\nend\n\nclass Cat\n  include Animal\n  \n  def make_sound\n      "Meow!"\n  end\nend\n\n# Polymorphism\ndef animal_sound(animal)\n  animal.make_sound\nend'},{name:"Swift",lang:"swift",code:'// Protocols (interfaces)\nprotocol Animal {\n  func makeSound() -> String\n}\n\nclass Dog: Animal {\n  func makeSound() -> String {\n      "Woof!"\n  }\n}\n\nclass Cat: Animal {\n  func makeSound() -> String {\n      "Meow!"\n  }\n}\n\n// Polymorphism\nfunc animalSound(_ animal: Animal) -> String {\n  animal.makeSound()\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Modelos de herencia"})," \u2014 Java, C#, C++, PHP, Ruby, Swift y JavaScript usan herencia simple basada en clases con la sintaxis ",(0,o.jsx)(e.code,{children:"extends"})," o ",(0,o.jsx)(e.code,{children:":"}),"; por ejemplo, ",(0,o.jsx)(e.code,{children:"class Student extends Person"})," en Java o ",(0,o.jsx)(e.code,{children:"class Student(Person)"})," en Python. Go rechaza la herencia por completo y usa composici\xf3n por incrustaci\xf3n: ",(0,o.jsx)(e.code,{children:"type Student struct { Person; school string }"})," incrusta los campos y m\xe9todos de Person directamente. Rust no tiene herencia en absoluto\u2014solo traits que los tipos implementan. Elige Go o Rust cuando quieras composici\xf3n sobre jerarqu\xeda; elige Java/C#/Swift cuando necesites taxonom\xedas de clases claras y sobreescritura de m\xe9todos."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Patrones de interfaces"})," \u2014 Java, C#, Swift y PHP requieren declaraciones expl\xedcitas de ",(0,o.jsx)(e.code,{children:"implements"}),": ",(0,o.jsx)(e.code,{children:"class Dog implements Animal"}),". Go usa tipado estructural: cualquier tipo con un m\xe9todo ",(0,o.jsx)(e.code,{children:"MakeSound() string"})," satisface ",(0,o.jsx)(e.code,{children:"type Animal interface { MakeSound() string }"})," sin declararlo. Python y Ruby dependen del duck typing\u2014si tiene ",(0,o.jsx)(e.code,{children:"make_sound()"}),", funciona. Los traits de Rust funcionan como interfaces: ",(0,o.jsx)(e.code,{children:"impl Animal for Dog { fn make_sound(&self) -> String { ... } }"}),". C y Zig simulan interfaces mediante structs de punteros a funciones. Prefiere interfaces impl\xedcitas al estilo Go para flexibilidad; prefiere interfaces expl\xedcitas cuando quieras aplicaci\xf3n de contratos en tiempo de compilaci\xf3n."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Filosof\xeda de POO"})," \u2014 La POO tradicional (Java, C#, C++) se centra en clases, jerarqu\xedas de herencia y ",(0,o.jsx)(e.code,{children:"virtual"}),"/",(0,o.jsx)(e.code,{children:"override"}),' para polimorfismo. Go y Rust favorecen la composici\xf3n y los traits: "prefiere composici\xf3n sobre herencia." JavaScript y Python son multiparadigma\u2014puedes usar clases o evitarlas por completo. Si est\xe1s construyendo modelos de dominio con jerarqu\xedas claras (por ejemplo, ',(0,o.jsx)(e.code,{children:"Vehiculo"})," \u2192 ",(0,o.jsx)(e.code,{children:"Auto"})," \u2192 ",(0,o.jsx)(e.code,{children:"AutoElectrico"}),"), Java/C#/Swift sobresalen. Si quieres dise\xf1os planos y componibles con m\xednima ceremonia, elige Go o Rust."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Memoria y ciclo de vida"})," \u2014 C++ y Rust requieren atenci\xf3n expl\xedcita al ciclo de vida de los objetos: C++ usa destructores ",(0,o.jsx)(e.code,{children:"virtual"})," y RAII; la propiedad de Rust previene referencias colgantes. Java, C#, PHP, Ruby, Python y JavaScript usan recolecci\xf3n de basura, as\xed que raramente gestionas el tiempo de vida de los objetos. Go usa un GC ligero. Para programaci\xf3n de sistemas o c\xf3digo cr\xedtico en rendimiento, Rust y C++ te dan control; para desarrollo r\xe1pido, los lenguajes con recolecci\xf3n de basura reducen la carga cognitiva."]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);