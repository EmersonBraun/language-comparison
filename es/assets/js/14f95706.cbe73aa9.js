"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[173],{6006(n,e,a){a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"maps-dictionaries","title":"Maps & Dictionaries","description":"Hash maps, dictionaries, and associative arrays compared across 12 programming languages","source":"@site/docs/maps-dictionaries.md","sourceDirName":".","slug":"/maps-dictionaries","permalink":"/language-comparison/es/docs/maps-dictionaries","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/maps-dictionaries.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"description":"Hash maps, dictionaries, and associative arrays compared across 12 programming languages","keywords":["maps","dictionaries","hash maps","associative arrays","key-value"]},"sidebar":"tutorialSidebar","previous":{"title":"Objects & Structs","permalink":"/language-comparison/es/docs/objects-structs"},"next":{"title":"Classes & OOP","permalink":"/language-comparison/es/docs/classes-oop"}}');var t=a(4848),r=a(8453),i=a(2531);const o={sidebar_position:14,description:"Hash maps, dictionaries, and associative arrays compared across 12 programming languages",keywords:["maps","dictionaries","hash maps","associative arrays","key-value"]},c="Maps & Dictionaries",d={},p=[{value:"Creating &amp; Accessing Maps",id:"creating--accessing-maps",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"maps--dictionaries",children:"Maps & Dictionaries"})}),"\n",(0,t.jsx)(e.p,{children:"Maps (also known as dictionaries, hash maps, or associative arrays) store key-value pairs. Here's how different languages handle them."}),"\n","\n",(0,t.jsx)(e.h2,{id:"creating--accessing-maps",children:"Creating & Accessing Maps"}),"\n",(0,t.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Object (string keys only)\nconst obj = { name: "John", age: 30 };\nobj.name;         // "John"\nobj["age"];       // 30\n\n// Map (any key type)\nconst map = new Map();\nmap.set("key", "value");\nmap.set(42, "number key");\nmap.set(obj, "object key");\n\nmap.get("key");       // "value"\nmap.has("key");       // true\nmap.size;             // 3\nmap.delete("key");\n\n// Initialize Map\nconst map2 = new Map([\n  ["a", 1], ["b", 2], ["c", 3]\n]);\n\n// WeakMap (keys are garbage collected)\nconst weakMap = new WeakMap();\nweakMap.set(obj, "data");'},{name:"PHP",lang:"php",code:'<?php\n// Associative array\n$map = [\n  "name" => "John",\n  "age" => 30,\n];\n\n$map["name"];         // "John"\n$map["city"] = "NYC"; // Add\nisset($map["name"]);  // true\nunset($map["age"]);   // Delete\ncount($map);          // Size\n\n// Array functions\narray_key_exists("name", $map);  // true\narray_keys($map);       // ["name", "city"]\narray_values($map);     // ["John", "NYC"]\n\n// Merge\n$merged = array_merge($map1, $map2);\n\n// SplObjectStorage (object keys)\n$storage = new SplObjectStorage();\n$storage[$obj] = "data";'},{name:"Rust",lang:"rust",code:'use std::collections::HashMap;\n\n// Create\nlet mut map = HashMap::new();\nmap.insert("name", "John");\nmap.insert("city", "NYC");\n\n// Access\nmap.get("name");        // Some("John")\nmap["name"];            // "John" (panics if missing)\nmap.contains_key("name"); // true\n\n// Initialize with collect\nlet map: HashMap<&str, i32> = vec![\n  ("a", 1), ("b", 2), ("c", 3),\n].into_iter().collect();\n\n// Entry API (insert if missing)\nmap.entry("count")\n .or_insert(0);\n*map.entry("count").or_insert(0) += 1;\n\n// Remove\nmap.remove("name");\nmap.len();  // Size\n\n// BTreeMap (ordered)\nuse std::collections::BTreeMap;\nlet ordered = BTreeMap::new();'},{name:"Go",lang:"go",code:'// Create\nm := map[string]string{\n  "name": "John",\n  "city": "NYC",\n}\n\n// Access\nname := m["name"]         // "John"\nvalue, ok := m["missing"] // "", false\n\n// Check existence\nif val, ok := m["name"]; ok {\n  fmt.Println(val)\n}\n\n// Add / Update\nm["age"] = "30"\n\n// Delete\ndelete(m, "age")\n\n// Size\nlen(m)\n\n// Make with capacity\nm2 := make(map[string]int, 100)\n\n// Iterate\nfor key, value := range m {\n  fmt.Printf("%s: %s\\n", key, value)\n}'},{name:"Python",lang:"python",code:'# Dict literal\nd = {"name": "John", "age": 30}\n\n# Access\nd["name"]               # "John"\nd.get("name")           # "John"\nd.get("missing", "default")  # "default"\n\n# Add / Update\nd["city"] = "NYC"\nd.update({"city": "NYC", "zip": "10001"})\n\n# Delete\ndel d["age"]\nd.pop("age", None)  # Remove with default\n\n# Check\n"name" in d          # True\nlen(d)               # Size\n\n# Methods\nd.keys()             # dict_keys\nd.values()           # dict_values\nd.items()            # dict_items\n\n# Dict comprehension\nsquares = {x: x**2 for x in range(5)}\n\n# defaultdict\nfrom collections import defaultdict\ndd = defaultdict(list)\ndd["key"].append(1)  # Auto-creates list\n\n# OrderedDict (maintains insertion order)\n# Note: regular dict is ordered since Python 3.7'},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// HashMap\nvar map = std.StringHashMap(i32).init(allocator);\ndefer map.deinit();\n\n// Insert\ntry map.put("name", 42);\ntry map.put("age", 30);\n\n// Access\nconst value = map.get("name");  // ?i32\nif (map.get("name")) |v| {\n  std.debug.print("{d}\\n", .{v});\n}\n\n// Remove\n_ = map.remove("name");\n\n// Contains\nconst exists = map.contains("name");\n\n// Size\nconst size = map.count();\n\n// Iterate\nvar it = map.iterator();\nwhile (it.next()) |entry| {\n  std.debug.print("{s}: {d}\\n",\n      .{entry.key_ptr.*, entry.value_ptr.*});\n}\n\n// AutoHashMap (auto-managed)\nvar auto_map = std.AutoHashMap(i32, []const u8).init(allocator);'},{name:"C#",lang:"csharp",code:'// Dictionary\nvar dict = new Dictionary<string, string>\n{\n  ["name"] = "John",\n  ["city"] = "NYC",\n};\n\n// Access\ndict["name"];                // "John"\ndict.TryGetValue("name", out var value); // true\ndict.ContainsKey("name");    // true\n\n// Add / Update\ndict["age"] = "30";\ndict.Add("zip", "10001");   // Throws if exists\n\n// Remove\ndict.Remove("age");\ndict.Count;                  // Size\n\n// Iterate\nforeach (var (key, val) in dict)\n{\n  Console.WriteLine($"{key}: {val}");\n}\n\n// SortedDictionary (ordered by key)\nvar sorted = new SortedDictionary<string, int>();\n\n// ConcurrentDictionary (thread-safe)\nvar concurrent = new ConcurrentDictionary<string, int>();'},{name:"C++",lang:"cpp",code:'#include <map>\n#include <unordered_map>\n\n// unordered_map (hash map)\nstd::unordered_map<std::string, int> map;\nmap["name"] = 42;\nmap["age"] = 30;\n\n// Access\nmap["name"];                 // 42\nmap.at("name");              // 42 (throws if missing)\nmap.count("name");           // 1 or 0\nmap.find("name") != map.end(); // true\n\n// Insert\nmap.insert({"city", 1});\nmap.emplace("zip", 2);\n\n// Remove\nmap.erase("age");\nmap.size();\n\n// Initialize\nstd::unordered_map<std::string, int> m = {\n  {"a", 1}, {"b", 2}, {"c", 3}\n};\n\n// std::map (ordered, tree-based)\nstd::map<std::string, int> ordered;'},{name:"C",lang:"c",code:"// No built-in hash map\n// Common approaches:\n\n// Simple struct array\n#define MAX_ENTRIES 100\ntypedef struct {\n  char key[50];\n  int value;\n} Entry;\n\nEntry map[MAX_ENTRIES];\nint map_size = 0;\n\n// Add\nvoid map_put(const char* key, int value) {\n  strcpy(map[map_size].key, key);\n  map[map_size].value = value;\n  map_size++;\n}\n\n// Find (linear search)\nint* map_get(const char* key) {\n  for (int i = 0; i < map_size; i++) {\n      if (strcmp(map[i].key, key) == 0)\n          return &map[i].value;\n  }\n  return NULL;\n}\n\n// For real projects, use libraries like\n// uthash, glib GHashTable, etc."},{name:"Java",lang:"java",code:'// HashMap\nMap<String, Integer> map = new HashMap<>();\nmap.put("name", 42);\nmap.put("age", 30);\n\n// Access\nmap.get("name");           // 42\nmap.getOrDefault("missing", 0); // 0\nmap.containsKey("name");   // true\n\n// Add / Update\nmap.put("city", 1);\nmap.putIfAbsent("city", 2); // Won\'t overwrite\n\n// Remove\nmap.remove("age");\nmap.size();\n\n// Initialize (Java 9+)\nvar m = Map.of("a", 1, "b", 2, "c", 3);\n\n// Iterate\nfor (var entry : map.entrySet()) {\n  System.out.println(entry.getKey() + ": " + entry.getValue());\n}\nmap.forEach((k, v) -> System.out.println(k + ": " + v));\n\n// TreeMap (sorted)\nMap<String, Integer> sorted = new TreeMap<>();\n\n// ConcurrentHashMap (thread-safe)\nMap<String, Integer> concurrent = new ConcurrentHashMap<>();'},{name:"Ruby",lang:"ruby",code:'# Hash literal\nhash = { name: "John", age: 30 }\nhash2 = { "name" => "John", "age" => 30 }\n\n# Access\nhash[:name]              # "John"\nhash.fetch(:name)        # "John" (raises if missing)\nhash.fetch(:missing, "default")  # "default"\n\n# Add / Update\nhash[:city] = "NYC"\nhash.merge!({ zip: "10001" })\n\n# Delete\nhash.delete(:age)\nhash.size                # Size\n\n# Check\nhash.key?(:name)         # true\nhash.value?("John")      # true\n\n# Iterate\nhash.each { |k, v| puts "#{k}: #{v}" }\n\n# Transform\nhash.map { |k, v| [k, v.to_s] }.to_h\nhash.select { |k, v| v.is_a?(String) }\nhash.transform_values { |v| v.to_s }\n\n# Dig (nested access)\ndata = { user: { address: { city: "NYC" } } }\ndata.dig(:user, :address, :city)  # "NYC"'},{name:"Swift",lang:"swift",code:'// Dictionary literal\nvar dict: [String: Int] = [\n  "name": 42,\n  "age": 30,\n]\n\n// Access (returns Optional)\ndict["name"]               // Optional(42)\ndict["missing"]            // nil\ndict["missing", default: 0]  // 0\n\n// Add / Update\ndict["city"] = 1\ndict.updateValue(2, forKey: "city")\n\n// Remove\ndict.removeValue(forKey: "age")\ndict.count                 // Size\n\n// Check\ndict.keys.contains("name")  // true\n\n// Iterate\nfor (key, value) in dict {\n  print("\\(key): \\(value)")\n}\n\n// Transform\nlet mapped = dict.mapValues { $0 * 2 }\nlet filtered = dict.filter { $0.value > 10 }\n\n// Grouping\nlet grouped = Dictionary(grouping: items) { $0.category }'}]}),"\n",(0,t.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Built-in syntax support"})," -- JavaScript, Python, Ruby, Go, and Swift have dedicated map/dict literal syntax (e.g., ",(0,t.jsx)(e.code,{children:'{"name": "John"}'})," in Python, ",(0,t.jsx)(e.code,{children:'map[string]string{"name": "John"}'})," in Go). C has no built-in hash map and requires libraries like uthash or manual implementation. Literal syntax improves readability and reduces boilerplate. If you work heavily with key-value data (config, caches, JSON), choose a language with first-class map support; for C, plan to integrate a library early."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Ordered vs unordered"})," -- Python dicts (3.7+), PHP arrays, and JavaScript ",(0,t.jsx)(e.code,{children:"Map"})," preserve insertion order. Rust's ",(0,t.jsx)(e.code,{children:"HashMap"})," is unordered; use ",(0,t.jsx)(e.code,{children:"BTreeMap"})," for key-ordered iteration. Go maps are unordered; Java's ",(0,t.jsx)(e.code,{children:"HashMap"})," is unordered (use ",(0,t.jsx)(e.code,{children:"LinkedHashMap"})," for insertion order). Order matters for reproducible output, LRU caches, or when order encodes meaning. Prefer Python, PHP, or JavaScript ",(0,t.jsx)(e.code,{children:"Map"})," when order is important; Rust's ",(0,t.jsx)(e.code,{children:"BTreeMap"})," when you need sorted keys."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Safe access patterns"})," -- Go's ",(0,t.jsx)(e.code,{children:'value, ok := m["key"]'})," returns a boolean for existence; Swift's optional subscript (",(0,t.jsx)(e.code,{children:'dict["key"]'}),") returns ",(0,t.jsx)(e.code,{children:"nil"})," for missing keys; Python's ",(0,t.jsx)(e.code,{children:'dict.get("key", default)'})," and Ruby's ",(0,t.jsx)(e.code,{children:"hash.fetch(:key, default)"})," avoid exceptions. Direct indexing in Rust (",(0,t.jsx)(e.code,{children:'map["key"]'}),") panics if the key is missing; C++ ",(0,t.jsx)(e.code,{children:'map["key"]'})," creates an entry with a default value. Use safe access when keys may be absent (e.g., user input, optional config); direct indexing when keys are guaranteed."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Key and value types"})," -- JavaScript's plain objects support only string keys; ",(0,t.jsx)(e.code,{children:"Map"})," allows any type including objects. Python dicts require hashable keys (e.g., strings, numbers, tuples). Go maps require comparable keys. Rust's ",(0,t.jsx)(e.code,{children:"HashMap"})," needs keys implementing ",(0,t.jsx)(e.code,{children:"Hash"})," and ",(0,t.jsx)(e.code,{children:"Eq"}),". Choose ",(0,t.jsx)(e.code,{children:"Map"})," in JavaScript when you need non-string keys; in Rust, consider ",(0,t.jsx)(e.code,{children:"BTreeMap"})," for custom key types that don't implement ",(0,t.jsx)(e.code,{children:"Hash"})," well."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Thread safety and concurrency"})," -- Java's ",(0,t.jsx)(e.code,{children:"ConcurrentHashMap"})," and C#'s ",(0,t.jsx)(e.code,{children:"ConcurrentDictionary"})," are built for concurrent access. Go maps are not safe for concurrent writes; use ",(0,t.jsx)(e.code,{children:"sync.Map"})," or mutexes. Rust's ownership model prevents data races without a separate concurrent map type. For shared mutable state across threads, prefer Java or C#; in Go, wrap maps with mutexes or use ",(0,t.jsx)(e.code,{children:"sync.Map"}),"; in Rust, use channels or ",(0,t.jsx)(e.code,{children:"Arc<Mutex<HashMap>>"}),"."]}),"\n"]}),"\n"]})]})}function l(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);