"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[930],{5832(n,e,t){t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"closures-lambdas","title":"Closures & Lambdas","description":"Closures, lambdas, anonymous functions, and higher-order functions across 12 languages","source":"@site/docs/closures-lambdas.md","sourceDirName":".","slug":"/closures-lambdas","permalink":"/language-comparison/es/docs/closures-lambdas","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/closures-lambdas.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"description":"Closures, lambdas, anonymous functions, and higher-order functions across 12 languages","keywords":["closures","lambdas","anonymous functions","higher-order functions","callbacks"]},"sidebar":"tutorialSidebar","previous":{"title":"Functions","permalink":"/language-comparison/es/docs/functions"},"next":{"title":"Arrays","permalink":"/language-comparison/es/docs/arrays"}}');var a=t(4848),o=t(8453),i=t(2531);const s={sidebar_position:10,description:"Closures, lambdas, anonymous functions, and higher-order functions across 12 languages",keywords:["closures","lambdas","anonymous functions","higher-order functions","callbacks"]},c="Closures & Lambdas",u={},l=[{value:"Closures &amp; Anonymous Functions",id:"closures--anonymous-functions",level:2},{value:"Higher-Order Functions",id:"higher-order-functions",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"closures--lambdas",children:"Closures & Lambdas"})}),"\n",(0,a.jsx)(e.p,{children:"Closures are functions that capture variables from their surrounding scope. Here's how different languages handle closures, lambdas, and higher-order functions."}),"\n","\n",(0,a.jsx)(e.h2,{id:"closures--anonymous-functions",children:"Closures & Anonymous Functions"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Arrow functions (closures)\nconst add = (a, b) => a + b;\nconst square = x => x * x;\n\n// Capturing variables\nfunction counter() {\n  let count = 0;\n  return {\n      increment: () => ++count,\n      getCount: () => count,\n  };\n}\nconst c = counter();\nc.increment();  // 1\nc.increment();  // 2\nc.getCount();   // 2\n\n// IIFE (Immediately Invoked)\nconst result = ((x) => x * 2)(5);  // 10\n\n// Closures in loops\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n  // Prints 0, 1, 2 (let creates new scope)\n}"},{name:"PHP",lang:"php",code:"<?php\n// Anonymous functions\n$add = function($a, $b) { return $a + $b; };\n$add(1, 2);  // 3\n\n// Arrow functions (PHP 7.4+)\n$square = fn($x) => $x * $x;\n\n// Capturing variables (use keyword)\n$multiplier = 3;\n$multiply = function($x) use ($multiplier) {\n  return $x * $multiplier;\n};\n$multiply(5);  // 15\n\n// Capture by reference\n$count = 0;\n$increment = function() use (&$count) {\n  $count++;\n};\n$increment();  // $count is now 1\n\n// Arrow functions auto-capture by value\n$factor = 2;\n$double = fn($x) => $x * $factor;"},{name:"Rust",lang:"rust",code:'// Closures\nlet add = |a, b| a + b;\nlet square = |x: i32| -> i32 { x * x };\n\n// Capturing by reference (borrow)\nlet name = String::from("hello");\nlet greet = || println!("{}", name);  // borrows name\n\n// Capturing by value (move)\nlet name = String::from("hello");\nlet greet = move || println!("{}", name);\n// name is no longer accessible here\n\n// Closure types\n// Fn: borrows immutably\n// FnMut: borrows mutably\n// FnOnce: takes ownership\n\nfn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n  f(x)\n}\n\n// Mutable closure\nlet mut count = 0;\nlet mut increment = || {\n  count += 1;\n  count\n};'},{name:"Go",lang:"go",code:"// Anonymous functions\nadd := func(a, b int) int { return a + b }\nadd(1, 2)  // 3\n\n// Closures (capture by reference)\nfunc counter() func() int {\n  count := 0\n  return func() int {\n      count++\n      return count\n  }\n}\n\nc := counter()\nc()  // 1\nc()  // 2\n\n// Immediately invoked\nresult := func(x int) int { return x * 2 }(5)\n\n// Closures in goroutines\nfor i := 0; i < 3; i++ {\n  go func(n int) {\n      fmt.Println(n)  // Pass i as parameter\n  }(i)\n}"},{name:"Python",lang:"python",code:'# Lambda functions\nadd = lambda a, b: a + b\nsquare = lambda x: x * x\n\n# Closures\ndef counter():\n  count = 0\n  def increment():\n      nonlocal count\n      count += 1\n      return count\n  return increment\n\nc = counter()\nc()  # 1\nc()  # 2\n\n# functools.partial (partial application)\nfrom functools import partial\n\ndef multiply(a, b):\n  return a * b\n\ndouble = partial(multiply, 2)\ndouble(5)  # 10\n\n# Decorators (higher-order functions)\ndef log_calls(func):\n  def wrapper(*args, **kwargs):\n      print(f"Calling {func.__name__}")\n      return func(*args, **kwargs)\n  return wrapper\n\n@log_calls\ndef greet(name):\n  return f"Hello, {name}"'},{name:"Zig",lang:"zig",code:"// Zig has limited closure support\n// Use function pointers and context\n\n// Function pointer\nconst Op = fn (i32, i32) i32;\n\nfn add(a: i32, b: i32) i32 {\n  return a + b;\n}\n\nconst op: Op = add;\nconst result = op(1, 2);  // 3\n\n// Closure-like with struct\nfn makeMultiplier(factor: i32) fn (i32) i32 {\n  const Closure = struct {\n      fn multiply(x: i32) i32 {\n          // Note: can't capture runtime values\n          return x * 2;\n      }\n  };\n  return Closure.multiply;\n}\n\n// Comptime closures\nfn applyComptime(\n  comptime f: fn (i32) i32,\n  value: i32\n) i32 {\n  return f(value);\n}"},{name:"C#",lang:"csharp",code:'// Lambda expressions\nFunc<int, int, int> add = (a, b) => a + b;\nFunc<int, int> square = x => x * x;\n\n// Multi-statement lambda\nFunc<int, string> describe = x =>\n{\n  if (x > 0) return "positive";\n  if (x < 0) return "negative";\n  return "zero";\n};\n\n// Closures (capture by reference)\nint count = 0;\nAction increment = () => count++;\nincrement();  // count is 1\n\n// Action (void return)\nAction<string> greet = name =>\n  Console.WriteLine($"Hello, {name}");\n\n// Predicate\nPredicate<int> isEven = x => x % 2 == 0;\n\n// Local functions (C# 7+)\nint Multiply(int a, int b) => a * b;\n\n// Static lambda (no capture, C# 9+)\nFunc<int, int> doubleIt = static x => x * 2;'},{name:"C++",lang:"cpp",code:"// Lambda expressions\nauto add = [](int a, int b) { return a + b; };\nauto square = [](int x) { return x * x; };\n\n// Capture by value [=]\nint factor = 3;\nauto multiply = [factor](int x) { return x * factor; };\n\n// Capture by reference [&]\nint count = 0;\nauto increment = [&count]() { count++; };\n\n// Mixed capture\nauto func = [=, &count](int x) {\n  count++;\n  return x * factor;\n};\n\n// Mutable (modify captured value copy)\nauto counter = [count = 0]() mutable {\n  return ++count;\n};\n\n// Generic lambda (C++14)\nauto identity = [](auto x) { return x; };\n\n// Immediately invoked\nauto result = [](int x) { return x * 2; }(5);"},{name:"C",lang:"c",code:"// C has no closures or lambdas\n// Use function pointers\n\ntypedef int (*Operation)(int, int);\n\nint add(int a, int b) { return a + b; }\nint multiply(int a, int b) { return a * b; }\n\n// Pass function as argument\nint apply(Operation op, int a, int b) {\n  return op(a, b);\n}\n\nint result = apply(add, 3, 4);       // 7\nint result2 = apply(multiply, 3, 4); // 12\n\n// Simulate closure with struct + function pointer\ntypedef struct {\n  int factor;\n  int (*multiply)(int, int);\n} Multiplier;\n\nint mult(int x, int factor) {\n  return x * factor;\n}\n// Must pass context manually"},{name:"Java",lang:"java",code:'// Lambda expressions (Java 8+)\nFunction<Integer, Integer> square = x -> x * x;\nBiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;\n\n// Multi-statement\nFunction<Integer, String> describe = x -> {\n  if (x > 0) return "positive";\n  if (x < 0) return "negative";\n  return "zero";\n};\n\n// Effectively final (captures must be final)\nint factor = 3;\nFunction<Integer, Integer> multiply = x -> x * factor;\n// factor = 4;  // Error! Must be effectively final\n\n// Method references\nFunction<String, Integer> len = String::length;\nConsumer<String> printer = System.out::println;\n\n// Functional interfaces\nPredicate<Integer> isEven = x -> x % 2 == 0;\nSupplier<String> greeting = () -> "Hello";\nConsumer<String> logger = msg -> System.out.println(msg);\nRunnable task = () -> System.out.println("Running");'},{name:"Ruby",lang:"ruby",code:'# Blocks\n[1, 2, 3].each { |n| puts n }\n[1, 2, 3].each do |n|\nputs n\nend\n\n# Procs\nsquare = Proc.new { |x| x * x }\nsquare.call(5)  # 25\nsquare.(5)      # 25\nsquare[5]       # 25\n\n# Lambdas\nadd = ->(a, b) { a + b }\nadd.call(1, 2)  # 3\n\n# Lambda vs Proc differences\n# Lambda checks arity, Proc doesn\'t\n# Lambda return exits lambda, Proc return exits method\n\n# Closures (capture by reference)\ndef counter\ncount = 0\nincrement = -> { count += 1; count }\nget_count = -> { count }\n[increment, get_count]\nend\n\ninc, get = counter\ninc.call  # 1\ninc.call  # 2\nget.call  # 2\n\n# Method objects\nmethod_obj = method(:puts)\nmethod_obj.call("hello")'},{name:"Swift",lang:"swift",code:'// Closures\nlet add = { (a: Int, b: Int) -> Int in a + b }\nlet square: (Int) -> Int = { $0 * $0 }\n\n// Trailing closure syntax\nlet sorted = numbers.sorted { $0 < $1 }\n\n// Capturing values\nfunc makeCounter() -> () -> Int {\n  var count = 0\n  return {\n      count += 1\n      return count\n  }\n}\n\nlet counter = makeCounter()\ncounter()  // 1\ncounter()  // 2\n\n// Escaping closures\nfunc fetchData(completion: @escaping (String) -> Void) {\n  DispatchQueue.global().async {\n      completion("data")\n  }\n}\n\n// Autoclosure\nfunc assert(_ condition: @autoclosure () -> Bool) {\n  if !condition() { print("Failed") }\n}\nassert(2 + 2 == 4)  // Expression auto-wrapped'}]}),"\n",(0,a.jsx)(e.h2,{id:"higher-order-functions",children:"Higher-Order Functions"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Map, filter, reduce\nconst nums = [1, 2, 3, 4, 5];\n\nnums.map(x => x * 2);          // [2, 4, 6, 8, 10]\nnums.filter(x => x % 2 === 0); // [2, 4]\nnums.reduce((acc, x) => acc + x, 0); // 15\n\n// Function composition\nconst compose = (f, g) => x => f(g(x));\nconst double = x => x * 2;\nconst addOne = x => x + 1;\nconst doubleThenAdd = compose(addOne, double);\ndoubleThenAdd(3);  // 7\n\n// Currying\nconst curry = fn => a => b => fn(a, b);\nconst add = curry((a, b) => a + b);\nconst add5 = add(5);\nadd5(3);  // 8"},{name:"PHP",lang:"php",code:"<?php\n$nums = [1, 2, 3, 4, 5];\n\narray_map(fn($x) => $x * 2, $nums);\narray_filter($nums, fn($x) => $x % 2 === 0);\narray_reduce($nums, fn($acc, $x) => $acc + $x, 0);\n\n// Function composition\nfunction compose(callable $f, callable $g): Closure {\n  return fn($x) => $f($g($x));\n}\n\n// Currying\nfunction curry(callable $fn): Closure {\n  return fn($a) => fn($b) => $fn($a, $b);\n}\n\n$add = curry(fn($a, $b) => $a + $b);\n$add5 = $add(5);\n$add5(3);  // 8"},{name:"Rust",lang:"rust",code:"let nums = vec![1, 2, 3, 4, 5];\n\n// Iterator methods\nlet doubled: Vec<i32> = nums.iter()\n  .map(|x| x * 2).collect();\nlet evens: Vec<&i32> = nums.iter()\n  .filter(|x| *x % 2 == 0).collect();\nlet sum: i32 = nums.iter()\n  .fold(0, |acc, x| acc + x);\n\n// Chaining\nlet result: Vec<i32> = nums.iter()\n  .filter(|x| *x % 2 == 0)\n  .map(|x| x * 3)\n  .collect();\n\n// Accepting closures as parameters\nfn apply_twice<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n  f(f(x))\n}\n\nlet double = |x| x * 2;\napply_twice(double, 3);  // 12"},{name:"Go",lang:"go",code:"// Go doesn't have built-in map/filter/reduce\n// Manual higher-order functions\n\nfunc Map(slice []int, f func(int) int) []int {\n  result := make([]int, len(slice))\n  for i, v := range slice {\n      result[i] = f(v)\n  }\n  return result\n}\n\nfunc Filter(slice []int, f func(int) bool) []int {\n  var result []int\n  for _, v := range slice {\n      if f(v) {\n          result = append(result, v)\n      }\n  }\n  return result\n}\n\nnums := []int{1, 2, 3, 4, 5}\ndoubled := Map(nums, func(x int) int { return x * 2 })\nevens := Filter(nums, func(x int) bool { return x%2 == 0 })"},{name:"Python",lang:"python",code:"nums = [1, 2, 3, 4, 5]\n\n# Built-in higher-order functions\nlist(map(lambda x: x * 2, nums))\nlist(filter(lambda x: x % 2 == 0, nums))\n\nfrom functools import reduce\nreduce(lambda acc, x: acc + x, nums, 0)\n\n# Prefer comprehensions\n[x * 2 for x in nums]\n[x for x in nums if x % 2 == 0]\n\n# Function as argument\ndef apply_twice(f, x):\n  return f(f(x))\n\napply_twice(lambda x: x * 2, 3)  # 12\n\n# Composition with functools\nfrom functools import reduce\ndef compose(*funcs):\n  return reduce(lambda f, g: lambda x: f(g(x)), funcs)"},{name:"Zig",lang:"zig",code:"// Higher-order with function pointers\nfn map(arr: []const i32, f: fn(i32) i32, out: []i32) void {\n  for (arr, 0..) |val, i| {\n      out[i] = f(val);\n  }\n}\n\nfn double(x: i32) i32 {\n  return x * 2;\n}\n\nvar input = [_]i32{ 1, 2, 3, 4, 5 };\nvar output: [5]i32 = undefined;\nmap(&input, double, &output);\n\n// Inline for + comptime\ninline for (.{ add, subtract, multiply }) |op| {\n  // Apply each operation\n}"},{name:"C#",lang:"csharp",code:"var nums = new[] { 1, 2, 3, 4, 5 };\n\n// LINQ methods\nnums.Select(x => x * 2);\nnums.Where(x => x % 2 == 0);\nnums.Aggregate(0, (acc, x) => acc + x);\n\n// Chaining\nvar result = nums\n  .Where(x => x % 2 == 0)\n  .Select(x => x * 3)\n  .ToArray();\n\n// Function as parameter\nint ApplyTwice(Func<int, int> f, int x) => f(f(x));\nApplyTwice(x => x * 2, 3);  // 12"},{name:"C++",lang:"cpp",code:"#include <algorithm>\n#include <numeric>\n\nstd::vector<int> nums = {1, 2, 3, 4, 5};\n\n// transform (map)\nstd::vector<int> doubled;\nstd::transform(nums.begin(), nums.end(),\n  std::back_inserter(doubled),\n  [](int x) { return x * 2; });\n\n// accumulate (reduce)\nint sum = std::accumulate(nums.begin(), nums.end(), 0);\n\n// Ranges (C++20)\n#include <ranges>\nauto result = nums\n  | std::views::filter([](int x) { return x % 2 == 0; })\n  | std::views::transform([](int x) { return x * 3; });\n\n// Function as parameter\ntemplate<typename F>\nint applyTwice(F f, int x) {\n  return f(f(x));\n}"},{name:"C",lang:"c",code:"// Function pointers as arguments\nvoid map(int* in, int* out, int n, int (*f)(int)) {\n  for (int i = 0; i < n; i++) {\n      out[i] = f(in[i]);\n  }\n}\n\nint double_val(int x) { return x * 2; }\n\nint arr[] = {1, 2, 3, 4, 5};\nint result[5];\nmap(arr, result, 5, double_val);\n\n// qsort with comparator\nint compare_desc(const void* a, const void* b) {\n  return *(int*)b - *(int*)a;\n}\nqsort(arr, 5, sizeof(int), compare_desc);"},{name:"Java",lang:"java",code:"var nums = List.of(1, 2, 3, 4, 5);\n\n// Stream API\nnums.stream().map(x -> x * 2).toList();\nnums.stream().filter(x -> x % 2 == 0).toList();\nnums.stream().reduce(0, Integer::sum);\n\n// Chaining\nvar result = nums.stream()\n  .filter(x -> x % 2 == 0)\n  .map(x -> x * 3)\n  .toList();\n\n// Function composition\nFunction<Integer, Integer> doubleIt = x -> x * 2;\nFunction<Integer, Integer> addOne = x -> x + 1;\nvar doubleThenAdd = doubleIt.andThen(addOne);\ndoubleThenAdd.apply(3);  // 7"},{name:"Ruby",lang:"ruby",code:'nums = [1, 2, 3, 4, 5]\n\nnums.map { |x| x * 2 }\nnums.select { |x| x.even? }\nnums.reduce(0) { |acc, x| acc + x }\n\n# Chaining\nnums.select(&:even?).map { |x| x * 3 }\n\n# Symbol to proc\nnums.map(&:to_s)  # ["1", "2", "3", "4", "5"]\n\n# Yielding to blocks\ndef apply_twice(x)\nyield(yield(x))\nend\n\napply_twice(3) { |x| x * 2 }  # 12'},{name:"Swift",lang:"swift",code:"let nums = [1, 2, 3, 4, 5]\n\nnums.map { $0 * 2 }\nnums.filter { $0 % 2 == 0 }\nnums.reduce(0) { $0 + $1 }\nnums.reduce(0, +)  // Shorthand\n\n// Chaining\nlet result = nums\n  .filter { $0 % 2 == 0 }\n  .map { $0 * 3 }\n\n// Function as parameter\nfunc applyTwice(_ f: (Int) -> Int, _ x: Int) -> Int {\n  f(f(x))\n}\n\napplyTwice({ $0 * 2 }, 3)  // 12"}]}),"\n",(0,a.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Capture semantics"})," -- C++ uses ",(0,a.jsx)(e.code,{children:"[=]"})," for by-value and ",(0,a.jsx)(e.code,{children:"[&]"})," for by-reference capture; PHP uses ",(0,a.jsx)(e.code,{children:"use ($x)"})," for by-value and ",(0,a.jsx)(e.code,{children:"use (&$x)"})," for by-reference. Rust distinguishes ",(0,a.jsx)(e.code,{children:"Fn"})," (immutable borrow), ",(0,a.jsx)(e.code,{children:"FnMut"})," (mutable borrow), and ",(0,a.jsx)(e.code,{children:"FnOnce"})," (takes ownership). For example, ",(0,a.jsx)(e.code,{children:"let mut count = 0; let inc = || { count += 1; count };"})," in Rust requires ",(0,a.jsx)(e.code,{children:"FnMut"})," because the closure mutates ",(0,a.jsx)(e.code,{children:"count"}),". Choose explicit capture when you need to control lifetime and mutability; Rust's traits enforce this at compile time and prevent accidental moves or borrow conflicts."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Closure types in Rust"})," -- Rust's ",(0,a.jsx)(e.code,{children:"Fn"}),", ",(0,a.jsx)(e.code,{children:"FnMut"}),", and ",(0,a.jsx)(e.code,{children:"FnOnce"})," traits encode capture semantics at compile time. A closure that only reads captured variables implements ",(0,a.jsx)(e.code,{children:"Fn"}),"; one that mutates them implements ",(0,a.jsx)(e.code,{children:"FnMut"}),"; one that consumes them (e.g. ",(0,a.jsx)(e.code,{children:"move"}),") implements ",(0,a.jsx)(e.code,{children:"FnOnce"}),". When accepting closures as parameters, use ",(0,a.jsx)(e.code,{children:"impl Fn(i32) -> i32"})," or ",(0,a.jsx)(e.code,{children:"F: Fn(i32) -> i32"})," to constrain what the caller can pass. This matters because ",(0,a.jsx)(e.code,{children:"FnOnce"})," can only be called once, so it can't be used in a loop. If you write closures that capture state, understand which trait your closure implements to avoid ownership errors."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Lambda limitations in C"})," -- C has no closures or lambdas; only function pointers (",(0,a.jsx)(e.code,{children:"int (*op)(int, int)"}),'). To simulate "closures," you must pass a context struct manually: ',(0,a.jsx)(e.code,{children:"typedef struct { int factor; } Context; int apply(int x, Context* ctx) { return x * ctx->factor; }"}),". This is verbose and error-prone. For callback-heavy code in C, consider passing a ",(0,a.jsx)(e.code,{children:"void*"})," context alongside the function pointer; for new projects, prefer languages with native closures (Go, Rust, C++) if you need capture semantics."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Java's effectively final"})," -- Java lambdas can only capture variables that are final or effectively final (never reassigned). For example, ",(0,a.jsx)(e.code,{children:"int factor = 3; Function<Integer, Integer> mul = x -> x * factor;"})," works, but ",(0,a.jsx)(e.code,{children:"factor = 4;"})," afterward would be a compile error. This prevents mutation of captured state and simplifies the model but limits closures that need to maintain mutable state. For immutable or stateless captures, Java lambdas are fine; for mutable state, use a single-element array or ",(0,a.jsx)(e.code,{children:"AtomicInteger"})," as a workaround, or prefer a language with full closure capture (e.g. JavaScript, C#)."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Higher-order functions and built-ins"})," -- JavaScript, Python, Ruby, C#, and Swift have built-in ",(0,a.jsx)(e.code,{children:"map"}),", ",(0,a.jsx)(e.code,{children:"filter"}),", ",(0,a.jsx)(e.code,{children:"reduce"})," (or equivalents). Go does not; you must implement them or use a library. C uses ",(0,a.jsx)(e.code,{children:"qsort"})," with a comparator function pointer. Rust uses iterator methods (",(0,a.jsx)(e.code,{children:".map()"}),", ",(0,a.jsx)(e.code,{children:".filter()"}),", ",(0,a.jsx)(e.code,{children:".fold()"}),"). Zig uses function pointers and manual loops. If you rely heavily on functional pipelines, choose a language with rich iterator/collection APIs; for minimal abstraction, Go or C style is acceptable."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"When to choose which"})," -- For web and event-driven code, JavaScript closures are idiomatic. For systems with safety and performance, Rust closures with ",(0,a.jsx)(e.code,{children:"Fn"}),"/",(0,a.jsx)(e.code,{children:"FnMut"}),"/",(0,a.jsx)(e.code,{children:"FnOnce"}),' balance expressiveness and control. For enterprise Java, lambdas and streams work well within the "effectively final" constraint. For C/C++/Zig, function pointers are the norm; use closures only when you have C++ or Rust available. Match closure support to your use case: callback-heavy vs. predominantly procedural vs. functional pipelines.']}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);