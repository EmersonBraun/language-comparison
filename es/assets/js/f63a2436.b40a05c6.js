"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[778],{7145(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"regex","title":"Regex","description":"Regular expressions and pattern matching compared across 12 programming languages","source":"@site/docs/regex.md","sourceDirName":".","slug":"/regex","permalink":"/language-comparison/es/docs/regex","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/regex.md","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17,"description":"Regular expressions and pattern matching compared across 12 programming languages","keywords":["regex","regular expressions","pattern matching","search","replace"]},"sidebar":"tutorialSidebar","previous":{"title":"Generics & Templates","permalink":"/language-comparison/es/docs/generics-templates"},"next":{"title":"Dates","permalink":"/language-comparison/es/docs/dates"}}');var r=t(4848),l=t(8453),o=t(2531);const s={sidebar_position:17,description:"Regular expressions and pattern matching compared across 12 programming languages",keywords:["regex","regular expressions","pattern matching","search","replace"]},i="Regex",c={},h=[{value:"Basic Pattern Matching",id:"basic-pattern-matching",level:2},{value:"Replace Operations",id:"replace-operations",level:2},{value:"Capture Groups",id:"capture-groups",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"regex",children:"Regex"})}),"\n",(0,r.jsx)(n.p,{children:"Regular expressions (regex) are powerful tools for pattern matching and text manipulation. Here's how different languages handle regex operations."}),"\n","\n",(0,r.jsx)(n.h2,{id:"basic-pattern-matching",children:"Basic Pattern Matching"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Create regex\nconst pattern = /hello/i;  // literal with flag\nconst pattern2 = new RegExp("hello", "i");  // constructor\n\n// Test match\npattern.test("Hello World");  // true\n\n// Find match\n"Hello World".match(/hello/i);  // ["Hello"]\n"Hello World".search(/hello/i);  // 0 (index)\n\n// Find all matches\n"hello hello".match(/hello/g);  // ["hello", "hello"]'},{name:"PHP",lang:"php",code:'<?php\n// Create regex\n$pattern = "/hello/i";\n\n// Test match\npreg_match($pattern, "Hello World");  // 1 (true)\n\n// Find match\npreg_match($pattern, "Hello World", $matches);  // $matches[0] = "Hello"\n\n// Find all matches\npreg_match_all("/hello/i", "hello hello", $matches);  // $matches[0] = ["hello", "hello"]'},{name:"Rust",lang:"rust",code:'use regex::Regex;\n\n// Create regex\nlet re = Regex::new(r"hello")?;\nlet re_case = Regex::new(r"(?i)hello")?;  // case insensitive\n\n// Test match\nre.is_match("Hello World");  // false (case sensitive)\nre_case.is_match("Hello World");  // true\n\n// Find match\nre.find("Hello World");  // Some(Match)\nif let Some(mat) = re.find("Hello World") {\n  println!("{}", mat.as_str());  // "hello"\n}\n\n// Find all matches\nfor mat in re.find_iter("hello hello") {\n  println!("{}", mat.as_str());\n}'},{name:"Go",lang:"go",code:'import (\n  "regexp"\n)\n\n// Create regex\nre, _ := regexp.Compile("hello")\nreCase, _ := regexp.Compile("(?i)hello")  // case insensitive\n\n// Test match\nre.MatchString("Hello World")  // false\nreCase.MatchString("Hello World")  // true\n\n// Find match\nre.FindString("Hello World")  // "hello" or ""\n\n// Find all matches\nre.FindAllString("hello hello", -1)  // ["hello", "hello"]\n\n// Find with index\nre.FindStringIndex("Hello World")  // [0, 5]'},{name:"Python",lang:"python",code:'import re\n\n# Create regex\npattern = re.compile(r"hello", re.IGNORECASE)\n\n# Test match\npattern.search("Hello World")  # Match object or None\nbool(pattern.search("Hello World"))  # True\n\n# Find match\npattern.search("Hello World").group()  # "Hello"\npattern.findall("hello hello")  # ["hello", "hello"]\n\n# Find with index\nmatch = pattern.search("Hello World")\nif match:\n  match.start()  # 0\n  match.end()    # 5\n  match.span()   # (0, 5)'},{name:"Zig",lang:"zig",code:'// Zig doesn\'t have built-in regex\n// Use external library like zig-regex or pcre\n\n// Example with external library\nconst std = @import("std");\n// const regex = @import("regex");\n\n// Manual pattern matching for simple cases\nconst str = "Hello World";\nconst pattern = "hello";\n// Use std.mem.indexOfPos for simple cases'},{name:"C#",lang:"csharp",code:'using System.Text.RegularExpressions;\n\n// Create regex\nRegex pattern = new Regex("hello", RegexOptions.IgnoreCase);\n\n// Test match\npattern.IsMatch("Hello World");  // true\n\n// Find match\nMatch match = pattern.Match("Hello World");\nif (match.Success) {\n  string result = match.Value;  // "Hello"\n}\n\n// Find all matches\nMatchCollection matches = pattern.Matches("hello hello");\nforeach (Match m in matches) {\n  Console.WriteLine(m.Value);\n}'},{name:"C++",lang:"cpp",code:'#include <regex>\n#include <string>\n\n// Create regex\nstd::regex pattern("hello", std::regex_constants::icase);\n\n// Test match\nstd::regex_search("Hello World", pattern);  // true\n\n// Find match\nstd::smatch match;\nif (std::regex_search("Hello World", match, pattern)) {\n  std::string result = match.str();  // "Hello"\n}\n\n// Find all matches\nstd::string text = "hello hello";\nstd::sregex_iterator iter(text.begin(), text.end(), pattern);\nstd::sregex_iterator end;\nfor (; iter != end; ++iter) {\n  std::cout << iter->str() << std::endl;\n}'},{name:"C",lang:"c",code:'// C doesn\'t have built-in regex\n// Use POSIX regex (regex.h) or PCRE library\n\n#include <regex.h>\n\nregex_t regex;\nint reti = regcomp(&regex, "hello", REG_ICASE | REG_EXTENDED);\n\nif (reti) {\n  // error\n}\n\n// Test match\nreti = regexec(&regex, "Hello World", 0, NULL, 0);\nif (!reti) {\n  // match found\n}\n\nregfree(&regex);  // free'},{name:"Java",lang:"java",code:'import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\n// Create regex\nPattern pattern = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);\n\n// Test match\npattern.matcher("Hello World").find();  // true\n\n// Find match\nMatcher matcher = pattern.matcher("Hello World");\nif (matcher.find()) {\n  String result = matcher.group();  // "Hello"\n}\n\n// Find all matches\nMatcher matcher = pattern.matcher("hello hello");\nwhile (matcher.find()) {\n  System.out.println(matcher.group());\n}'},{name:"Ruby",lang:"ruby",code:'# Create regex\npattern = /hello/i\n\n# Test match\npattern =~ "Hello World"  # 0 (index) or nil\n"Hello World" =~ pattern  # 0\n\n# Find match\n"Hello World".match(pattern)  # MatchData object\n"Hello World"[pattern]  # "Hello"\n\n# Find all matches\n"hello hello".scan(pattern)  # ["hello", "hello"]\n\n# Match with groups\n/(\\w+) (\\w+)/.match("Hello World")\n# $1 = "Hello", $2 = "World"'},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Create regex\nlet pattern = try NSRegularExpression(pattern: "hello", options: .caseInsensitive)\n\n// Test match\nlet range = NSRange(location: 0, length: str.utf16.count)\npattern.numberOfMatches(in: str, range: range) > 0  // true\n\n// Find match\nif let match = pattern.firstMatch(in: str, range: range) {\n  let result = (str as NSString).substring(with: match.range)\n}\n\n// Find all matches\nlet matches = pattern.matches(in: str, range: range)\nfor match in matches {\n  let result = (str as NSString).substring(with: match.range)\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"replace-operations",children:"Replace Operations"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Replace first match\n"Hello World".replace(/hello/i, "Hi");  // "Hi World"\n\n// Replace all matches\n"hello hello".replace(/hello/g, "Hi");  // "Hi Hi"\n\n// Replace with function\n"hello world".replace(/\\w+/g, (match) => match.toUpperCase());  // "HELLO WORLD"'},{name:"PHP",lang:"php",code:'<?php\n// Replace first match\npreg_replace("/hello/i", "Hi", "Hello World");  // "Hi World"\n\n// Replace all matches (default behavior)\npreg_replace("/hello/i", "Hi", "hello hello");  // "Hi Hi"\n\n// Replace with callback\npreg_replace_callback("/\\w+/", function($matches) {\n  return strtoupper($matches[0]);\n}, "hello world");  // "HELLO WORLD"'},{name:"Rust",lang:"rust",code:'use regex::Regex;\n\nlet re = Regex::new(r"hello")?;\n\n// Replace all matches\nre.replace_all("hello hello", "Hi");  // "Hi Hi"\n\n// Replace with function\nre.replace_all("hello world", |caps: &regex::Captures| {\n  caps[0].to_uppercase()\n});  // "HELLO WORLD"'},{name:"Go",lang:"go",code:'import "regexp"\n\nre, _ := regexp.Compile("hello")\n\n// Replace all matches\nre.ReplaceAllString("hello hello", "Hi")  // "Hi Hi"\n\n// Replace with function\nre.ReplaceAllStringFunc("hello world", func(s string) string {\n  return strings.ToUpper(s)\n})  // "HELLO WORLD"'},{name:"Python",lang:"python",code:'import re\n\npattern = re.compile(r"hello")\n\n# Replace all matches\npattern.sub("Hi", "hello hello")  # "Hi Hi"\nre.sub(r"hello", "Hi", "hello hello")  # "Hi Hi"\n\n# Replace with function\npattern.sub(lambda m: m.group().upper(), "hello world")  # "HELLO WORLD"\n\n# Replace with count\npattern.sub("Hi", "hello hello", count=1)  # "Hi hello"'},{name:"Zig",lang:"zig",code:'// Use external regex library\n// Manual replacement for simple cases\n// const std = @import("std");\n// Use std.mem.replace for simple string replacement'},{name:"C#",lang:"csharp",code:'using System.Text.RegularExpressions;\n\nRegex pattern = new Regex("hello");\n\n// Replace all matches\npattern.Replace("hello hello", "Hi");  // "Hi Hi"\n\n// Replace with function\npattern.Replace("hello world", match => {\n  return match.Value.ToUpper();\n});  // "HELLO WORLD"'},{name:"C++",lang:"cpp",code:'#include <regex>\n\nstd::regex pattern("hello");\n\n// Replace all matches\nstd::string result = std::regex_replace(\n  "hello hello", \n  pattern, \n  "Hi"\n);  // "Hi Hi"\n\n// Replace with format\nstd::regex_replace("hello world", pattern, \n  [](const std::smatch& m) {\n      std::string s = m.str();\n      std::transform(s.begin(), s.end(), s.begin(), ::toupper);\n      return s;\n  }\n);'},{name:"C",lang:"c",code:"// Use POSIX regex or PCRE library\n// Manual implementation or use library functions\n// regcomp, regexec, regfree for matching\n// Manual string replacement for simple cases"},{name:"Java",lang:"java",code:'import java.util.regex.Pattern;\n\nPattern pattern = Pattern.compile("hello");\n\n// Replace all matches\npattern.matcher("hello hello").replaceAll("Hi");  // "Hi Hi"\n\n// Replace first match\npattern.matcher("hello hello").replaceFirst("Hi");  // "Hi hello"\n\n// Replace with function (Java 9+)\npattern.matcher("hello world").replaceAll(mr -> \n  mr.group().toUpperCase()\n);  // "HELLO WORLD"'},{name:"Ruby",lang:"ruby",code:'pattern = /hello/\n\n# Replace all matches\n"hello hello".gsub(pattern, "Hi")  # "Hi Hi"\n\n# Replace first match\n"hello hello".sub(pattern, "Hi")  # "Hi hello"\n\n# Replace with block\n"hello world".gsub(/\\w+/) { |match| match.upcase }  # "HELLO WORLD"'},{name:"Swift",lang:"swift",code:'import Foundation\n\nlet pattern = try NSRegularExpression(pattern: "hello")\n\n// Replace all matches\nlet range = NSRange(location: 0, length: str.utf16.count)\nlet result = pattern.stringByReplacingMatches(\n  in: str,\n  range: range,\n  withTemplate: "Hi"\n)  // "Hi Hi"\n\n// Replace with function (manual implementation)\nvar result = str\nlet matches = pattern.matches(in: str, range: range)\nfor match in matches.reversed() {\n  let replacement = "Hi"\n  result = (result as NSString).replacingCharacters(\n      in: match.range, \n      with: replacement\n  )\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"capture-groups",children:"Capture Groups"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Capture groups\nconst match = "John Doe".match(/(\\w+) (\\w+)/);\n// match[0] = "John Doe"\n// match[1] = "John"\n// match[2] = "Doe"\n\n// Named groups (ES2018+)\nconst named = /(?<first>\\w+) (?<last>\\w+)/.exec("John Doe");\nnamed.groups.first;  // "John"\nnamed.groups.last;   // "Doe"\n\n// Use in replace\n"John Doe".replace(/(\\w+) (\\w+)/, "$2, $1");  // "Doe, John"'},{name:"PHP",lang:"php",code:'<?php\n// Capture groups\npreg_match("/(\\w+) (\\w+)/", "John Doe", $matches);\n// $matches[0] = "John Doe"\n// $matches[1] = "John"\n// $matches[2] = "Doe"\n\n// Named groups\npreg_match("/(?<first>\\w+) (?<last>\\w+)/", "John Doe", $matches);\n$matches[\'first\'];  // "John"\n$matches[\'last\'];   // "Doe"\n\n// Use in replace\npreg_replace("/(\\w+) (\\w+)/", "$2, $1", "John Doe");  // "Doe, John"'},{name:"Rust",lang:"rust",code:'use regex::Regex;\n\nlet re = Regex::new(r"(\\w+) (\\w+)")?;\n\nif let Some(caps) = re.captures("John Doe") {\n  let full = &caps[0];  // "John Doe"\n  let first = &caps[1];  // "John"\n  let last = &caps[2];   // "Doe"\n}\n\n// Named groups\nlet re = Regex::new(r"(?<first>\\w+) (?<last>\\w+)")?;\nif let Some(caps) = re.captures("John Doe") {\n  let first = &caps["first"];  // "John"\n  let last = &caps["last"];    // "Doe"\n}\n\n// Use in replace\nre.replace("John Doe", "$last, $first");  // "Doe, John"'},{name:"Go",lang:"go",code:'import "regexp"\n\nre := regexp.MustCompile("(\\w+) (\\w+)")\n\n// Capture groups\nmatches := re.FindStringSubmatch("John Doe")\n// matches[0] = "John Doe"\n// matches[1] = "John"\n// matches[2] = "Doe"\n\n// Named groups (Go 1.11+)\nre = regexp.MustCompile("(?P<first>\\w+) (?P<last>\\w+)")\nmatches := re.FindStringSubmatch("John Doe")\nnames := re.SubexpNames()\n// Access by index or use map\n\n// Use in replace\nre.ReplaceAllString("John Doe", "$2, $1")  // "Doe, John"'},{name:"Python",lang:"python",code:'import re\n\npattern = re.compile(r"(\\w+) (\\w+)")\n\n# Capture groups\nmatch = pattern.search("John Doe")\nmatch.group(0)  # "John Doe"\nmatch.group(1)  # "John"\nmatch.group(2)  # "Doe"\nmatch.groups()  # ("John", "Doe")\n\n# Named groups\npattern = re.compile(r"(?P<first>\\w+) (?P<last>\\w+)")\nmatch = pattern.search("John Doe")\nmatch.group("first")  # "John"\nmatch.group("last")   # "Doe"\nmatch.groupdict()     # {"first": "John", "last": "Doe"}\n\n# Use in replace\npattern.sub(r"\\2, \\1", "John Doe")  # "Doe, John"'},{name:"Zig",lang:"zig",code:"// Use external regex library\n// Capture groups supported by most regex libraries"},{name:"C#",lang:"csharp",code:'using System.Text.RegularExpressions;\n\nRegex pattern = new Regex("(\\w+) (\\w+)");\n\nMatch match = pattern.Match("John Doe");\nif (match.Success) {\n  string full = match.Groups[0].Value;  // "John Doe"\n  string first = match.Groups[1].Value;  // "John"\n  string last = match.Groups[2].Value;  // "Doe"\n}\n\n// Named groups\nRegex named = new Regex("(?<first>\\w+) (?<last>\\w+)");\nMatch m = named.Match("John Doe");\nstring first = m.Groups["first"].Value;  // "John"\nstring last = m.Groups["last"].Value;   // "Doe"\n\n// Use in replace\npattern.Replace("John Doe", "$2, $1");  // "Doe, John"'},{name:"C++",lang:"cpp",code:'#include <regex>\n\nstd::regex pattern("(\\w+) (\\w+)");\n\nstd::smatch match;\nif (std::regex_search("John Doe", match, pattern)) {\n  std::string full = match[0];   // "John Doe"\n  std::string first = match[1];   // "John"\n  std::string last = match[2];   // "Doe"\n}\n\n// Use in replace\nstd::regex_replace("John Doe", pattern, "$2, $1");  // "Doe, John"'},{name:"C",lang:"c",code:'// Use POSIX regex with regmatch_t\n#include <regex.h>\n\nregex_t regex;\nregmatch_t matches[3];  // 0=full, 1=first group, 2=second group\n\nregcomp(&regex, "\\(\\w\\+\\) \\(\\w\\+\\)", REG_EXTENDED);\nregexec(&regex, "John Doe", 3, matches, 0);\n\n// Access matches[0].rm_so, matches[0].rm_eo for positions\n// Extract substring manually'},{name:"Java",lang:"java",code:'import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\nPattern pattern = Pattern.compile("(\\w+) (\\w+)");\nMatcher matcher = pattern.matcher("John Doe");\n\nif (matcher.find()) {\n  String full = matcher.group(0);   // "John Doe"\n  String first = matcher.group(1);  // "John"\n  String last = matcher.group(2);   // "Doe"\n}\n\n// Named groups (Java 7+)\nPattern named = Pattern.compile("(?<first>\\w+) (?<last>\\w+)");\nMatcher m = named.matcher("John Doe");\nif (m.find()) {\n  String first = m.group("first");  // "John"\n  String last = m.group("last");    // "Doe"\n}\n\n// Use in replace\nmatcher.replaceAll("$2, $1");  // "Doe, John"'},{name:"Ruby",lang:"ruby",code:'pattern = /(\\w+) (\\w+)/\n\n# Capture groups\nmatch = pattern.match("John Doe")\nmatch[0]  # "John Doe"\nmatch[1]  # "John"\nmatch[2]  # "Doe"\n\n# Named groups\npattern = /(?<first>\\w+) (?<last>\\w+)/\nmatch = pattern.match("John Doe")\nmatch[:first]  # "John"\nmatch["last"]  # "Doe"\n\n# Use in replace\n"John Doe".gsub(pattern, "\\2, \\1")  # "Doe, John"'},{name:"Swift",lang:"swift",code:'import Foundation\n\nlet pattern = try NSRegularExpression(\n  pattern: "(\\w+) (\\w+)", \n  options: []\n)\n\nlet range = NSRange(location: 0, length: str.utf16.count)\nif let match = pattern.firstMatch(in: str, range: range) {\n  let full = (str as NSString).substring(with: match.range)\n  if match.numberOfRanges > 1 {\n      let first = (str as NSString).substring(with: match.range(at: 1))\n  }\n  if match.numberOfRanges > 2 {\n      let last = (str as NSString).substring(with: match.range(at: 2))\n  }\n}\n\n// Named groups (manual extraction or use external library)'}]}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Email\n/^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$/i\n\n// Phone (US)\n/^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/\n\n// URL\n/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/\n\n// Digits only\n/^\\d+$/\n\n// Alphanumeric\n/^[a-zA-Z0-9]+$/"},{name:"PHP",lang:"php",code:'<?php\n// Email\n"/^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$/i"\n\n// Phone (US)\n"/^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/"\n\n// URL\n"/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&\\/\\/=]*)/"\n\n// Digits only\n"/^\\d+$/"\n\n// Alphanumeric\n"/^[a-zA-Z0-9]+$/"'},{name:"Rust",lang:"rust",code:'use regex::Regex;\n\n// Email\nRegex::new(r"^[w.-]+@[w.-]+.[a-z]{2,}$")?;\n\n// Phone (US)\nRegex::new(r"^+?1?[-. ]?(?([0-9]{3}))?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$")?;\n\n// URL\nRegex::new(r"https?://(www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)")?;\n\n// Digits only\nRegex::new(r"^d+$")?;\n\n// Alphanumeric\nRegex::new(r"^[a-zA-Z0-9]+$")?;'},{name:"Go",lang:"go",code:'import "regexp"\n\n// Email\nregexp.MustCompile("^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$")\n\n// Phone (US)\nregexp.MustCompile("^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$")\n\n// URL\nregexp.MustCompile("https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&\\/\\/=]*)")\n\n// Digits only\nregexp.MustCompile("^\\d+$")\n\n// Alphanumeric\nregexp.MustCompile("^[a-zA-Z0-9]+$")'},{name:"Python",lang:"python",code:'import re\n\n# Email\nre.compile(r"^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$", re.IGNORECASE)\n\n# Phone (US)\nre.compile(r"^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$")\n\n# URL\nre.compile(r"https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&\\/\\/=]*)")\n\n# Digits only\nre.compile(r"^\\d+$")\n\n# Alphanumeric\nre.compile(r"^[a-zA-Z0-9]+$")'},{name:"Zig",lang:"zig",code:"// Use external regex library\n// Patterns similar to other languages"},{name:"C#",lang:"csharp",code:'using System.Text.RegularExpressions;\n\n// Email\nnew Regex(@"^[w.-]+@[w.-]+.[a-z]{2,}$", RegexOptions.IgnoreCase);\n\n// Phone (US)\nnew Regex(@"^+?1?[-. ]?(?([0-9]{3}))?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$");\n\n// URL\nnew Regex(@"https?://(www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)");\n\n// Digits only\nnew Regex(@"^d+$");\n\n// Alphanumeric\nnew Regex(@"^[a-zA-Z0-9]+$");'},{name:"C++",lang:"cpp",code:'#include <regex>\n\n// Email\nstd::regex email(R"(^[w.-]+@[w.-]+.[a-z]{2,}$)", std::regex_constants::icase);\n\n// Phone (US)\nstd::regex phone(R"(^+?1?[-. ]?(?([0-9]{3}))?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$)");\n\n// URL\nstd::regex url(R"(https?://(www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*))");\n\n// Digits only\nstd::regex digits(R"(^d+$)");\n\n// Alphanumeric\nstd::regex alnum(R"(^[a-zA-Z0-9]+$)");'},{name:"C",lang:"c",code:"// Use POSIX regex or PCRE\n// Patterns similar to other languages\n// Escape sequences may differ"},{name:"Java",lang:"java",code:'import java.util.regex.Pattern;\n\n// Email\nPattern.compile("^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$", Pattern.CASE_INSENSITIVE);\n\n// Phone (US)\nPattern.compile("^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$");\n\n// URL\nPattern.compile("https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&\\/\\/=]*)");\n\n// Digits only\nPattern.compile("^\\d+$");\n\n// Alphanumeric\nPattern.compile("^[a-zA-Z0-9]+$");'},{name:"Ruby",lang:"ruby",code:"# Email\n/^[w.-]+@[w.-]+.[a-z]{2,}$/i\n\n# Phone (US)\n/^+?1?[-. ]?(?([0-9]{3}))?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/\n\n# URL\n/https?://(www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/\n\n# Digits only\n/^d+$/\n\n# Alphanumeric\n/^[a-zA-Z0-9]+$/"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Email\ntry NSRegularExpression(pattern: "^[\\w\\.-]+@[\\w\\.-]+\\.[a-z]{2,}$", options: .caseInsensitive)\n\n// Phone (US)\ntry NSRegularExpression(pattern: "^\\+?1?[-. ]?\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$")\n\n// URL\ntry NSRegularExpression(pattern: "https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&\\/\\/=]*)")\n\n// Digits only\ntry NSRegularExpression(pattern: "^\\d+$")\n\n// Alphanumeric\ntry NSRegularExpression(pattern: "^[a-zA-Z0-9]+$")'}]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Built-in vs library support"})," \u2014 JavaScript (",(0,r.jsx)(n.code,{children:"/pattern/"})," or ",(0,r.jsx)(n.code,{children:"new RegExp"}),"), Python (",(0,r.jsx)(n.code,{children:"re"})," module), Ruby (",(0,r.jsx)(n.code,{children:"/pattern/"}),"), Java (",(0,r.jsx)(n.code,{children:"Pattern"}),"/",(0,r.jsx)(n.code,{children:"Matcher"}),"), C# (",(0,r.jsx)(n.code,{children:"Regex"}),"), C++ (",(0,r.jsx)(n.code,{children:"<regex>"}),"), and Go (",(0,r.jsx)(n.code,{children:"regexp"}),") include regex in the standard library. C requires POSIX ",(0,r.jsx)(n.code,{children:"regex.h"})," or a library like PCRE; Zig has no built-in regex and typically uses external libraries; Rust needs the ",(0,r.jsx)(n.code,{children:"regex"})," crate. If you're building a project that heavily uses pattern matching, prefer a language with built-in support; for systems or embedded work, factor in library dependencies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Syntax variations"})," \u2014 Most languages use PCRE-style patterns. JavaScript and Ruby allow literal syntax: ",(0,r.jsx)(n.code,{children:"/hello/i"})," for case-insensitive. Go and Rust use string-based patterns: ",(0,r.jsx)(n.code,{children:'Regex::new(r"(?i)hello")'})," in Rust or ",(0,r.jsx)(n.code,{children:'regexp.Compile("(?i)hello")'})," in Go. Replace operations also differ: Ruby's ",(0,r.jsx)(n.code,{children:'"hello hello".gsub(/hello/, "Hi")'})," vs. Python's ",(0,r.jsx)(n.code,{children:'re.sub(r"hello", "Hi", text)'}),". When porting regex between languages, watch for escaping differences\u2014especially in string literals where backslashes may need doubling."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Capture groups"})," \u2014 Named groups ",(0,r.jsx)(n.code,{children:"(?<first>\\w+) (?<last>\\w+)"})," are supported in JavaScript, PHP, Rust, Python, C#, Java, and Ruby, giving clean access like ",(0,r.jsx)(n.code,{children:"match.groups.first"})," or ",(0,r.jsx)(n.code,{children:'caps["first"]'}),". C's POSIX regex provides ",(0,r.jsx)(n.code,{children:"regmatch_t"})," for positional groups but not named groups; Swift's ",(0,r.jsx)(n.code,{children:"NSRegularExpression"})," exposes ranges by index, requiring manual extraction. For parsing structured text (e.g., log lines, config files), prefer a language with named group support to keep code readable."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"API ergonomics"})," \u2014 Ruby and JavaScript offer the most concise syntax: ",(0,r.jsx)(n.code,{children:'"Hello World" =~ /hello/i'})," returns the match index; ",(0,r.jsx)(n.code,{children:'"hello hello".gsub(/hello/, "Hi")'})," does replace-all in one line. C, C++, and Swift require more boilerplate: opening files, iterating with ",(0,r.jsx)(n.code,{children:"sregex_iterator"}),", converting ",(0,r.jsx)(n.code,{children:"NSRange"})," to ",(0,r.jsx)(n.code,{children:"String"})," indices. For quick text processing and scripting, choose Ruby, Python, or JavaScript; for performance-critical or low-level code, accept the verbosity of C/C++ or the explicit APIs of Rust and Go."]}),"\n"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);