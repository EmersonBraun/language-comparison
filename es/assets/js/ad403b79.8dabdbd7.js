"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[479],{5744(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"error-handling","title":"Manejo de Errores","description":"Patrones de manejo de errores -- excepciones, tipos Result y retornos de error en 12 lenguajes","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/error-handling.md","sourceDirName":".","slug":"/error-handling","permalink":"/language-comparison/es/docs/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/error-handling.md","tags":[],"version":"current","sidebarPosition":22,"frontMatter":{"sidebar_position":22,"description":"Patrones de manejo de errores -- excepciones, tipos Result y retornos de error en 12 lenguajes","keywords":["manejo de errores","excepciones","try-catch","tipo Result","patrones de error"]},"sidebar":"tutorialSidebar","previous":{"title":"CRUD Operations","permalink":"/language-comparison/es/docs/crud"},"next":{"title":"Null Safety & Optionals","permalink":"/language-comparison/es/docs/null-safety"}}');var s=r(4848),t=r(8453),i=r(6153);const a={sidebar_position:22,description:"Patrones de manejo de errores -- excepciones, tipos Result y retornos de error en 12 lenguajes",keywords:["manejo de errores","excepciones","try-catch","tipo Result","patrones de error"]},c="Manejo de Errores",l={},d=[{value:"Manejo B\xe1sico de Errores",id:"manejo-b\xe1sico-de-errores",level:2},{value:"Patrones Avanzados de Manejo de Errores",id:"patrones-avanzados-de-manejo-de-errores",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"manejo-de-errores",children:"Manejo de Errores"})}),"\n",(0,s.jsx)(n.p,{children:"Los mecanismos de manejo de errores var\xedan significativamente entre lenguajes. As\xed es como los diferentes lenguajes manejan errores y excepciones."}),"\n","\n",(0,s.jsx)(n.h2,{id:"manejo-b\xe1sico-de-errores",children:"Manejo B\xe1sico de Errores"}),"\n",(0,s.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (error) {\n  console.error("Error:", error.message);\n} finally {\n  cleanup();\n}\n\n// Throwing errors\nthrow new Error("Something went wrong");\n\n// Custom errors\nclass CustomError extends Error {\n  constructor(message) {\n      super(message);\n      this.name = "CustomError";\n  }\n}'},{name:"PHP",lang:"php",code:'<?php\n// Try-catch\ntry {\n  riskyOperation();\n} catch (Exception $e) {\n  echo "Error: " . $e->getMessage();\n} finally {\n  cleanup();\n}\n\n// Throwing exceptions\nthrow new Exception("Something went wrong");\n\n// Custom exceptions\nclass CustomException extends Exception {\n  public function __construct($message) {\n      parent::__construct($message);\n  }\n}'},{name:"Rust",lang:"rust",code:'// Result type\nfn divide(a: f64, b: f64) -> Result<f64, String> {\n  if b == 0.0 {\n      Err("Division by zero".to_string())\n  } else {\n      Ok(a / b)\n  }\n}\n\n// Using Result\nmatch divide(10.0, 2.0) {\n  Ok(result) => println!("Result: {}", result),\n  Err(e) => println!("Error: {}", e),\n}\n\n// Option type\nfn find_item(items: &[i32], target: i32) -> Option<usize> {\n  items.iter().position(|&x| x == target)\n}'},{name:"Go",lang:"go",code:'// Error return\nfunc divide(a, b float64) (float64, error) {\n  if b == 0 {\n      return 0, fmt.Errorf("division by zero")\n  }\n  return a / b, nil\n}\n\n// Using errors\nresult, err := divide(10, 2)\nif err != nil {\n  log.Fatal(err)\n}\nfmt.Println(result)\n\n// Custom error type\ntype DivisionError struct {\n  Message string\n}\n\nfunc (e *DivisionError) Error() string {\n  return e.Message\n}'},{name:"Python",lang:"python",code:'# Try-except\ntry:\n  risky_operation()\nexcept ValueError as e:\n  print(f"Error: {e}")\nexcept Exception as e:\n  print(f"Unexpected error: {e}")\nelse:\n  print("No errors")\nfinally:\n  cleanup()\n\n# Raising exceptions\nraise ValueError("Something went wrong")\n\n# Custom exceptions\nclass CustomError(Exception):\n  def __init__(self, message):\n      self.message = message\n      super().__init__(self.message)'},{name:"Zig",lang:"zig",code:'// Error union type\nfn divide(a: f64, b: f64) !f64 {\n  if (b == 0) return error.DivisionByZero;\n  return a / b;\n}\n\n// Using error union\nconst result = divide(10, 2) catch |err| {\n  std.debug.print("Error: {}\\n", .{err});\n  return;\n};\n\n// Error sets\nconst MathError = error{\n  DivisionByZero,\n  Overflow,\n};'},{name:"C#",lang:"csharp",code:'// Try-catch\ntry\n{\n  RiskyOperation();\n}\ncatch (ArgumentException ex)\n{\n  Console.WriteLine($"Error: {ex.Message}");\n}\ncatch (Exception ex)\n{\n  Console.WriteLine($"Unexpected error: {ex.Message}");\n}\nfinally\n{\n  Cleanup();\n}\n\n// Throwing exceptions\nthrow new ArgumentException("Something went wrong");\n\n// Custom exceptions\npublic class CustomException : Exception\n{\n  public CustomException(string message) : base(message) { }\n}'},{name:"C++",lang:"cpp",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (const std::exception& e) {\n  std::cerr << "Error: " << e.what() << std::endl;\n} catch (...) {\n  std::cerr << "Unknown error" << std::endl;\n}\n\n// Throwing exceptions\nthrow std::runtime_error("Something went wrong");\n\n// Custom exceptions\nclass CustomException : public std::exception {\n  const char* what() const noexcept override {\n      return "Custom error";\n  }\n};'},{name:"C",lang:"c",code:'// No built-in exceptions\n// Use return codes and error handling\n\nint divide(double a, double b, double* result) {\n  if (b == 0) {\n      return -1;  // Error code\n  }\n  *result = a / b;\n  return 0;  // Success\n}\n\n// Using error codes\ndouble result;\nif (divide(10, 2, &result) != 0) {\n  fprintf(stderr, "Division by zero\\n");\n  return;\n}\nprintf("Result: %f\\n", result);'},{name:"Java",lang:"java",code:'// Try-catch\ntry {\n  riskyOperation();\n} catch (IllegalArgumentException e) {\n  System.err.println("Error: " + e.getMessage());\n} catch (Exception e) {\n  System.err.println("Unexpected error: " + e.getMessage());\n} finally {\n  cleanup();\n}\n\n// Throwing exceptions\nthrow new IllegalArgumentException("Something went wrong");\n\n// Custom exceptions\npublic class CustomException extends Exception {\n  public CustomException(String message) {\n      super(message);\n  }\n}'},{name:"Ruby",lang:"ruby",code:'# Begin-rescue\nbegin\n  risky_operation\nrescue ArgumentError => e\n  puts "Error: #{e.message}"\nrescue => e\n  puts "Unexpected error: #{e.message}"\nensure\n  cleanup\nend\n\n# Raising exceptions\nraise ArgumentError, "Something went wrong"\n\n# Custom exceptions\nclass CustomError < StandardError\n  def initialize(message)\n      super(message)\n  end\nend'},{name:"Swift",lang:"swift",code:'// Do-catch\ndo {\n  try riskyOperation()\n} catch let error as CustomError {\n  print("Error: \\(error)")\n} catch {\n  print("Unexpected error: \\(error)")\n}\n\n// Throwing errors\nthrow CustomError.somethingWentWrong\n\n// Error protocol\nenum CustomError: Error {\n  case somethingWentWrong\n  case invalidInput(String)\n  \n  var localizedDescription: String {\n      switch self {\n      case .somethingWentWrong:\n          return "Something went wrong"\n      case .invalidInput(let message):\n          return "Invalid input: \\(message)"\n      }\n  }\n}'}]}),"\n",(0,s.jsx)(n.h2,{id:"patrones-avanzados-de-manejo-de-errores",children:"Patrones Avanzados de Manejo de Errores"}),"\n",(0,s.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Promise error handling\nfetch('/api/data')\n  .then(response => response.json())\n  .catch(error => console.error(\"Error:\", error));\n\n// Async/await\nasync function fetchData() {\n  try {\n      const response = await fetch('/api/data');\n      return await response.json();\n  } catch (error) {\n      console.error(\"Error:\", error);\n      throw error;\n  }\n}\n\n// Error boundaries (React)\nclass ErrorBoundary extends React.Component {\n  componentDidCatch(error, errorInfo) {\n      logErrorToService(error, errorInfo);\n  }\n}"},{name:"PHP",lang:"php",code:'<?php\n// Error handling with set_error_handler\nset_error_handler(function($severity, $message, $file, $line) {\n  throw new ErrorException($message, 0, $severity, $file, $line);\n});\n\n// Exception chaining\ntry {\n  // code\n} catch (Exception $e) {\n  throw new CustomException("New error", 0, $e);\n}'},{name:"Rust",lang:"rust",code:'// Error propagation with ?\nfn read_file(path: &str) -> Result<String, io::Error> {\n  let mut file = File::open(path)?;\n  let mut contents = String::new();\n  file.read_to_string(&mut contents)?;\n  Ok(contents)\n}\n\n// Combinators\nlet result = divide(10, 2)\n  .map(|x| x * 2)\n  .map_err(|e| format!("Error: {}", e));\n\n// Unwrap with custom message\nlet value = divide(10, 2)\n  .expect("Failed to divide");'},{name:"Go",lang:"go",code:'// Error wrapping (Go 1.13+)\nif err != nil {\n  return fmt.Errorf("failed to process: %w", err)\n}\n\n// Error checking\nif errors.Is(err, ErrNotFound) {\n  // handle not found\n}\n\n// Error unwrapping\nvar targetErr *CustomError\nif errors.As(err, &targetErr) {\n  // handle custom error\n}'},{name:"Python",lang:"python",code:"# Exception chaining\ntry:\n  risky_operation()\nexcept ValueError as e:\n  raise RuntimeError(\"Failed\") from e\n\n# Context managers for cleanup\nwith open('file.txt') as f:\n  content = f.read()\n# File automatically closed\n\n# Suppressing exceptions\nfrom contextlib import suppress\nwith suppress(FileNotFoundError):\n  os.remove('file.txt')"},{name:"Zig",lang:"zig",code:'// Error propagation\nfn read_file(path: []const u8) ![]const u8 {\n  const file = try std.fs.cwd().openFile(path, .{});\n  defer file.close();\n  return try file.reader().readAllAlloc(allocator, 1024);\n}\n\n// Catching specific errors\nconst result = read_file("data.txt") catch |err| switch (err) {\n  error.FileNotFound => "default content",\n  else => return err,\n};'},{name:"C#",lang:"csharp",code:'// Using statement (automatic disposal)\nusing var file = new FileStream("data.txt", FileMode.Open);\n// Automatically disposed\n\n// Exception filters (C# 6+)\ntry {\n  ProcessData();\n}\ncatch (Exception ex) when (ex.Message.Contains("timeout"))\n{\n  // Handle timeout\n}\n\n// AggregateException\nvar exceptions = new List<Exception>();\n// ... collect exceptions\nthrow new AggregateException(exceptions);'},{name:"C++",lang:"cpp",code:'// RAII (Resource Acquisition Is Initialization)\n{\n  std::ifstream file("data.txt");\n  // File automatically closed when out of scope\n}\n\n// Exception specifications (deprecated, use noexcept)\nvoid function() noexcept {\n  // Function that doesn\'t throw\n}\n\n// Nested exceptions\ntry {\n  // outer code\n} catch (...) {\n  std::throw_with_nested(std::runtime_error("Outer error"));\n}'},{name:"C",lang:"c",code:'// Error codes with errno\n#include <errno.h>\n\nFILE* file = fopen("data.txt", "r");\nif (file == NULL) {\n  perror("Error opening file");\n  // errno contains error code\n}\n\n// setjmp/longjmp (not recommended)\n#include <setjmp.h>\njmp_buf env;\nif (setjmp(env) == 0) {\n  // code that might call longjmp\n} else {\n  // error handling\n}'},{name:"Java",lang:"java",code:'// Try-with-resources (automatic close)\ntry (FileReader file = new FileReader("data.txt")) {\n  // use file\n} // automatically closed\n\n// Multi-catch (Java 7+)\ntry {\n  process();\n} catch (IOException | SQLException e) {\n  // handle both\n}\n\n// Suppressed exceptions\ntry (Resource1 r1 = ...; Resource2 r2 = ...) {\n  // if both throw, one is suppressed\n}'},{name:"Ruby",lang:"ruby",code:"# Retry mechanism\nretries = 0\nbegin\n  risky_operation\nrescue => e\n  retries += 1\n  retry if retries < 3\n  raise\nend\n\n# Exception hierarchy\nbegin\n  # code\nrescue StandardError => e\n  # catches most exceptions\nrescue => e\n  # catches all exceptions\nend"},{name:"Swift",lang:"swift",code:'// Result type (alternative to throwing)\nfunc fetchData() -> Result<String, NetworkError> {\n  // return .success("data") or .failure(.timeout)\n}\n\n// Using Result\nswitch fetchData() {\ncase .success(let data):\n  print(data)\ncase .failure(let error):\n  print("Error: \\(error)")\n}\n\n// Defer for cleanup\nfunc processFile() {\n  let file = openFile()\n  defer { closeFile(file) }\n  // file will be closed when function exits\n}'}]}),"\n",(0,s.jsx)(n.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Excepciones vs retornos de error"})," -- JavaScript, Python, PHP, Ruby, Java, C#, C++ y Swift usan excepciones estilo try/catch: haces ",(0,s.jsx)(n.code,{children:"throw"})," o ",(0,s.jsx)(n.code,{children:"raise"})," y opcionalmente ",(0,s.jsx)(n.code,{children:"catch"})," m\xe1s adelante. Go y Zig usan retornos de error expl\xedcitos: ",(0,s.jsx)(n.code,{children:"result, err := divide(10, 2)"})," en Go y ",(0,s.jsx)(n.code,{children:"const result = divide(10, 2) catch |err| { ... }"})," en Zig. Rust usa ",(0,s.jsx)(n.code,{children:"Result<T, E>"})," y ",(0,s.jsx)(n.code,{children:"Option<T>"})," en el sistema de tipos. C usa c\xf3digos de retorno (",(0,s.jsx)(n.code,{children:"int divide(..., double* result)"})," retornando 0 o -1) y ",(0,s.jsx)(n.code,{children:"errno"}),". Las excepciones permiten que los errores se propaguen impl\xedcitamente a trav\xe9s de la pila de llamadas; los retornos de error obligan a cada punto de llamada a decidir. Elige excepciones cuando quieras un manejo centralizado; elige retornos de error cuando quieras un flujo de control expl\xedcito y menos sorpresas."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tipos Result/Option"})," -- ",(0,s.jsx)(n.code,{children:"Result<T, E>"})," de Rust y las uniones de error ",(0,s.jsx)(n.code,{children:"!T"})," de Zig codifican los errores en el sistema de tipos. Por ejemplo, ",(0,s.jsx)(n.code,{children:"fn divide(a: f64, b: f64) -> Result<f64, String>"})," en Rust obliga a los llamadores a manejar ",(0,s.jsx)(n.code,{children:"Ok"})," y ",(0,s.jsx)(n.code,{children:"Err"})," mediante ",(0,s.jsx)(n.code,{children:"match"}),", ",(0,s.jsx)(n.code,{children:"?"})," o ",(0,s.jsx)(n.code,{children:".unwrap()"}),". ",(0,s.jsx)(n.code,{children:"fn divide(a: f64, b: f64) !f64"})," en Zig retorna un valor o un error de un conjunto de errores en tiempo de compilaci\xf3n. ",(0,s.jsx)(n.code,{children:"Result<String, NetworkError>"})," de Swift es opcional pero com\xfan para c\xf3digo as\xedncrono. ",(0,s.jsx)(n.code,{children:"(value, error)"})," en Go es idiom\xe1tico y se verifica con ",(0,s.jsx)(n.code,{children:"if err != nil"}),'. Los tipos Result hacen visible "esto puede fallar" en las firmas. Prefiere Rust o Zig cuando quieras garant\xedas en tiempo de compilaci\xf3n de que los errores se manejan.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Manejo obligado por el compilador"})," -- Rust y Zig requieren un manejo expl\xedcito de errores: debes usar ",(0,s.jsx)(n.code,{children:"match"}),", ",(0,s.jsx)(n.code,{children:"?"}),", ",(0,s.jsx)(n.code,{children:"try"})," o ",(0,s.jsx)(n.code,{children:"catch"}),", o el c\xf3digo no compilar\xe1. Por ejemplo, ",(0,s.jsx)(n.code,{children:"let contents = File::open(path)?;"})," en Rust propaga errores; ignorar el ",(0,s.jsx)(n.code,{children:"?"})," requerir\xeda ",(0,s.jsx)(n.code,{children:"unwrap()"})," o ",(0,s.jsx)(n.code,{children:"expect()"}),", que es expl\xedcito. En Python, Java o JavaScript, puedes llamar a una funci\xf3n que lanza excepciones sin try/catch y el error se propagar\xe1 (o fallar\xe1) silenciosamente hasta ser capturado. Si tu prioridad es eliminar errores no manejados en tiempo de compilaci\xf3n, elige Rust o Zig; si prefieres flexibilidad y manejadores centralizados, usa lenguajes basados en excepciones."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Propagaci\xf3n y envolvimiento de errores"})," -- Go 1.13+ soporta ",(0,s.jsx)(n.code,{children:'fmt.Errorf("failed: %w", err)'})," para envolver y ",(0,s.jsx)(n.code,{children:"errors.Is(err, ErrNotFound)"})," para verificar. El operador ",(0,s.jsx)(n.code,{children:"?"})," de Rust propaga errores preservando la conversi\xf3n mediante ",(0,s.jsx)(n.code,{children:"From"}),". Python usa ",(0,s.jsx)(n.code,{children:'raise RuntimeError("failed") from e'})," para encadenamiento. Java y C# soportan encadenamiento de excepciones con ",(0,s.jsx)(n.code,{children:"initCause"}),". Envolver preserva el contexto cuando los errores ascienden. Elige lenguajes con buen soporte de envolvimiento cuando construyas sistemas en capas donde los errores cruzan muchos l\xedmites."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Limpieza de recursos"})," -- RAII (C++), ",(0,s.jsx)(n.code,{children:"defer"})," (Go, Zig), ",(0,s.jsx)(n.code,{children:"using"})," (C#), ",(0,s.jsx)(n.code,{children:"try-with-resources"})," (Java) y ",(0,s.jsx)(n.code,{children:"with"})," (Python) aseguran la limpieza incluso cuando ocurren errores. Por ejemplo, ",(0,s.jsx)(n.code,{children:"defer file.close()"})," en Zig y ",(0,s.jsx)(n.code,{children:"using var file = new FileStream(...)"})," en C# garantizan la liberaci\xf3n. C no tiene un mecanismo incorporado; debes usar ",(0,s.jsx)(n.code,{children:"goto cleanup"})," o condicionales anidados. Prefiere lenguajes con limpieza estructurada cuando gestiones archivos, conexiones o bloqueos para evitar fugas en rutas de error."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);