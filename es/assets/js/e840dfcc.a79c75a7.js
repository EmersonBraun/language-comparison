"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[480],{2281(n,e,l){l.r(e),l.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"null-safety","title":"Seguridad ante Nulos y Opcionales","description":"Seguridad ante nulos, tipos Optional y manejo de nil comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/null-safety.md","sourceDirName":".","slug":"/null-safety","permalink":"/language-comparison/es/docs/null-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/null-safety.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{"sidebar_position":23,"description":"Seguridad ante nulos, tipos Optional y manejo de nil comparados en 12 lenguajes de programaci\xf3n","keywords":["seguridad ante nulos","Optional","nullable","nil","coalescencia nula","opcionales"]},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/language-comparison/es/docs/error-handling"},"next":{"title":"Concurrency & Async","permalink":"/language-comparison/es/docs/concurrency-async"}}');var i=l(4848),s=l(8453),t=l(6153);const r={sidebar_position:23,description:"Seguridad ante nulos, tipos Optional y manejo de nil comparados en 12 lenguajes de programaci\xf3n",keywords:["seguridad ante nulos","Optional","nullable","nil","coalescencia nula","opcionales"]},o="Seguridad ante Nulos y Opcionales",u={},d=[{value:"Tipos Nullable y Opcionales",id:"tipos-nullable-y-opcionales",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"seguridad-ante-nulos-y-opcionales",children:"Seguridad ante Nulos y Opcionales"})}),"\n",(0,i.jsx)(e.p,{children:"Manejar valores null/nil es una fuente com\xfan de errores. As\xed es como los diferentes lenguajes abordan la seguridad ante nulos."}),"\n","\n",(0,i.jsx)(e.h2,{id:"tipos-nullable-y-opcionales",children:"Tipos Nullable y Opcionales"}),"\n",(0,i.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// null and undefined are distinct\nlet a = null;       // Intentionally empty\nlet b = undefined;  // Not yet assigned\nlet c;              // undefined\n\n// Checking for null/undefined\nif (value === null) { }\nif (value === undefined) { }\nif (value == null) { }  // checks both null & undefined\n\n// Nullish coalescing (??)\nconst name = user ?? "default";\nconst age = data.age ?? 0;\n\n// Optional chaining (?.)\nconst city = user?.address?.city;\nconst first = arr?.[0];\nconst result = func?.();\n\n// Nullish coalescing assignment\nlet x = null;\nx ??= "default";  // x is now "default"\n\n// Logical OR (includes falsy values)\nconst name2 = user || "default";  // "" -> "default"\nconst name3 = user ?? "default";  // "" -> ""'},{name:"PHP",lang:"php",code:'<?php\n// Null\n$value = null;\nis_null($value);     // true\nisset($value);       // false\n\n// Null coalescing\n$name = $user ?? "default";\n$name ??= "default";  // PHP 7.4+\n\n// Null safe operator (PHP 8.0+)\n$city = $user?->getAddress()?->getCity();\n\n// Nullable types\nfunction find(?int $id): ?User {\n  if ($id === null) return null;\n  return User::find($id);\n}\n\n// Union types with null\nfunction process(string|null $value): string {\n  return $value ?? "default";\n}\n\n// Null strict comparison\n$value === null;   // Strict check\n$value == null;    // Also matches false, 0, ""'},{name:"Rust",lang:"rust",code:'// No null! Use Option<T>\nlet some_value: Option<i32> = Some(42);\nlet no_value: Option<i32> = None;\n\n// Pattern matching\nmatch some_value {\n  Some(v) => println!("Got: {}", v),\n  None => println!("Nothing"),\n}\n\n// if let\nif let Some(v) = some_value {\n  println!("Got: {}", v);\n}\n\n// Unwrap methods\nsome_value.unwrap();           // Panics if None\nsome_value.unwrap_or(0);       // Default value\nsome_value.unwrap_or_default(); // Type\'s default\nsome_value.expect("must exist"); // Panic with message\n\n// Combinators\nsome_value.map(|v| v * 2);         // Some(84)\nno_value.map(|v| v * 2);           // None\nsome_value.and_then(|v| Some(v + 1)); // Some(43)\nsome_value.filter(|v| *v > 50);    // None\nno_value.or(Some(0));              // Some(0)\n\n// ? operator (propagate None)\nfn get_city(user: &Option<User>) -> Option<String> {\n  let city = user.as_ref()?.address.as_ref()?.city.clone();\n  Some(city)\n}'},{name:"Go",lang:"go",code:'// nil is the zero value for pointers, interfaces,\n// maps, slices, channels, and functions\nvar ptr *int = nil\nvar slice []int = nil\nvar m map[string]int = nil\n\n// Check for nil\nif ptr != nil {\n  fmt.Println(*ptr)\n}\n\n// Pointer for optional values\nfunc findUser(id int) *User {\n  // return nil if not found\n  return nil\n}\n\nuser := findUser(1)\nif user != nil {\n  fmt.Println(user.Name)\n}\n\n// Error pattern (idiomatic Go)\nfunc getCity(user *User) (string, error) {\n  if user == nil {\n      return "", errors.New("user is nil")\n  }\n  if user.Address == nil {\n      return "", errors.New("address is nil")\n  }\n  return user.Address.City, nil\n}\n\n// Zero values (no nil needed)\nvar s string  // "" (not nil)\nvar n int     // 0 (not nil)\nvar b bool    // false (not nil)'},{name:"Python",lang:"python",code:"# None is Python's null\nvalue = None\n\n# Check for None (use 'is', not '==')\nif value is None:\n  print(\"no value\")\n\nif value is not None:\n  print(value)\n\n# Optional type hints\nfrom typing import Optional\n\ndef find_user(id: int) -> Optional[User]:\n  # Returns User or None\n  return None\n\n# Union syntax (Python 3.10+)\ndef find_user(id: int) -> User | None:\n  return None\n\n# Default values\nname = user.name if user else \"default\"\n\n# Walrus operator for safe access\nif (user := find_user(1)) is not None:\n  print(user.name)\n\n# getattr with default\nname = getattr(user, 'name', 'default')\n\n# dict.get with default\ncity = data.get('city', 'unknown')"},{name:"Zig",lang:"zig",code:'// Optional type: ?T\nvar value: ?i32 = 42;\nvar empty: ?i32 = null;\n\n// Unwrap with orelse\nconst result = value orelse 0;       // 42\nconst result2 = empty orelse 0;      // 0\n\n// Unwrap with if\nif (value) |v| {\n  std.debug.print("Got: {d}\\n", .{v});\n} else {\n  std.debug.print("null\\n", .{});\n}\n\n// Unwrap with .?  (assert non-null)\nconst v = value.?;  // panics if null\n\n// Optional pointers\nvar ptr: ?*i32 = null;\n\n// Chaining optionals\nfn getCity(user: ?*User) ?[]const u8 {\n  const u = user orelse return null;\n  const addr = u.address orelse return null;\n  return addr.city;\n}'},{name:"C#",lang:"csharp",code:'// Nullable value types\nint? nullableInt = null;\nint? withValue = 42;\n\n// Null check\nif (nullableInt.HasValue)\n  Console.WriteLine(nullableInt.Value);\n\n// Null-coalescing\nstring name = user ?? "default";\nint age = nullableAge ?? 0;\n\n// Null-coalescing assignment\nstring? name = null;\nname ??= "default";\n\n// Null-conditional (safe navigation)\nstring? city = user?.Address?.City;\nint? length = text?.Length;\nint? first = list?.FirstOrDefault();\n\n// Nullable reference types (C# 8+)\n#nullable enable\nstring nonNull = "hello";     // Cannot be null\nstring? canBeNull = null;     // Can be null\n\n// Pattern matching with null\nif (value is not null) { }\nif (value is string s) { }\n\n// Null-forgiving operator\nstring s = possiblyNull!;  // Trust me, not null'},{name:"C++",lang:"cpp",code:"// Pointers can be null\nint* ptr = nullptr;\n\nif (ptr != nullptr) {\n  std::cout << *ptr;\n}\n\n// std::optional (C++17)\n#include <optional>\n\nstd::optional<int> findValue(int id) {\n  if (id > 0) return 42;\n  return std::nullopt;\n}\n\nauto result = findValue(1);\n\n// Check and access\nif (result.has_value()) {\n  std::cout << result.value();\n}\n\n// value_or (default)\nint val = result.value_or(0);\n\n// Dereference (undefined if empty)\nif (result) {\n  std::cout << *result;\n}\n\n// std::unique_ptr / std::shared_ptr\nauto ptr = std::make_unique<int>(42);\nif (ptr) {\n  std::cout << *ptr;\n}"},{name:"C",lang:"c",code:'// NULL pointer\nint* ptr = NULL;\n\n// Check before use\nif (ptr != NULL) {\n  printf("%d\\n", *ptr);\n}\n\n// Common patterns\n// Return NULL for "not found"\nchar* find_name(int id) {\n  if (id < 0) return NULL;\n  return "John";\n}\n\nchar* name = find_name(-1);\nif (name != NULL) {\n  printf("%s\\n", name);\n}\n\n// Sentinel values (no optionals)\n#define NOT_FOUND -1\n\nint find_index(int* arr, int size, int target) {\n  for (int i = 0; i < size; i++) {\n      if (arr[i] == target) return i;\n  }\n  return NOT_FOUND;\n}'},{name:"Java",lang:"java",code:'// null reference\nString name = null;\n\n// NullPointerException if not checked\n// name.length();  // throws NPE!\n\n// Optional<T> (Java 8+)\nOptional<String> opt = Optional.of("hello");\nOptional<String> empty = Optional.empty();\nOptional<String> nullable = Optional.ofNullable(name);\n\n// Access\nopt.get();                    // "hello" (throws if empty)\nopt.orElse("default");        // "hello"\nempty.orElse("default");      // "default"\nopt.orElseGet(() -> compute()); // Lazy default\n\n// Transform\nopt.map(String::toUpperCase); // Optional("HELLO")\nopt.flatMap(this::findUser);  // Flatten nested Optional\nopt.filter(s -> s.length() > 3); // Optional("hello")\n\n// Check\nopt.isPresent();              // true\nopt.isEmpty();                // false (Java 11+)\nopt.ifPresent(s -> System.out.println(s));\n\n// Chaining\nOptional<String> city = Optional.ofNullable(user)\n  .map(User::getAddress)\n  .map(Address::getCity);'},{name:"Ruby",lang:"ruby",code:'# nil is Ruby\'s null\nvalue = nil\n\n# Check for nil\nvalue.nil?       # true\nvalue == nil     # true\n\n# Safe navigation operator (&.)\ncity = user&.address&.city\n\n# Default with ||\nname = user_name || "default"\n\n# Default with ||= (assign if nil/false)\n@name ||= "default"\n\n# Dig method (safe nested access)\ncity = data.dig(:user, :address, :city)\n\n# &. with method calls\nlength = text&.length  # nil if text is nil\n\n# Presence check (Rails)\n# name.present?  # false for nil, "", " "\n# name.presence || "default"\n\n# Compact (remove nils from array)\n[1, nil, 2, nil, 3].compact  # [1, 2, 3]'},{name:"Swift",lang:"swift",code:'// Optionals (core language feature)\nvar name: String? = nil       // Optional String\nvar age: Int? = 42            // Optional Int\n\n// Forced unwrap (crashes if nil!)\nlet n = name!  // Don\'t do this unless sure\n\n// Optional binding (if let)\nif let name = name {\n  print(name)\n}\n\n// Guard let (early return)\nguard let name = name else {\n  return\n}\nprint(name)  // name is now non-optional\n\n// Nil-coalescing\nlet result = name ?? "default"\n\n// Optional chaining\nlet city = user?.address?.city\n\n// Map / flatMap\nlet upper = name.map { $0.uppercased() }\nlet user = id.flatMap { findUser($0) }\n\n// Implicitly unwrapped optional\nvar label: String!  // Assumed non-nil after init\n\n// Multiple optional binding\nif let name = name, let age = age {\n  print("\\(name) is \\(age)")\n}'}]}),"\n",(0,i.jsx)(e.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Tipos Option/Optional"})," -- Rust (",(0,i.jsx)(e.code,{children:"Option<T>"}),"), Swift (",(0,i.jsx)(e.code,{children:"T?"}),"), Zig (",(0,i.jsx)(e.code,{children:"?T"}),") y Java (",(0,i.jsx)(e.code,{children:"Optional<T>"}),") proporcionan tipos opcionales expl\xedcitos en lugar de referencias anulables. En Rust, ",(0,i.jsx)(e.code,{children:"let x: Option<i32> = Some(42)"})," o ",(0,i.jsx)(e.code,{children:"None"})," -- no existe ",(0,i.jsx)(e.code,{children:"null"}),"; usas ",(0,i.jsx)(e.code,{children:"match"}),", ",(0,i.jsx)(e.code,{children:"if let"})," o ",(0,i.jsx)(e.code,{children:"unwrap_or(0)"}),". ",(0,i.jsx)(e.code,{children:"var name: String? = nil"})," de Swift y ",(0,i.jsx)(e.code,{children:"var value: ?i32 = null"})," de Zig hacen de la opcionalidad parte del tipo. ",(0,i.jsx)(e.code,{children:"Optional<String> opt = Optional.ofNullable(name)"})," de Java envuelve valores anulables. Estos tipos te obligan a manejar la ausencia expl\xedcitamente. Elige Option/Optional cuando quieras aplicaci\xf3n en tiempo de compilaci\xf3n; usa referencias anulables (JavaScript, Python, C) cuando prefieras flexibilidad y verificaciones en tiempo de ejecuci\xf3n."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Operadores de coalescencia nula"})," -- La mayor\xeda de los lenguajes soportan ",(0,i.jsx)(e.code,{children:"??"})," para valores por defecto: ",(0,i.jsx)(e.code,{children:'const name = user ?? "default"'})," en JavaScript, ",(0,i.jsx)(e.code,{children:'$name = $user ?? "default"'})," en PHP, ",(0,i.jsx)(e.code,{children:'string name = user ?? "default"'})," en C#, ",(0,i.jsx)(e.code,{children:'let result = name ?? "default"'})," en Swift y ",(0,i.jsx)(e.code,{children:"const result = value orelse 0"})," en Zig. Estos ignoran valores falsy como ",(0,i.jsx)(e.code,{children:'""'})," o ",(0,i.jsx)(e.code,{children:"0"})," (a diferencia de ",(0,i.jsx)(e.code,{children:"||"})," en JavaScript). Go no tiene ",(0,i.jsx)(e.code,{children:"??"}),"; usas ",(0,i.jsx)(e.code,{children:'if user != nil { name = user.Name } else { name = "default" }'})," o funciones auxiliares. Elige lenguajes con ",(0,i.jsx)(e.code,{children:"??"})," cuando necesites valores por defecto seguros con frecuencia; en Go, encapsula los valores por defecto en peque\xf1as funciones auxiliares."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Lenguajes que eliminan null"})," -- Rust no tiene null; los valores opcionales usan ",(0,i.jsx)(e.code,{children:"Option<T>"}),". Swift y Zig usan tipos opcionales como mecanismo principal: en Swift, ",(0,i.jsx)(e.code,{children:"String?"})," es distinto de ",(0,i.jsx)(e.code,{children:"String"}),", y desenvolver con ",(0,i.jsx)(e.code,{children:"!"})," o ",(0,i.jsx)(e.code,{children:"if let"})," es expl\xedcito. ",(0,i.jsx)(e.code,{children:"?T"})," de Zig obliga a usar ",(0,i.jsx)(e.code,{children:"orelse"})," o ",(0,i.jsx)(e.code,{children:"if"}),' para manejar null. Esto evita el "error del bill\xf3n de d\xf3lares" de las desreferencias nulas. Python, JavaScript, Java y C permiten ',(0,i.jsx)(e.code,{children:"null"}),"/",(0,i.jsx)(e.code,{children:"None"}),"/",(0,i.jsx)(e.code,{children:"undefined"})," en cualquier lugar, lo que lleva a ",(0,i.jsx)(e.code,{children:"NullPointerException"})," o ",(0,i.jsx)(e.code,{children:"TypeError"})," en tiempo de ejecuci\xf3n. Si eliminar errores de nulos es una prioridad, elige Rust; Swift y Zig ofrecen un manejo fuerte de opcionales con menos estrictez que Rust."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Navegaci\xf3n segura"})," -- El encadenamiento opcional (",(0,i.jsx)(e.code,{children:"?."}),") en JavaScript, PHP, C#, Swift y Ruby previene errores de desreferencia nula al recorrer estructuras anidadas. Por ejemplo, ",(0,i.jsx)(e.code,{children:"user?.address?.city"})," retorna ",(0,i.jsx)(e.code,{children:"undefined"})," o ",(0,i.jsx)(e.code,{children:"nil"})," si alg\xfan eslab\xf3n es nulo en lugar de lanzar una excepci\xf3n. ",(0,i.jsx)(e.code,{children:"arr?.[0]"})," y ",(0,i.jsx)(e.code,{children:"func?.()"})," de JavaScript extienden esto a arrays y llamadas. Sin ",(0,i.jsx)(e.code,{children:"?."}),", escribes ",(0,i.jsx)(e.code,{children:"user && user.address && user.address.city"})," (JavaScript) o verificaciones ",(0,i.jsx)(e.code,{children:"if"})," anidadas. Go no tiene ",(0,i.jsx)(e.code,{children:"?."}),"; verificas ",(0,i.jsx)(e.code,{children:"if user != nil && user.Address != nil { city = user.Address.City }"}),". Prefiere ",(0,i.jsx)(e.code,{children:"?."})," cuando trabajes con datos profundamente anidados y de tipado flexible (APIs, configuraciones)."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Asignaci\xf3n de coalescencia nula"})," -- JavaScript (",(0,i.jsx)(e.code,{children:'x ??= "default"'}),"), PHP (",(0,i.jsx)(e.code,{children:'$name ??= "default"'}),") y C# (",(0,i.jsx)(e.code,{children:'name ??= "default"'}),") asignan un valor por defecto solo cuando la variable es null o undefined. Esto mantiene el c\xf3digo conciso al inicializar campos opcionales. Go y Rust requieren ",(0,i.jsx)(e.code,{children:"if"})," o ",(0,i.jsx)(e.code,{children:"match"})," expl\xedcitos. Usa ",(0,i.jsx)(e.code,{children:"??="})," cuando tengas configuraci\xf3n opcional o valores por defecto perezosos; en Go y Rust, usa patrones ",(0,i.jsx)(e.code,{children:"Option"}),"/",(0,i.jsx)(e.code,{children:"if"})," para mayor claridad."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);