"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[671],{4129(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"crud","title":"Operaciones CRUD","description":"Operaciones CRUD y frameworks de servidor HTTP comparados en 12 lenguajes de programaci\xf3n","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/crud.md","sourceDirName":".","slug":"/crud","permalink":"/language-comparison/es/docs/crud","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/crud.md","tags":[],"version":"current","sidebarPosition":21,"frontMatter":{"sidebar_position":21,"description":"Operaciones CRUD y frameworks de servidor HTTP comparados en 12 lenguajes de programaci\xf3n","keywords":["CRUD","REST API","servidor HTTP","framework web","enrutamiento"]},"sidebar":"tutorialSidebar","previous":{"title":"JSON & Serialization","permalink":"/language-comparison/es/docs/json-serialization"},"next":{"title":"Error Handling","permalink":"/language-comparison/es/docs/error-handling"}}');var i=t(4848),r=t(8453),a=t(6153);const o={sidebar_position:21,description:"Operaciones CRUD y frameworks de servidor HTTP comparados en 12 lenguajes de programaci\xf3n",keywords:["CRUD","REST API","servidor HTTP","framework web","enrutamiento"]},p="Operaciones CRUD",d={},c=[{value:"Servidor HTTP M\xednimo con CRUD",id:"servidor-http-m\xednimo-con-crud",level:2},{value:"Puntos Clave",id:"puntos-clave",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"operaciones-crud",children:"Operaciones CRUD"})}),"\n",(0,i.jsx)(n.p,{children:"CRUD (Crear, Leer, Actualizar, Eliminar) son operaciones fundamentales en el desarrollo web. As\xed es como se crea un servidor HTTP m\xednimo con todos los verbos HTTP usando las bibliotecas m\xe1s populares en cada lenguaje."}),"\n","\n",(0,i.jsx)(n.h2,{id:"servidor-http-m\xednimo-con-crud",children:"Servidor HTTP M\xednimo con CRUD"}),"\n",(0,i.jsx)(a.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Express.js\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\n// CREATE - POST\napp.post('/items', (req, res) => {\nres.status(201).json({ message: 'Item created successfully' });\n});\n\n// READ - GET all\napp.get('/items', (req, res) => {\nres.json({ message: 'Get all items' });\n});\n\n// READ - GET one\napp.get('/items/:id', (req, res) => {\nres.json({ message: `Get item with id: ${req.params.id}` });\n});\n\n// UPDATE - PUT\napp.put('/items/:id', (req, res) => {\nres.json({ message: `Update item with id: ${req.params.id}` });\n});\n\n// DELETE\napp.delete('/items/:id', (req, res) => {\nres.status(204).json({ message: `Delete item with id: ${req.params.id}` });\n});\n\napp.listen(3000, () => {\nconsole.log('Server running on http://localhost:3000');\n});"},{name:"PHP",lang:"php",code:"<?php\n// Slim Framework\nrequire 'vendor/autoload.php';\n\nuse Slim\\Factory\\AppFactory;\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\n$app = AppFactory::create();\n$app->addBodyParsingMiddleware();\n\n// CREATE - POST\n$app->post('/items', function (Request $request, Response $response) {\n  $response->getBody()->write(json_encode(['message' => 'Item created successfully']));\n  return $response->withStatus(201)->withHeader('Content-Type', 'application/json');\n});\n\n// READ - GET all\n$app->get('/items', function (Request $request, Response $response) {\n  $response->getBody()->write(json_encode(['message' => 'Get all items']));\n  return $response->withHeader('Content-Type', 'application/json');\n});\n\n// READ - GET one\n$app->get('/items/{id}', function (Request $request, Response $response, $args) {\n  $id = $args['id'];\n  $response->getBody()->write(json_encode(['message' => \"Get item with id: $id\"]));\n  return $response->withHeader('Content-Type', 'application/json');\n});\n\n// UPDATE - PUT\n$app->put('/items/{id}', function (Request $request, Response $response, $args) {\n  $id = $args['id'];\n  $response->getBody()->write(json_encode(['message' => \"Update item with id: $id\"]));\n  return $response->withHeader('Content-Type', 'application/json');\n});\n\n// DELETE\n$app->delete('/items/{id}', function (Request $request, Response $response, $args) {\n  $id = $args['id'];\n  $response->getBody()->write(json_encode(['message' => \"Delete item with id: $id\"]));\n  return $response->withStatus(204)->withHeader('Content-Type', 'application/json');\n});\n\n$app->run();"},{name:"Rust",lang:"rust",code:'// Actix-web\nuse actix_web::{web, App, HttpResponse, HttpServer, Result};\n\n// CREATE - POST\nasync fn create_item() -> Result<HttpResponse> {\n  Ok(HttpResponse::Created().json(serde_json::json!({\n      "message": "Item created successfully"\n  })))\n}\n\n// READ - GET all\nasync fn get_items() -> Result<HttpResponse> {\n  Ok(HttpResponse::Ok().json(serde_json::json!({\n      "message": "Get all items"\n  })))\n}\n\n// READ - GET one\nasync fn get_item(id: web::Path<u32>) -> Result<HttpResponse> {\n  Ok(HttpResponse::Ok().json(serde_json::json!({\n      "message": format!("Get item with id: {}", id)\n  })))\n}\n\n// UPDATE - PUT\nasync fn update_item(id: web::Path<u32>) -> Result<HttpResponse> {\n  Ok(HttpResponse::Ok().json(serde_json::json!({\n      "message": format!("Update item with id: {}", id)\n  })))\n}\n\n// DELETE\nasync fn delete_item(id: web::Path<u32>) -> Result<HttpResponse> {\n  Ok(HttpResponse::NoContent().json(serde_json::json!({\n      "message": format!("Delete item with id: {}", id)\n  })))\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n  HttpServer::new(|| {\n      App::new()\n          .route("/items", web::post().to(create_item))\n          .route("/items", web::get().to(get_items))\n          .route("/items/{id}", web::get().to(get_item))\n          .route("/items/{id}", web::put().to(update_item))\n          .route("/items/{id}", web::delete().to(delete_item))\n  })\n  .bind("127.0.0.1:8080")?\n  .run()\n  .await\n}'},{name:"Go",lang:"go",code:'// Gin framework\npackage main\n\nimport (\n  "net/http"\n  "github.com/gin-gonic/gin"\n)\n\n// CREATE - POST\nfunc createItem(c *gin.Context) {\n  c.JSON(http.StatusCreated, gin.H{\n      "message": "Item created successfully",\n  })\n}\n\n// READ - GET all\nfunc getItems(c *gin.Context) {\n  c.JSON(http.StatusOK, gin.H{\n      "message": "Get all items",\n  })\n}\n\n// READ - GET one\nfunc getItem(c *gin.Context) {\n  id := c.Param("id")\n  c.JSON(http.StatusOK, gin.H{\n      "message": "Get item with id: " + id,\n  })\n}\n\n// UPDATE - PUT\nfunc updateItem(c *gin.Context) {\n  id := c.Param("id")\n  c.JSON(http.StatusOK, gin.H{\n      "message": "Update item with id: " + id,\n  })\n}\n\n// DELETE\nfunc deleteItem(c *gin.Context) {\n  id := c.Param("id")\n  c.JSON(http.StatusNoContent, gin.H{\n      "message": "Delete item with id: " + id,\n  })\n}\n\nfunc main() {\n  r := gin.Default()\n  \n  r.POST("/items", createItem)\n  r.GET("/items", getItems)\n  r.GET("/items/:id", getItem)\n  r.PUT("/items/:id", updateItem)\n  r.DELETE("/items/:id", deleteItem)\n  \n  r.Run(":8080")\n}'},{name:"Python",lang:"python",code:"# Flask\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\n\n# CREATE - POST\n@app.route('/items', methods=['POST'])\ndef create_item():\n  return jsonify({'message': 'Item created successfully'}), 201\n\n# READ - GET all\n@app.route('/items', methods=['GET'])\ndef get_items():\n  return jsonify({'message': 'Get all items'})\n\n# READ - GET one\n@app.route('/items/<int:item_id>', methods=['GET'])\ndef get_item(item_id):\n  return jsonify({'message': f'Get item with id: {item_id}'})\n\n# UPDATE - PUT\n@app.route('/items/<int:item_id>', methods=['PUT'])\ndef update_item(item_id):\n  return jsonify({'message': f'Update item with id: {item_id}'})\n\n# DELETE\n@app.route('/items/<int:item_id>', methods=['DELETE'])\ndef delete_item(item_id):\n  return jsonify({'message': f'Delete item with id: {item_id}'}), 204\n\nif __name__ == '__main__':\n  app.run(port=5000)"},{name:"Zig",lang:"zig",code:'// httpz (http.zig) - Express-like framework\nconst std = @import("std");\nconst httpz = @import("httpz");\n\npub fn main() !void {\n  var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n  const allocator = gpa.allocator();\n  defer _ = gpa.deinit();\n\n  var server = try httpz.Server(void).init(allocator, .{ .port = 8080 }, {});\n  defer {\n      server.stop();\n      server.deinit();\n  }\n\n  var router = try server.router(.{});\n  \n  // CREATE - POST\n  try router.post("/items", createItem, .{});\n  \n  // READ - GET all\n  try router.get("/items", getItems, .{});\n  \n  // READ - GET one\n  try router.get("/items/:id", getItem, .{});\n  \n  // UPDATE - PUT\n  try router.put("/items/:id", updateItem, .{});\n  \n  // DELETE\n  try router.delete("/items/:id", deleteItem, .{});\n\n  try server.listen();\n}\n\n// CREATE - POST\nfn createItem(req: *httpz.Request, res: *httpz.Response) !void {\n  res.status = 201;\n  try res.json(.{ .message = "Item created successfully" }, .{});\n}\n\n// READ - GET all\nfn getItems(req: *httpz.Request, res: *httpz.Response) !void {\n  res.status = 200;\n  try res.json(.{ .message = "Get all items" }, .{});\n}\n\n// READ - GET one\nfn getItem(req: *httpz.Request, res: *httpz.Response) !void {\n  const id = req.param("id").?;\n  res.status = 200;\n  try res.json(.{ .message = try std.fmt.allocPrint(req.arena.allocator(), "Get item with id: {s}", .{id}) }, .{});\n}\n\n// UPDATE - PUT\nfn updateItem(req: *httpz.Request, res: *httpz.Response) !void {\n  const id = req.param("id").?;\n  res.status = 200;\n  try res.json(.{ .message = try std.fmt.allocPrint(req.arena.allocator(), "Update item with id: {s}", .{id}) }, .{});\n}\n\n// DELETE\nfn deleteItem(req: *httpz.Request, res: *httpz.Response) !void {\n  const id = req.param("id").?;\n  res.status = 204;\n  try res.json(.{ .message = try std.fmt.allocPrint(req.arena.allocator(), "Delete item with id: {s}", .{id}) }, .{});\n}'},{name:"C#",lang:"csharp",code:'// ASP.NET Core Minimal API\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\n// CREATE - POST\napp.MapPost("/items", () => {\n  return Results.Created("/items", new { message = "Item created successfully" });\n});\n\n// READ - GET all\napp.MapGet("/items", () => {\n  return Results.Ok(new { message = "Get all items" });\n});\n\n// READ - GET one\napp.MapGet("/items/{id}", (int id) => {\n  return Results.Ok(new { message = $"Get item with id: {id}" });\n});\n\n// UPDATE - PUT\napp.MapPut("/items/{id}", (int id) => {\n  return Results.Ok(new { message = $"Update item with id: {id}" });\n});\n\n// DELETE\napp.MapDelete("/items/{id}", (int id) => {\n  return Results.NoContent();\n});\n\napp.Run("http://localhost:5000");'},{name:"C++",lang:"cpp",code:'// cpp-httplib\n#include <httplib.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nint main() {\n  httplib::Server svr;\n\n  // CREATE - POST\n  svr.Post("/items", [](const httplib::Request&, httplib::Response& res) {\n      json response;\n      response["message"] = "Item created successfully";\n      res.set_content(response.dump(), "application/json");\n      res.status = 201;\n  });\n\n  // READ - GET all\n  svr.Get("/items", [](const httplib::Request&, httplib::Response& res) {\n      json response;\n      response["message"] = "Get all items";\n      res.set_content(response.dump(), "application/json");\n  });\n\n  // READ - GET one\n  svr.Get("/items/(\\d+)", [](const httplib::Request& req, httplib::Response& res) {\n      std::string id = req.matches[1];\n      json response;\n      response["message"] = "Get item with id: " + id;\n      res.set_content(response.dump(), "application/json");\n  });\n\n  // UPDATE - PUT\n  svr.Put("/items/(\\d+)", [](const httplib::Request& req, httplib::Response& res) {\n      std::string id = req.matches[1];\n      json response;\n      response["message"] = "Update item with id: " + id;\n      res.set_content(response.dump(), "application/json");\n  });\n\n  // DELETE\n  svr.Delete("/items/(\\d+)", [](const httplib::Request& req, httplib::Response& res) {\n      std::string id = req.matches[1];\n      json response;\n      response["message"] = "Delete item with id: " + id;\n      res.set_content(response.dump(), "application/json");\n      res.status = 204;\n  });\n\n  svr.listen("0.0.0.0", 8080);\n  return 0;\n}'},{name:"C",lang:"c",code:'// libmicrohttpd\n#include <microhttpd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// HTTP handler (simplified - full implementation requires\n// request parsing, JSON handling, routing, etc.)\nstatic int answer_to_connection(void *cls, struct MHD_Connection *connection,\n                              const char *url, const char *method,\n                              const char *version, const char *upload_data,\n                              size_t *upload_data_size, void **con_cls) {\n  \n  struct MHD_Response *response;\n  int ret;\n  const char *page;\n  \n  // Simple routing based on method and URL\n  if (strcmp(method, "GET") == 0 && strcmp(url, "/items") == 0) {\n      page = "{"message": "Get all items"}";\n  } else if (strcmp(method, "POST") == 0 && strcmp(url, "/items") == 0) {\n      page = "{"message": "Item created successfully"}";\n  } else {\n      page = "{"message": "CRUD API"}";\n  }\n  \n  response = MHD_create_response_from_buffer(strlen(page),\n                                              (void*)page,\n                                              MHD_RESPMEM_PERSISTENT);\n  MHD_add_response_header(response, "Content-Type", "application/json");\n  ret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n  MHD_destroy_response(response);\n  \n  return ret;\n}\n\nint main() {\n  struct MHD_Daemon *daemon;\n  \n  daemon = MHD_start_daemon(MHD_USE_INTERNAL_POLLING_THREAD,\n                           8080, NULL, NULL,\n                           &answer_to_connection, NULL,\n                           MHD_OPTION_END);\n  if (NULL == daemon) return 1;\n  \n  getchar();\n  MHD_stop_daemon(daemon);\n  return 0;\n}\n\n// Note: Full CRUD implementation in C requires extensive\n// manual HTTP parsing, JSON handling, and routing logic.'},{name:"Java",lang:"java",code:'// Spring Boot\npackage com.example.crud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@SpringBootApplication\n@RestController\n@RequestMapping("/items")\npublic class CrudApplication {\n  \n  // CREATE - POST\n  @PostMapping\n  public Map<String, String> createItem() {\n      Map<String, String> response = new HashMap<>();\n      response.put("message", "Item created successfully");\n      return response;\n  }\n  \n  // READ - GET all\n  @GetMapping\n  public Map<String, String> getItems() {\n      Map<String, String> response = new HashMap<>();\n      response.put("message", "Get all items");\n      return response;\n  }\n  \n  // READ - GET one\n  @GetMapping("/{id}")\n  public Map<String, String> getItem(@PathVariable int id) {\n      Map<String, String> response = new HashMap<>();\n      response.put("message", "Get item with id: " + id);\n      return response;\n  }\n  \n  // UPDATE - PUT\n  @PutMapping("/{id}")\n  public Map<String, String> updateItem(@PathVariable int id) {\n      Map<String, String> response = new HashMap<>();\n      response.put("message", "Update item with id: " + id);\n      return response;\n  }\n  \n  // DELETE\n  @DeleteMapping("/{id}")\n  public Map<String, String> deleteItem(@PathVariable int id) {\n      Map<String, String> response = new HashMap<>();\n      response.put("message", "Delete item with id: " + id);\n      return response;\n  }\n  \n  public static void main(String[] args) {\n      SpringApplication.run(CrudApplication.class, args);\n  }\n}'},{name:"Ruby",lang:"ruby",code:"# Sinatra\nrequire 'sinatra'\nrequire 'json'\n\n# CREATE - POST\npost '/items' do\ncontent_type :json\n{ message: 'Item created successfully' }.to_json\nend\n\n# READ - GET all\nget '/items' do\ncontent_type :json\n{ message: 'Get all items' }.to_json\nend\n\n# READ - GET one\nget '/items/:id' do\ncontent_type :json\n{ message: \"Get item with id: #{params[:id]}\" }.to_json\nend\n\n# UPDATE - PUT\nput '/items/:id' do\ncontent_type :json\n{ message: \"Update item with id: #{params[:id]}\" }.to_json\nend\n\n# DELETE\ndelete '/items/:id' do\ncontent_type :json\n{ message: \"Delete item with id: #{params[:id]}\" }.to_json\nend\n\n# Run: ruby app.rb\n# Or: rackup config.ru"},{name:"Swift",lang:"swift",code:'// Vapor\nimport Vapor\n\n// CREATE - POST\nfunc createItem(req: Request) throws -> [String: String] {\n  return ["message": "Item created successfully"]\n}\n\n// READ - GET all\nfunc getItems(req: Request) -> [String: String] {\n  return ["message": "Get all items"]\n}\n\n// READ - GET one\nfunc getItem(req: Request) throws -> [String: String] {\n  guard let id = req.parameters.get("id") else {\n      throw Abort(.badRequest)\n  }\n  return ["message": "Get item with id: \\(id)"]\n}\n\n// UPDATE - PUT\nfunc updateItem(req: Request) throws -> [String: String] {\n  guard let id = req.parameters.get("id") else {\n      throw Abort(.badRequest)\n  }\n  return ["message": "Update item with id: \\(id)"]\n}\n\n// DELETE\nfunc deleteItem(req: Request) throws -> HTTPStatus {\n  guard let id = req.parameters.get("id") else {\n      throw Abort(.badRequest)\n  }\n  // Return 204 No Content\n  return .noContent\n}\n\n// Configure routes\nfunc routes(_ app: Application) throws {\n  app.post("items", use: createItem)\n  app.get("items", use: getItems)\n  app.get("items", ":id", use: getItem)\n  app.put("items", ":id", use: updateItem)\n  app.delete("items", ":id", use: deleteItem)\n}\n\n// Run: swift run'}]}),"\n",(0,i.jsx)(n.h2,{id:"puntos-clave",children:"Puntos Clave"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Madurez del framework"})," -- JavaScript (Express), Python (Flask), Go (Gin), Java (Spring Boot) y Ruby (Sinatra) tienen ecosistemas maduros y ricos en convenciones con middleware incorporado, validaci\xf3n e integraciones con ORM. Por ejemplo, Express ofrece ",(0,i.jsx)(n.code,{children:"express.json()"})," y ",(0,i.jsx)(n.code,{children:"app.post('/items', handler)"})," directamente, mientras que Spring Boot auto-configura Tomcat embebido e inyecci\xf3n de dependencias. En contraste, C con libmicrohttpd requiere enrutamiento manual basado en ",(0,i.jsx)(n.code,{children:"strcmp"}),", parseo manual de JSON y manejo personalizado de request/response. Elige frameworks maduros cuando necesites enviar APIs r\xe1pidamente; considera C solo para sistemas embebidos o binarios m\xednimos."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Patrones de enrutamiento"})," -- El enrutamiento declarativo es la norma: Express usa ",(0,i.jsx)(n.code,{children:"app.get('/items/:id', ...)"}),", Gin usa ",(0,i.jsx)(n.code,{children:'r.GET("/items/:id", getItem)'}),", Flask usa ",(0,i.jsx)(n.code,{children:"@app.route('/items/<int:item_id>', methods=['GET'])"})," y Sinatra usa ",(0,i.jsx)(n.code,{children:"get '/items/:id' do"}),". Spring Boot usa anotaciones como ",(0,i.jsx)(n.code,{children:'@GetMapping("/{id}")'})," con ",(0,i.jsx)(n.code,{children:"@PathVariable"}),". Estos patrones mapean verbos y rutas a handlers de forma limpia. C requiere un \xfanico callback que despacha mediante ",(0,i.jsx)(n.code,{children:'strcmp(method, "GET")'})," y ",(0,i.jsx)(n.code,{children:'strcmp(url, "/items")'}),", lo cual escala mal. Prefiere enrutamiento declarativo para mantenibilidad y consistencia en toda tu superficie de API."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"M\xednimo vs full-stack"})," -- ASP.NET Core Minimal API y Zig (httpz) enfatizan definiciones de ruta concisas: C# usa ",(0,i.jsx)(n.code,{children:'app.MapGet("/items/{id}", (int id) => Results.Ok(...))'})," sin controladores; Zig usa ",(0,i.jsx)(n.code,{children:'try router.get("/items/:id", getItem, .{})'}),". Spring Boot y Vapor ofrecen estructuras con bater\xedas incluidas: Spring proporciona ",(0,i.jsx)(n.code,{children:"@RestController"}),", ",(0,i.jsx)(n.code,{children:"@RequestMapping"}),", auto-serializaci\xf3n e inyecci\xf3n de dependencias; Vapor se integra con el sistema de tipos de Swift y async/await. Las APIs m\xednimas son adecuadas para microservicios y prototipos; los frameworks full-stack son adecuados para aplicaciones grandes con convenciones y herramientas compartidas."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Ergonom\xeda de request/response"})," -- La mayor\xeda de los frameworks ofrecen manejo conveniente de JSON: Express con ",(0,i.jsx)(n.code,{children:"res.json({ message: '...' })"}),", Gin con ",(0,i.jsx)(n.code,{children:"c.JSON(http.StatusOK, gin.H{...})"}),", Flask con ",(0,i.jsx)(n.code,{children:"jsonify({'message': '...'})"})," y C# con ",(0,i.jsx)(n.code,{children:'Results.Ok(new { message = "..." })'}),". El httpz de Zig requiere ",(0,i.jsx)(n.code,{children:'res.json(.{ .message = "..." }, .{})'})," expl\xedcito y asignaci\xf3n manual de arena para strings formateados. Elige frameworks con serializaci\xf3n ergon\xf3mica cuando construyas APIs REST; el enfoque expl\xedcito de Zig prioriza control y previsibilidad sobre conveniencia."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Extracci\xf3n de par\xe1metros"})," -- Los lenguajes difieren en c\xf3mo los par\xe1metros de ruta llegan a los handlers: Python (Flask) usa ",(0,i.jsx)(n.code,{children:"def get_item(item_id)"})," con conversi\xf3n de tipos; Go (Gin) usa ",(0,i.jsx)(n.code,{children:'c.Param("id")'}),"; Rust (Actix) usa ",(0,i.jsx)(n.code,{children:"web::Path<u32>"})," para extracci\xf3n tipada; Java (Spring) usa ",(0,i.jsx)(n.code,{children:"@PathVariable int id"}),". C y Zig requieren parseo manual: ",(0,i.jsx)(n.code,{children:'req.param("id").?'})," en Zig o extracci\xf3n de strings de URL en C. La extracci\xf3n tipada reduce bugs y c\xf3digo repetitivo. Prefiere frameworks que parseen par\xe1metros a valores tipados autom\xe1ticamente."]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);