"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[686],{9388(n,e,l){l.r(e),l.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"null-safety","title":"Null Safety & Optionals","description":"Null safety, tipos Optional e tratamento de nil comparados em 12 linguagens de programa\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/null-safety.md","sourceDirName":".","slug":"/null-safety","permalink":"/language-comparison/pt-BR/docs/null-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/null-safety.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{"sidebar_position":23,"description":"Null safety, tipos Optional e tratamento de nil comparados em 12 linguagens de programa\xe7\xe3o","keywords":["null safety","Optional","nullable","nil","null coalescing","optionals"]},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling","permalink":"/language-comparison/pt-BR/docs/error-handling"},"next":{"title":"Concurrency & Async","permalink":"/language-comparison/pt-BR/docs/concurrency-async"}}');var i=l(4848),t=l(8453),s=l(6153);const r={sidebar_position:23,description:"Null safety, tipos Optional e tratamento de nil comparados em 12 linguagens de programa\xe7\xe3o",keywords:["null safety","Optional","nullable","nil","null coalescing","optionals"]},o="Null Safety & Optionals",u={},d=[{value:"Tipos Nullable &amp; Optionals",id:"tipos-nullable--optionals",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"null-safety--optionals",children:"Null Safety & Optionals"})}),"\n",(0,i.jsx)(e.p,{children:"Lidar com valores null/nil \xe9 uma fonte comum de bugs. Veja como diferentes linguagens abordam a seguran\xe7a contra null."}),"\n","\n",(0,i.jsx)(e.h2,{id:"tipos-nullable--optionals",children:"Tipos Nullable & Optionals"}),"\n",(0,i.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// null and undefined are distinct\nlet a = null;       // Intentionally empty\nlet b = undefined;  // Not yet assigned\nlet c;              // undefined\n\n// Checking for null/undefined\nif (value === null) { }\nif (value === undefined) { }\nif (value == null) { }  // checks both null & undefined\n\n// Nullish coalescing (??)\nconst name = user ?? "default";\nconst age = data.age ?? 0;\n\n// Optional chaining (?.)\nconst city = user?.address?.city;\nconst first = arr?.[0];\nconst result = func?.();\n\n// Nullish coalescing assignment\nlet x = null;\nx ??= "default";  // x is now "default"\n\n// Logical OR (includes falsy values)\nconst name2 = user || "default";  // "" -> "default"\nconst name3 = user ?? "default";  // "" -> ""'},{name:"PHP",lang:"php",code:'<?php\n// Null\n$value = null;\nis_null($value);     // true\nisset($value);       // false\n\n// Null coalescing\n$name = $user ?? "default";\n$name ??= "default";  // PHP 7.4+\n\n// Null safe operator (PHP 8.0+)\n$city = $user?->getAddress()?->getCity();\n\n// Nullable types\nfunction find(?int $id): ?User {\n  if ($id === null) return null;\n  return User::find($id);\n}\n\n// Union types with null\nfunction process(string|null $value): string {\n  return $value ?? "default";\n}\n\n// Null strict comparison\n$value === null;   // Strict check\n$value == null;    // Also matches false, 0, ""'},{name:"Rust",lang:"rust",code:'// No null! Use Option<T>\nlet some_value: Option<i32> = Some(42);\nlet no_value: Option<i32> = None;\n\n// Pattern matching\nmatch some_value {\n  Some(v) => println!("Got: {}", v),\n  None => println!("Nothing"),\n}\n\n// if let\nif let Some(v) = some_value {\n  println!("Got: {}", v);\n}\n\n// Unwrap methods\nsome_value.unwrap();           // Panics if None\nsome_value.unwrap_or(0);       // Default value\nsome_value.unwrap_or_default(); // Type\'s default\nsome_value.expect("must exist"); // Panic with message\n\n// Combinators\nsome_value.map(|v| v * 2);         // Some(84)\nno_value.map(|v| v * 2);           // None\nsome_value.and_then(|v| Some(v + 1)); // Some(43)\nsome_value.filter(|v| *v > 50);    // None\nno_value.or(Some(0));              // Some(0)\n\n// ? operator (propagate None)\nfn get_city(user: &Option<User>) -> Option<String> {\n  let city = user.as_ref()?.address.as_ref()?.city.clone();\n  Some(city)\n}'},{name:"Go",lang:"go",code:'// nil is the zero value for pointers, interfaces,\n// maps, slices, channels, and functions\nvar ptr *int = nil\nvar slice []int = nil\nvar m map[string]int = nil\n\n// Check for nil\nif ptr != nil {\n  fmt.Println(*ptr)\n}\n\n// Pointer for optional values\nfunc findUser(id int) *User {\n  // return nil if not found\n  return nil\n}\n\nuser := findUser(1)\nif user != nil {\n  fmt.Println(user.Name)\n}\n\n// Error pattern (idiomatic Go)\nfunc getCity(user *User) (string, error) {\n  if user == nil {\n      return "", errors.New("user is nil")\n  }\n  if user.Address == nil {\n      return "", errors.New("address is nil")\n  }\n  return user.Address.City, nil\n}\n\n// Zero values (no nil needed)\nvar s string  // "" (not nil)\nvar n int     // 0 (not nil)\nvar b bool    // false (not nil)'},{name:"Python",lang:"python",code:"# None is Python's null\nvalue = None\n\n# Check for None (use 'is', not '==')\nif value is None:\n  print(\"no value\")\n\nif value is not None:\n  print(value)\n\n# Optional type hints\nfrom typing import Optional\n\ndef find_user(id: int) -> Optional[User]:\n  # Returns User or None\n  return None\n\n# Union syntax (Python 3.10+)\ndef find_user(id: int) -> User | None:\n  return None\n\n# Default values\nname = user.name if user else \"default\"\n\n# Walrus operator for safe access\nif (user := find_user(1)) is not None:\n  print(user.name)\n\n# getattr with default\nname = getattr(user, 'name', 'default')\n\n# dict.get with default\ncity = data.get('city', 'unknown')"},{name:"Zig",lang:"zig",code:'// Optional type: ?T\nvar value: ?i32 = 42;\nvar empty: ?i32 = null;\n\n// Unwrap with orelse\nconst result = value orelse 0;       // 42\nconst result2 = empty orelse 0;      // 0\n\n// Unwrap with if\nif (value) |v| {\n  std.debug.print("Got: {d}\\n", .{v});\n} else {\n  std.debug.print("null\\n", .{});\n}\n\n// Unwrap with .?  (assert non-null)\nconst v = value.?;  // panics if null\n\n// Optional pointers\nvar ptr: ?*i32 = null;\n\n// Chaining optionals\nfn getCity(user: ?*User) ?[]const u8 {\n  const u = user orelse return null;\n  const addr = u.address orelse return null;\n  return addr.city;\n}'},{name:"C#",lang:"csharp",code:'// Nullable value types\nint? nullableInt = null;\nint? withValue = 42;\n\n// Null check\nif (nullableInt.HasValue)\n  Console.WriteLine(nullableInt.Value);\n\n// Null-coalescing\nstring name = user ?? "default";\nint age = nullableAge ?? 0;\n\n// Null-coalescing assignment\nstring? name = null;\nname ??= "default";\n\n// Null-conditional (safe navigation)\nstring? city = user?.Address?.City;\nint? length = text?.Length;\nint? first = list?.FirstOrDefault();\n\n// Nullable reference types (C# 8+)\n#nullable enable\nstring nonNull = "hello";     // Cannot be null\nstring? canBeNull = null;     // Can be null\n\n// Pattern matching with null\nif (value is not null) { }\nif (value is string s) { }\n\n// Null-forgiving operator\nstring s = possiblyNull!;  // Trust me, not null'},{name:"C++",lang:"cpp",code:"// Pointers can be null\nint* ptr = nullptr;\n\nif (ptr != nullptr) {\n  std::cout << *ptr;\n}\n\n// std::optional (C++17)\n#include <optional>\n\nstd::optional<int> findValue(int id) {\n  if (id > 0) return 42;\n  return std::nullopt;\n}\n\nauto result = findValue(1);\n\n// Check and access\nif (result.has_value()) {\n  std::cout << result.value();\n}\n\n// value_or (default)\nint val = result.value_or(0);\n\n// Dereference (undefined if empty)\nif (result) {\n  std::cout << *result;\n}\n\n// std::unique_ptr / std::shared_ptr\nauto ptr = std::make_unique<int>(42);\nif (ptr) {\n  std::cout << *ptr;\n}"},{name:"C",lang:"c",code:'// NULL pointer\nint* ptr = NULL;\n\n// Check before use\nif (ptr != NULL) {\n  printf("%d\\n", *ptr);\n}\n\n// Common patterns\n// Return NULL for "not found"\nchar* find_name(int id) {\n  if (id < 0) return NULL;\n  return "John";\n}\n\nchar* name = find_name(-1);\nif (name != NULL) {\n  printf("%s\\n", name);\n}\n\n// Sentinel values (no optionals)\n#define NOT_FOUND -1\n\nint find_index(int* arr, int size, int target) {\n  for (int i = 0; i < size; i++) {\n      if (arr[i] == target) return i;\n  }\n  return NOT_FOUND;\n}'},{name:"Java",lang:"java",code:'// null reference\nString name = null;\n\n// NullPointerException if not checked\n// name.length();  // throws NPE!\n\n// Optional<T> (Java 8+)\nOptional<String> opt = Optional.of("hello");\nOptional<String> empty = Optional.empty();\nOptional<String> nullable = Optional.ofNullable(name);\n\n// Access\nopt.get();                    // "hello" (throws if empty)\nopt.orElse("default");        // "hello"\nempty.orElse("default");      // "default"\nopt.orElseGet(() -> compute()); // Lazy default\n\n// Transform\nopt.map(String::toUpperCase); // Optional("HELLO")\nopt.flatMap(this::findUser);  // Flatten nested Optional\nopt.filter(s -> s.length() > 3); // Optional("hello")\n\n// Check\nopt.isPresent();              // true\nopt.isEmpty();                // false (Java 11+)\nopt.ifPresent(s -> System.out.println(s));\n\n// Chaining\nOptional<String> city = Optional.ofNullable(user)\n  .map(User::getAddress)\n  .map(Address::getCity);'},{name:"Ruby",lang:"ruby",code:'# nil is Ruby\'s null\nvalue = nil\n\n# Check for nil\nvalue.nil?       # true\nvalue == nil     # true\n\n# Safe navigation operator (&.)\ncity = user&.address&.city\n\n# Default with ||\nname = user_name || "default"\n\n# Default with ||= (assign if nil/false)\n@name ||= "default"\n\n# Dig method (safe nested access)\ncity = data.dig(:user, :address, :city)\n\n# &. with method calls\nlength = text&.length  # nil if text is nil\n\n# Presence check (Rails)\n# name.present?  # false for nil, "", " "\n# name.presence || "default"\n\n# Compact (remove nils from array)\n[1, nil, 2, nil, 3].compact  # [1, 2, 3]'},{name:"Swift",lang:"swift",code:'// Optionals (core language feature)\nvar name: String? = nil       // Optional String\nvar age: Int? = 42            // Optional Int\n\n// Forced unwrap (crashes if nil!)\nlet n = name!  // Don\'t do this unless sure\n\n// Optional binding (if let)\nif let name = name {\n  print(name)\n}\n\n// Guard let (early return)\nguard let name = name else {\n  return\n}\nprint(name)  // name is now non-optional\n\n// Nil-coalescing\nlet result = name ?? "default"\n\n// Optional chaining\nlet city = user?.address?.city\n\n// Map / flatMap\nlet upper = name.map { $0.uppercased() }\nlet user = id.flatMap { findUser($0) }\n\n// Implicitly unwrapped optional\nvar label: String!  // Assumed non-nil after init\n\n// Multiple optional binding\nif let name = name, let age = age {\n  print("\\(name) is \\(age)")\n}'}]}),"\n",(0,i.jsx)(e.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Tipos Option/Optional"})," -- Rust (",(0,i.jsx)(e.code,{children:"Option<T>"}),"), Swift (",(0,i.jsx)(e.code,{children:"T?"}),"), Zig (",(0,i.jsx)(e.code,{children:"?T"}),") e Java (",(0,i.jsx)(e.code,{children:"Optional<T>"}),") fornecem tipos opcionais expl\xedcitos em vez de refer\xeancias anul\xe1veis. Em Rust, ",(0,i.jsx)(e.code,{children:"let x: Option<i32> = Some(42)"})," ou ",(0,i.jsx)(e.code,{children:"None"})," -- n\xe3o existe ",(0,i.jsx)(e.code,{children:"null"}),"; voc\xea usa ",(0,i.jsx)(e.code,{children:"match"}),", ",(0,i.jsx)(e.code,{children:"if let"})," ou ",(0,i.jsx)(e.code,{children:"unwrap_or(0)"}),". O ",(0,i.jsx)(e.code,{children:"var name: String? = nil"})," do Swift e o ",(0,i.jsx)(e.code,{children:"var value: ?i32 = null"})," do Zig tornam a opcionalidade parte do tipo. O ",(0,i.jsx)(e.code,{children:"Optional<String> opt = Optional.ofNullable(name)"})," do Java encapsula valores anul\xe1veis. Esses tipos for\xe7am voc\xea a tratar a aus\xeancia explicitamente. Escolha Option/Optional quando quiser verifica\xe7\xe3o em tempo de compila\xe7\xe3o; use refer\xeancias anul\xe1veis (JavaScript, Python, C) quando preferir flexibilidade e verifica\xe7\xf5es em tempo de execu\xe7\xe3o."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Operadores de coalesc\xeancia nula"})," -- A maioria das linguagens suporta ",(0,i.jsx)(e.code,{children:"??"})," para valores padr\xe3o: ",(0,i.jsx)(e.code,{children:'const name = user ?? "default"'})," em JavaScript, ",(0,i.jsx)(e.code,{children:'$name = $user ?? "default"'})," em PHP, ",(0,i.jsx)(e.code,{children:'string name = user ?? "default"'})," em C#, ",(0,i.jsx)(e.code,{children:'let result = name ?? "default"'})," em Swift e ",(0,i.jsx)(e.code,{children:"const result = value orelse 0"})," em Zig. Esses ignoram valores falsy como ",(0,i.jsx)(e.code,{children:'""'})," ou ",(0,i.jsx)(e.code,{children:"0"})," (diferente de ",(0,i.jsx)(e.code,{children:"||"})," em JavaScript). Go n\xe3o tem ",(0,i.jsx)(e.code,{children:"??"}),"; voc\xea usa ",(0,i.jsx)(e.code,{children:'if user != nil { name = user.Name } else { name = "default" }'})," ou fun\xe7\xf5es auxiliares. Escolha linguagens com ",(0,i.jsx)(e.code,{children:"??"})," quando precisar frequentemente de valores padr\xe3o seguros; em Go, encapsule os padr\xf5es em pequenas fun\xe7\xf5es auxiliares."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Linguagens que eliminam null"})," -- Rust n\xe3o tem null; valores opcionais usam ",(0,i.jsx)(e.code,{children:"Option<T>"}),". Swift e Zig usam tipos opcionais como mecanismo principal: em Swift, ",(0,i.jsx)(e.code,{children:"String?"})," \xe9 distinto de ",(0,i.jsx)(e.code,{children:"String"}),", e o desempacotamento com ",(0,i.jsx)(e.code,{children:"!"})," ou ",(0,i.jsx)(e.code,{children:"if let"})," \xe9 expl\xedcito. O ",(0,i.jsx)(e.code,{children:"?T"})," do Zig for\xe7a ",(0,i.jsx)(e.code,{children:"orelse"})," ou ",(0,i.jsx)(e.code,{children:"if"}),' para tratar null. Isso evita o "erro de um bilh\xe3o de d\xf3lares" das desrefer\xeancias nulas. Python, JavaScript, Java e C permitem ',(0,i.jsx)(e.code,{children:"null"}),"/",(0,i.jsx)(e.code,{children:"None"}),"/",(0,i.jsx)(e.code,{children:"undefined"})," em qualquer lugar, levando a ",(0,i.jsx)(e.code,{children:"NullPointerException"})," ou ",(0,i.jsx)(e.code,{children:"TypeError"})," em tempo de execu\xe7\xe3o. Se eliminar bugs de null \xe9 prioridade, escolha Rust; Swift e Zig oferecem tratamento forte de opcionais com menos rigidez que Rust."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Navega\xe7\xe3o segura"})," -- Encadeamento opcional (",(0,i.jsx)(e.code,{children:"?."}),") em JavaScript, PHP, C#, Swift e Ruby previne erros de desrefer\xeancia nula ao percorrer estruturas aninhadas. Por exemplo, ",(0,i.jsx)(e.code,{children:"user?.address?.city"})," retorna ",(0,i.jsx)(e.code,{children:"undefined"})," ou ",(0,i.jsx)(e.code,{children:"nil"})," se qualquer elo for null em vez de lan\xe7ar exce\xe7\xe3o. O ",(0,i.jsx)(e.code,{children:"arr?.[0]"})," e ",(0,i.jsx)(e.code,{children:"func?.()"})," do JavaScript estendem isso para arrays e chamadas. Sem ",(0,i.jsx)(e.code,{children:"?."}),", voc\xea escreve ",(0,i.jsx)(e.code,{children:"user && user.address && user.address.city"})," (JavaScript) ou verifica\xe7\xf5es ",(0,i.jsx)(e.code,{children:"if"})," aninhadas. Go n\xe3o tem ",(0,i.jsx)(e.code,{children:"?."}),"; voc\xea verifica ",(0,i.jsx)(e.code,{children:"if user != nil && user.Address != nil { city = user.Address.City }"}),". Prefira ",(0,i.jsx)(e.code,{children:"?."})," ao trabalhar com dados profundamente aninhados e fracamente tipados (APIs, configura\xe7\xf5es)."]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Atribui\xe7\xe3o com coalesc\xeancia nula"})," -- JavaScript (",(0,i.jsx)(e.code,{children:'x ??= "default"'}),"), PHP (",(0,i.jsx)(e.code,{children:'$name ??= "default"'}),") e C# (",(0,i.jsx)(e.code,{children:'name ??= "default"'}),") atribuem um padr\xe3o apenas quando a vari\xe1vel \xe9 null ou undefined. Isso mant\xe9m o c\xf3digo conciso ao inicializar campos opcionais. Go e Rust exigem ",(0,i.jsx)(e.code,{children:"if"})," ou ",(0,i.jsx)(e.code,{children:"match"})," expl\xedcitos. Use ",(0,i.jsx)(e.code,{children:"??="})," quando tiver configura\xe7\xe3o opcional ou padr\xf5es lazy; em Go e Rust, use padr\xf5es ",(0,i.jsx)(e.code,{children:"Option"}),"/",(0,i.jsx)(e.code,{children:"if"})," para maior clareza."]}),"\n"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);