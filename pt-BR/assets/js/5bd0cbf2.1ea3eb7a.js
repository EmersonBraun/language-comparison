"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[365],{2318(n,e,a){a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"classes-oop","title":"Classes e POO","description":"Classes, heran\xe7a, interfaces e polimorfismo comparados em 12 linguagens de programa\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/classes-oop.md","sourceDirName":".","slug":"/classes-oop","permalink":"/language-comparison/pt-BR/docs/classes-oop","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/classes-oop.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"description":"Classes, heran\xe7a, interfaces e polimorfismo comparados em 12 linguagens de programa\xe7\xe3o","keywords":["classes","POO","heran\xe7a","interfaces","polimorfismo","orienta\xe7\xe3o a objetos"]},"sidebar":"tutorialSidebar","previous":{"title":"Maps & Dictionaries","permalink":"/language-comparison/pt-BR/docs/maps-dictionaries"},"next":{"title":"Generics & Templates","permalink":"/language-comparison/pt-BR/docs/generics-templates"}}');var o=a(4848),i=a(8453),t=a(6153);const r={sidebar_position:15,description:"Classes, heran\xe7a, interfaces e polimorfismo comparados em 12 linguagens de programa\xe7\xe3o",keywords:["classes","POO","heran\xe7a","interfaces","polimorfismo","orienta\xe7\xe3o a objetos"]},l="Classes e POO",c={},m=[{value:"Defini\xe7\xe3o de Classe e Instancia\xe7\xe3o",id:"defini\xe7\xe3o-de-classe-e-instancia\xe7\xe3o",level:2},{value:"Interfaces e Polimorfismo",id:"interfaces-e-polimorfismo",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"classes-e-poo",children:"Classes e POO"})}),"\n",(0,o.jsx)(e.p,{children:"Conceitos de Programa\xe7\xe3o Orientada a Objetos variam entre linguagens. Veja como classes, heran\xe7a, interfaces e polimorfismo funcionam em diferentes linguagens."}),"\n","\n",(0,o.jsx)(e.h2,{id:"defini\xe7\xe3o-de-classe-e-instancia\xe7\xe3o",children:"Defini\xe7\xe3o de Classe e Instancia\xe7\xe3o"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// ES6 Classes\nclass Person {\n  constructor(name, age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  greet() {\n      return `Hello, I\'m ${this.name}`;\n  }\n}\n\n// Instantiation\nconst person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  constructor(name, age, school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  study() {\n      return `${this.name} is studying`;\n  }\n}'},{name:"PHP",lang:"php",code:'<?php\n// Class definition\nclass Person {\n  private $name;\n  private $age;\n  \n  public function __construct($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n  }\n  \n  public function greet() {\n      return "Hello, I\'m " . $this->name;\n  }\n}\n\n// Instantiation\n$person = new Person("John", 30);\n\n// Inheritance\nclass Student extends Person {\n  private $school;\n  \n  public function __construct($name, $age, $school) {\n      parent::__construct($name, $age);\n      $this->school = $school;\n  }\n  \n  public function study() {\n      return $this->name . " is studying";\n  }\n}'},{name:"Rust",lang:"rust",code:'// Structs with impl blocks\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n      Person { name, age }\n  }\n  \n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}\n\n// Traits (similar to interfaces)\ntrait Greetable {\n  fn greet(&self) -> String;\n}\n\nimpl Greetable for Person {\n  fn greet(&self) -> String {\n      format!("Hello, I\'m {}", self.name)\n  }\n}'},{name:"Go",lang:"go",code:'// Structs with methods\ntype Person struct {\n  name string\n  age  int\n}\n\nfunc NewPerson(name string, age int) *Person {\n  return &Person{name: name, age: age}\n}\n\nfunc (p *Person) Greet() string {\n  return fmt.Sprintf("Hello, I\'m %s", p.name)\n}\n\n// Interfaces\ntype Greetable interface {\n  Greet() string\n}\n\n// Embedding (composition)\ntype Student struct {\n  Person\n  school string\n}'},{name:"Python",lang:"python",code:'# Class definition\nclass Person:\n  def __init__(self, name, age):\n      self.name = name\n      self.age = age\n  \n  def greet(self):\n      return f"Hello, I\'m {self.name}"\n\n# Instantiation\nperson = Person("John", 30)\n\n# Inheritance\nclass Student(Person):\n  def __init__(self, name, age, school):\n      super().__init__(name, age)\n      self.school = school\n  \n  def study(self):\n      return f"{self.name} is studying"'},{name:"Zig",lang:"zig",code:'// Structs with methods\nconst Person = struct {\n  name: []const u8,\n  age: u32,\n  \n  pub fn init(name: []const u8, age: u32) Person {\n      return Person{\n          .name = name,\n          .age = age,\n      };\n  }\n  \n  pub fn greet(self: Person) []const u8 {\n      return "Hello, I\'m " ++ self.name;\n  }\n};\n\n// Interfaces (using function pointers)\nconst Greetable = struct {\n  greet: fn (*const anyopaque) []const u8,\n};'},{name:"C#",lang:"csharp",code:'// Class definition\npublic class Person\n{\n  private string name;\n  private int age;\n  \n  public Person(string name, int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public virtual string Greet()\n  {\n      return $"Hello, I\'m {name}";\n  }\n}\n\n// Instantiation\nvar person = new Person("John", 30);\n\n// Inheritance\npublic class Student : Person\n{\n  private string school;\n  \n  public Student(string name, int age, string school) \n      : base(name, age)\n  {\n      this.school = school;\n  }\n  \n  public override string Greet()\n  {\n      return base.Greet() + $" and I study at {school}";\n  }\n}'},{name:"C++",lang:"cpp",code:'// Class definition\nclass Person {\nprivate:\n  std::string name;\n  int age;\n  \npublic:\n  Person(const std::string& name, int age) \n      : name(name), age(age) {}\n  \n  virtual std::string greet() const {\n      return "Hello, I\'m " + name;\n  }\n  \n  virtual ~Person() = default;\n};\n\n// Instantiation\nPerson person("John", 30);\n\n// Inheritance\nclass Student : public Person {\nprivate:\n  std::string school;\n  \npublic:\n  Student(const std::string& name, int age, \n          const std::string& school)\n      : Person(name, age), school(school) {}\n  \n  std::string greet() const override {\n      return Person::greet() + " and I study at " + school;\n  }\n};'},{name:"C",lang:"c",code:'// Struct with function pointers (OOP-like)\ntypedef struct {\n  char name[50];\n  int age;\n  void (*greet)(struct Person*);\n} Person;\n\nvoid person_greet(Person* self) {\n  printf("Hello, I\'m %s\\n", self->name);\n}\n\nPerson* person_new(const char* name, int age) {\n  Person* p = malloc(sizeof(Person));\n  strcpy(p->name, name);\n  p->age = age;\n  p->greet = person_greet;\n  return p;\n}'},{name:"Java",lang:"java",code:'// Class definition\npublic class Person {\n  private String name;\n  private int age;\n  \n  public Person(String name, int age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public String greet() {\n      return "Hello, I\'m " + name;\n  }\n}\n\n// Instantiation\nPerson person = new Person("John", 30);\n\n// Inheritance\npublic class Student extends Person {\n  private String school;\n  \n  public Student(String name, int age, String school) {\n      super(name, age);\n      this.school = school;\n  }\n  \n  @Override\n  public String greet() {\n      return super.greet() + " and I study at " + school;\n  }\n}'},{name:"Ruby",lang:"ruby",code:'# Class definition\nclass Person\n  def initialize(name, age)\n      @name = name\n      @age = age\n  end\n  \n  def greet\n      "Hello, I\'m #{@name}"\n  end\nend\n\n# Instantiation\nperson = Person.new("John", 30)\n\n# Inheritance\nclass Student < Person\n  def initialize(name, age, school)\n      super(name, age)\n      @school = school\n  end\n  \n  def study\n      "#{@name} is studying"\n  end\nend'},{name:"Swift",lang:"swift",code:'// Class definition\nclass Person {\n  private var name: String\n  private var age: Int\n  \n  init(name: String, age: Int) {\n      self.name = name\n      self.age = age\n  }\n  \n  func greet() -> String {\n      "Hello, I\'m \\(name)"\n  }\n}\n\n// Instantiation\nlet person = Person(name: "John", age: 30)\n\n// Inheritance\nclass Student: Person {\n  private var school: String\n  \n  init(name: String, age: Int, school: String) {\n      self.school = school\n      super.init(name: name, age: age)\n  }\n  \n  override func greet() -> String {\n      super.greet() + " and I study at \\(school)"\n  }\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"interfaces-e-polimorfismo",children:"Interfaces e Polimorfismo"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// No native interfaces, use duck typing\nclass Dog {\n  makeSound() {\n      return "Woof!";\n  }\n}\n\nclass Cat {\n  makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(animal) {\n  return animal.makeSound();\n}\n\n// TypeScript interfaces\ninterface Animal {\n  makeSound(): string;\n}'},{name:"PHP",lang:"php",code:'<?php\n// Interfaces\ninterface Animal {\n  public function makeSound(): string;\n}\n\nclass Dog implements Animal {\n  public function makeSound(): string {\n      return "Woof!";\n  }\n}\n\nclass Cat implements Animal {\n  public function makeSound(): string {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\nfunction animalSound(Animal $animal): string {\n  return $animal->makeSound();\n}'},{name:"Rust",lang:"rust",code:'// Traits (interfaces)\ntrait Animal {\n  fn make_sound(&self) -> String;\n}\n\nstruct Dog;\nimpl Animal for Dog {\n  fn make_sound(&self) -> String {\n      "Woof!".to_string()\n  }\n}\n\nstruct Cat;\nimpl Animal for Cat {\n  fn make_sound(&self) -> String {\n      "Meow!".to_string()\n  }\n}\n\n// Polymorphism\nfn animal_sound(animal: &dyn Animal) -> String {\n  animal.make_sound()\n}'},{name:"Go",lang:"go",code:'// Interfaces\ntype Animal interface {\n  MakeSound() string\n}\n\ntype Dog struct{}\nfunc (d Dog) MakeSound() string {\n  return "Woof!"\n}\n\ntype Cat struct{}\nfunc (c Cat) MakeSound() string {\n  return "Meow!"\n}\n\n// Polymorphism\nfunc AnimalSound(a Animal) string {\n  return a.MakeSound()\n}'},{name:"Python",lang:"python",code:'# Duck typing (no explicit interfaces)\nclass Dog:\n  def make_sound(self):\n      return "Woof!"\n\nclass Cat:\n  def make_sound(self):\n      return "Meow!"\n\n# Polymorphism\ndef animal_sound(animal):\n  return animal.make_sound()\n\n# ABC (Abstract Base Classes)\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n  @abstractmethod\n  def make_sound(self):\n      pass'},{name:"Zig",lang:"zig",code:'// Function pointers (interface-like)\nconst Animal = struct {\n  make_sound: fn (*const anyopaque) []const u8,\n};\n\nconst Dog = struct {\n  pub fn make_sound(self: *const Dog) []const u8 {\n      return "Woof!";\n  }\n};\n\n// Polymorphism through function pointers\nfn animal_sound(animal: Animal) []const u8 {\n  return animal.make_sound(animal.self);\n}'},{name:"C#",lang:"csharp",code:'// Interfaces\npublic interface IAnimal\n{\n  string MakeSound();\n}\n\npublic class Dog : IAnimal\n{\n  public string MakeSound() => "Woof!";\n}\n\npublic class Cat : IAnimal\n{\n  public string MakeSound() => "Meow!";\n}\n\n// Polymorphism\npublic static string AnimalSound(IAnimal animal)\n{\n  return animal.MakeSound();\n}'},{name:"C++",lang:"cpp",code:'// Abstract classes\nclass Animal {\npublic:\n  virtual std::string makeSound() = 0;\n  virtual ~Animal() = default;\n};\n\nclass Dog : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Woof!";\n  }\n};\n\nclass Cat : public Animal {\npublic:\n  std::string makeSound() override {\n      return "Meow!";\n  }\n};\n\n// Polymorphism\nstd::string animalSound(Animal* animal) {\n  return animal->makeSound();\n}'},{name:"C",lang:"c",code:'// Function pointers in structs\ntypedef struct {\n  void* self;\n  char* (*makeSound)(void*);\n} Animal;\n\nchar* dog_makeSound(void* self) {\n  return "Woof!";\n}\n\nchar* cat_makeSound(void* self) {\n  return "Meow!";\n}\n\n// Polymorphism\nchar* animalSound(Animal* animal) {\n  return animal->makeSound(animal->self);\n}'},{name:"Java",lang:"java",code:'// Interfaces\npublic interface Animal {\n  String makeSound();\n}\n\npublic class Dog implements Animal {\n  @Override\n  public String makeSound() {\n      return "Woof!";\n  }\n}\n\npublic class Cat implements Animal {\n  @Override\n  public String makeSound() {\n      return "Meow!";\n  }\n}\n\n// Polymorphism\npublic static String animalSound(Animal animal) {\n  return animal.makeSound();\n}'},{name:"Ruby",lang:"ruby",code:'# Modules as interfaces\nmodule Animal\n  def make_sound\n      raise NotImplementedError\n  end\nend\n\nclass Dog\n  include Animal\n  \n  def make_sound\n      "Woof!"\n  end\nend\n\nclass Cat\n  include Animal\n  \n  def make_sound\n      "Meow!"\n  end\nend\n\n# Polymorphism\ndef animal_sound(animal)\n  animal.make_sound\nend'},{name:"Swift",lang:"swift",code:'// Protocols (interfaces)\nprotocol Animal {\n  func makeSound() -> String\n}\n\nclass Dog: Animal {\n  func makeSound() -> String {\n      "Woof!"\n  }\n}\n\nclass Cat: Animal {\n  func makeSound() -> String {\n      "Meow!"\n  }\n}\n\n// Polymorphism\nfunc animalSound(_ animal: Animal) -> String {\n  animal.makeSound()\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Modelos de heran\xe7a"})," \u2014 Java, C#, C++, PHP, Ruby, Swift e JavaScript usam heran\xe7a simples baseada em classes com sintaxe ",(0,o.jsx)(e.code,{children:"extends"})," ou ",(0,o.jsx)(e.code,{children:":"}),"; por exemplo, ",(0,o.jsx)(e.code,{children:"class Student extends Person"})," em Java ou ",(0,o.jsx)(e.code,{children:"class Student(Person)"})," em Python. Go rejeita heran\xe7a completamente e usa embedding: ",(0,o.jsx)(e.code,{children:"type Student struct { Person; school string }"})," incorpora os campos e m\xe9todos de Person diretamente. Rust n\xe3o tem heran\xe7a alguma \u2014 apenas traits que os tipos implementam. Escolha Go ou Rust quando quiser composi\xe7\xe3o ao inv\xe9s de hierarquia; escolha Java/C#/Swift quando precisar de taxonomias de classe claras e sobrescrita de m\xe9todos."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Padr\xf5es de interface"})," \u2014 Java, C#, Swift e PHP exigem declara\xe7\xf5es expl\xedcitas de ",(0,o.jsx)(e.code,{children:"implements"}),": ",(0,o.jsx)(e.code,{children:"class Dog implements Animal"}),". Go usa tipagem estrutural: qualquer tipo com um m\xe9todo ",(0,o.jsx)(e.code,{children:"MakeSound() string"})," satisfaz ",(0,o.jsx)(e.code,{children:"type Animal interface { MakeSound() string }"})," sem declar\xe1-lo. Python e Ruby dependem de duck typing \u2014 se tem ",(0,o.jsx)(e.code,{children:"make_sound()"}),", funciona. As traits do Rust funcionam como interfaces: ",(0,o.jsx)(e.code,{children:"impl Animal for Dog { fn make_sound(&self) -> String { ... } }"}),". C e Zig simulam interfaces via structs de ponteiros de fun\xe7\xe3o. Prefira interfaces impl\xedcitas estilo Go para flexibilidade; prefira interfaces expl\xedcitas quando quiser garantia de contrato em tempo de compila\xe7\xe3o."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Filosofia de POO"})," \u2014 POO tradicional (Java, C#, C++) \xe9 centrada em classes, hierarquias de heran\xe7a e ",(0,o.jsx)(e.code,{children:"virtual"}),"/",(0,o.jsx)(e.code,{children:"override"}),' para polimorfismo. Go e Rust favorecem composi\xe7\xe3o e traits: "prefira composi\xe7\xe3o ao inv\xe9s de heran\xe7a." JavaScript e Python s\xe3o multiparadigma \u2014 voc\xea pode usar classes ou evit\xe1-las completamente. Se voc\xea est\xe1 construindo modelos de dom\xednio com hierarquias claras (ex.: ',(0,o.jsx)(e.code,{children:"Vehicle"})," \u2192 ",(0,o.jsx)(e.code,{children:"Car"})," \u2192 ",(0,o.jsx)(e.code,{children:"ElectricCar"}),"), Java/C#/Swift se destacam. Se quer designs planos e combin\xe1veis com cerim\xf4nia m\xednima, escolha Go ou Rust."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Mem\xf3ria e ciclo de vida"})," \u2014 C++ e Rust exigem aten\xe7\xe3o expl\xedcita ao ciclo de vida do objeto: C++ usa destrutores ",(0,o.jsx)(e.code,{children:"virtual"})," e RAII; o ownership do Rust previne refer\xeancias pendentes. Java, C#, PHP, Ruby, Python e JavaScript usam coleta de lixo, ent\xe3o voc\xea raramente gerencia o tempo de vida do objeto. Go usa GC leve. Para programa\xe7\xe3o de sistemas ou c\xf3digo cr\xedtico em performance, Rust e C++ d\xe3o controle; para desenvolvimento r\xe1pido, linguagens com coleta de lixo reduzem a carga cognitiva."]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);