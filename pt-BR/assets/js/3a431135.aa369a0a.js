"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[334],{5429(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"maps-dictionaries","title":"Maps e Dicion\xe1rios","description":"Hash maps, dicion\xe1rios e arrays associativos comparados em 12 linguagens de programa\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/maps-dictionaries.md","sourceDirName":".","slug":"/maps-dictionaries","permalink":"/language-comparison/pt-BR/docs/maps-dictionaries","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/maps-dictionaries.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"description":"Hash maps, dicion\xe1rios e arrays associativos comparados em 12 linguagens de programa\xe7\xe3o","keywords":["maps","dicion\xe1rios","hash maps","arrays associativos","chave-valor"]},"sidebar":"tutorialSidebar","previous":{"title":"Objects & Structs","permalink":"/language-comparison/pt-BR/docs/objects-structs"},"next":{"title":"Classes & OOP","permalink":"/language-comparison/pt-BR/docs/classes-oop"}}');var t=a(4848),i=a(8453),r=a(6153);const o={sidebar_position:14,description:"Hash maps, dicion\xe1rios e arrays associativos comparados em 12 linguagens de programa\xe7\xe3o",keywords:["maps","dicion\xe1rios","hash maps","arrays associativos","chave-valor"]},c="Maps e Dicion\xe1rios",d={},p=[{value:"Criando e Acessando Maps",id:"criando-e-acessando-maps",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"maps-e-dicion\xe1rios",children:"Maps e Dicion\xe1rios"})}),"\n",(0,t.jsx)(n.p,{children:"Maps (tamb\xe9m conhecidos como dicion\xe1rios, hash maps ou arrays associativos) armazenam pares chave-valor. Veja como diferentes linguagens os manipulam."}),"\n","\n",(0,t.jsx)(n.h2,{id:"criando-e-acessando-maps",children:"Criando e Acessando Maps"}),"\n",(0,t.jsx)(r.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Object (string keys only)\nconst obj = { name: "John", age: 30 };\nobj.name;         // "John"\nobj["age"];       // 30\n\n// Map (any key type)\nconst map = new Map();\nmap.set("key", "value");\nmap.set(42, "number key");\nmap.set(obj, "object key");\n\nmap.get("key");       // "value"\nmap.has("key");       // true\nmap.size;             // 3\nmap.delete("key");\n\n// Initialize Map\nconst map2 = new Map([\n  ["a", 1], ["b", 2], ["c", 3]\n]);\n\n// WeakMap (keys are garbage collected)\nconst weakMap = new WeakMap();\nweakMap.set(obj, "data");'},{name:"PHP",lang:"php",code:'<?php\n// Associative array\n$map = [\n  "name" => "John",\n  "age" => 30,\n];\n\n$map["name"];         // "John"\n$map["city"] = "NYC"; // Add\nisset($map["name"]);  // true\nunset($map["age"]);   // Delete\ncount($map);          // Size\n\n// Array functions\narray_key_exists("name", $map);  // true\narray_keys($map);       // ["name", "city"]\narray_values($map);     // ["John", "NYC"]\n\n// Merge\n$merged = array_merge($map1, $map2);\n\n// SplObjectStorage (object keys)\n$storage = new SplObjectStorage();\n$storage[$obj] = "data";'},{name:"Rust",lang:"rust",code:'use std::collections::HashMap;\n\n// Create\nlet mut map = HashMap::new();\nmap.insert("name", "John");\nmap.insert("city", "NYC");\n\n// Access\nmap.get("name");        // Some("John")\nmap["name"];            // "John" (panics if missing)\nmap.contains_key("name"); // true\n\n// Initialize with collect\nlet map: HashMap<&str, i32> = vec![\n  ("a", 1), ("b", 2), ("c", 3),\n].into_iter().collect();\n\n// Entry API (insert if missing)\nmap.entry("count")\n .or_insert(0);\n*map.entry("count").or_insert(0) += 1;\n\n// Remove\nmap.remove("name");\nmap.len();  // Size\n\n// BTreeMap (ordered)\nuse std::collections::BTreeMap;\nlet ordered = BTreeMap::new();'},{name:"Go",lang:"go",code:'// Create\nm := map[string]string{\n  "name": "John",\n  "city": "NYC",\n}\n\n// Access\nname := m["name"]         // "John"\nvalue, ok := m["missing"] // "", false\n\n// Check existence\nif val, ok := m["name"]; ok {\n  fmt.Println(val)\n}\n\n// Add / Update\nm["age"] = "30"\n\n// Delete\ndelete(m, "age")\n\n// Size\nlen(m)\n\n// Make with capacity\nm2 := make(map[string]int, 100)\n\n// Iterate\nfor key, value := range m {\n  fmt.Printf("%s: %s\\n", key, value)\n}'},{name:"Python",lang:"python",code:'# Dict literal\nd = {"name": "John", "age": 30}\n\n# Access\nd["name"]               # "John"\nd.get("name")           # "John"\nd.get("missing", "default")  # "default"\n\n# Add / Update\nd["city"] = "NYC"\nd.update({"city": "NYC", "zip": "10001"})\n\n# Delete\ndel d["age"]\nd.pop("age", None)  # Remove with default\n\n# Check\n"name" in d          # True\nlen(d)               # Size\n\n# Methods\nd.keys()             # dict_keys\nd.values()           # dict_values\nd.items()            # dict_items\n\n# Dict comprehension\nsquares = {x: x**2 for x in range(5)}\n\n# defaultdict\nfrom collections import defaultdict\ndd = defaultdict(list)\ndd["key"].append(1)  # Auto-creates list\n\n# OrderedDict (maintains insertion order)\n# Note: regular dict is ordered since Python 3.7'},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// HashMap\nvar map = std.StringHashMap(i32).init(allocator);\ndefer map.deinit();\n\n// Insert\ntry map.put("name", 42);\ntry map.put("age", 30);\n\n// Access\nconst value = map.get("name");  // ?i32\nif (map.get("name")) |v| {\n  std.debug.print("{d}\\n", .{v});\n}\n\n// Remove\n_ = map.remove("name");\n\n// Contains\nconst exists = map.contains("name");\n\n// Size\nconst size = map.count();\n\n// Iterate\nvar it = map.iterator();\nwhile (it.next()) |entry| {\n  std.debug.print("{s}: {d}\\n",\n      .{entry.key_ptr.*, entry.value_ptr.*});\n}\n\n// AutoHashMap (auto-managed)\nvar auto_map = std.AutoHashMap(i32, []const u8).init(allocator);'},{name:"C#",lang:"csharp",code:'// Dictionary\nvar dict = new Dictionary<string, string>\n{\n  ["name"] = "John",\n  ["city"] = "NYC",\n};\n\n// Access\ndict["name"];                // "John"\ndict.TryGetValue("name", out var value); // true\ndict.ContainsKey("name");    // true\n\n// Add / Update\ndict["age"] = "30";\ndict.Add("zip", "10001");   // Throws if exists\n\n// Remove\ndict.Remove("age");\ndict.Count;                  // Size\n\n// Iterate\nforeach (var (key, val) in dict)\n{\n  Console.WriteLine($"{key}: {val}");\n}\n\n// SortedDictionary (ordered by key)\nvar sorted = new SortedDictionary<string, int>();\n\n// ConcurrentDictionary (thread-safe)\nvar concurrent = new ConcurrentDictionary<string, int>();'},{name:"C++",lang:"cpp",code:'#include <map>\n#include <unordered_map>\n\n// unordered_map (hash map)\nstd::unordered_map<std::string, int> map;\nmap["name"] = 42;\nmap["age"] = 30;\n\n// Access\nmap["name"];                 // 42\nmap.at("name");              // 42 (throws if missing)\nmap.count("name");           // 1 or 0\nmap.find("name") != map.end(); // true\n\n// Insert\nmap.insert({"city", 1});\nmap.emplace("zip", 2);\n\n// Remove\nmap.erase("age");\nmap.size();\n\n// Initialize\nstd::unordered_map<std::string, int> m = {\n  {"a", 1}, {"b", 2}, {"c", 3}\n};\n\n// std::map (ordered, tree-based)\nstd::map<std::string, int> ordered;'},{name:"C",lang:"c",code:"// No built-in hash map\n// Common approaches:\n\n// Simple struct array\n#define MAX_ENTRIES 100\ntypedef struct {\n  char key[50];\n  int value;\n} Entry;\n\nEntry map[MAX_ENTRIES];\nint map_size = 0;\n\n// Add\nvoid map_put(const char* key, int value) {\n  strcpy(map[map_size].key, key);\n  map[map_size].value = value;\n  map_size++;\n}\n\n// Find (linear search)\nint* map_get(const char* key) {\n  for (int i = 0; i < map_size; i++) {\n      if (strcmp(map[i].key, key) == 0)\n          return &map[i].value;\n  }\n  return NULL;\n}\n\n// For real projects, use libraries like\n// uthash, glib GHashTable, etc."},{name:"Java",lang:"java",code:'// HashMap\nMap<String, Integer> map = new HashMap<>();\nmap.put("name", 42);\nmap.put("age", 30);\n\n// Access\nmap.get("name");           // 42\nmap.getOrDefault("missing", 0); // 0\nmap.containsKey("name");   // true\n\n// Add / Update\nmap.put("city", 1);\nmap.putIfAbsent("city", 2); // Won\'t overwrite\n\n// Remove\nmap.remove("age");\nmap.size();\n\n// Initialize (Java 9+)\nvar m = Map.of("a", 1, "b", 2, "c", 3);\n\n// Iterate\nfor (var entry : map.entrySet()) {\n  System.out.println(entry.getKey() + ": " + entry.getValue());\n}\nmap.forEach((k, v) -> System.out.println(k + ": " + v));\n\n// TreeMap (sorted)\nMap<String, Integer> sorted = new TreeMap<>();\n\n// ConcurrentHashMap (thread-safe)\nMap<String, Integer> concurrent = new ConcurrentHashMap<>();'},{name:"Ruby",lang:"ruby",code:'# Hash literal\nhash = { name: "John", age: 30 }\nhash2 = { "name" => "John", "age" => 30 }\n\n# Access\nhash[:name]              # "John"\nhash.fetch(:name)        # "John" (raises if missing)\nhash.fetch(:missing, "default")  # "default"\n\n# Add / Update\nhash[:city] = "NYC"\nhash.merge!({ zip: "10001" })\n\n# Delete\nhash.delete(:age)\nhash.size                # Size\n\n# Check\nhash.key?(:name)         # true\nhash.value?("John")      # true\n\n# Iterate\nhash.each { |k, v| puts "#{k}: #{v}" }\n\n# Transform\nhash.map { |k, v| [k, v.to_s] }.to_h\nhash.select { |k, v| v.is_a?(String) }\nhash.transform_values { |v| v.to_s }\n\n# Dig (nested access)\ndata = { user: { address: { city: "NYC" } } }\ndata.dig(:user, :address, :city)  # "NYC"'},{name:"Swift",lang:"swift",code:'// Dictionary literal\nvar dict: [String: Int] = [\n  "name": 42,\n  "age": 30,\n]\n\n// Access (returns Optional)\ndict["name"]               // Optional(42)\ndict["missing"]            // nil\ndict["missing", default: 0]  // 0\n\n// Add / Update\ndict["city"] = 1\ndict.updateValue(2, forKey: "city")\n\n// Remove\ndict.removeValue(forKey: "age")\ndict.count                 // Size\n\n// Check\ndict.keys.contains("name")  // true\n\n// Iterate\nfor (key, value) in dict {\n  print("\\(key): \\(value)")\n}\n\n// Transform\nlet mapped = dict.mapValues { $0 * 2 }\nlet filtered = dict.filter { $0.value > 10 }\n\n// Grouping\nlet grouped = Dictionary(grouping: items) { $0.category }'}]}),"\n",(0,t.jsx)(n.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Suporte a sintaxe nativa"})," -- JavaScript, Python, Ruby, Go e Swift possuem sintaxe dedicada para literais de map/dict (ex.: ",(0,t.jsx)(n.code,{children:'{"name": "John"}'})," em Python, ",(0,t.jsx)(n.code,{children:'map[string]string{"name": "John"}'})," em Go). C n\xe3o possui hash map nativo e requer bibliotecas como uthash ou implementa\xe7\xe3o manual. A sintaxe literal melhora a legibilidade e reduz c\xf3digo repetitivo. Se voc\xea trabalha intensamente com dados chave-valor (configura\xe7\xe3o, caches, JSON), escolha uma linguagem com suporte nativo a maps; para C, planeje integrar uma biblioteca desde o in\xedcio."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Ordenado vs n\xe3o ordenado"})," -- Dicts do Python (3.7+), arrays do PHP e ",(0,t.jsx)(n.code,{children:"Map"})," do JavaScript preservam a ordem de inser\xe7\xe3o. O ",(0,t.jsx)(n.code,{children:"HashMap"})," do Rust \xe9 n\xe3o ordenado; use ",(0,t.jsx)(n.code,{children:"BTreeMap"})," para itera\xe7\xe3o ordenada por chave. Maps do Go s\xe3o n\xe3o ordenados; o ",(0,t.jsx)(n.code,{children:"HashMap"})," do Java \xe9 n\xe3o ordenado (use ",(0,t.jsx)(n.code,{children:"LinkedHashMap"})," para ordem de inser\xe7\xe3o). A ordem importa para sa\xedda reproduz\xedvel, caches LRU ou quando a ordem carrega significado. Prefira Python, PHP ou ",(0,t.jsx)(n.code,{children:"Map"})," do JavaScript quando a ordem for importante; ",(0,t.jsx)(n.code,{children:"BTreeMap"})," do Rust quando precisar de chaves ordenadas."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Padr\xf5es de acesso seguro"})," -- O ",(0,t.jsx)(n.code,{children:'value, ok := m["key"]'})," do Go retorna um booleano para exist\xeancia; o subscript opcional do Swift (",(0,t.jsx)(n.code,{children:'dict["key"]'}),") retorna ",(0,t.jsx)(n.code,{children:"nil"})," para chaves ausentes; o ",(0,t.jsx)(n.code,{children:'dict.get("key", default)'})," do Python e o ",(0,t.jsx)(n.code,{children:"hash.fetch(:key, default)"})," do Ruby evitam exce\xe7\xf5es. A indexa\xe7\xe3o direta no Rust (",(0,t.jsx)(n.code,{children:'map["key"]'}),") causa panic se a chave estiver ausente; em C++ ",(0,t.jsx)(n.code,{children:'map["key"]'})," cria uma entrada com valor padr\xe3o. Use acesso seguro quando as chaves podem estar ausentes (ex.: entrada do usu\xe1rio, configura\xe7\xe3o opcional); indexa\xe7\xe3o direta quando as chaves s\xe3o garantidas."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tipos de chave e valor"})," -- Objetos simples do JavaScript suportam apenas chaves string; ",(0,t.jsx)(n.code,{children:"Map"})," permite qualquer tipo, incluindo objetos. Dicts do Python exigem chaves hashable (ex.: strings, n\xfameros, tuplas). Maps do Go exigem chaves compar\xe1veis. O ",(0,t.jsx)(n.code,{children:"HashMap"})," do Rust precisa de chaves que implementem ",(0,t.jsx)(n.code,{children:"Hash"})," e ",(0,t.jsx)(n.code,{children:"Eq"}),". Escolha ",(0,t.jsx)(n.code,{children:"Map"})," em JavaScript quando precisar de chaves n\xe3o-string; em Rust, considere ",(0,t.jsx)(n.code,{children:"BTreeMap"})," para tipos de chave personalizados que n\xe3o implementam ",(0,t.jsx)(n.code,{children:"Hash"})," adequadamente."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Seguran\xe7a em threads e concorr\xeancia"})," -- O ",(0,t.jsx)(n.code,{children:"ConcurrentHashMap"})," do Java e o ",(0,t.jsx)(n.code,{children:"ConcurrentDictionary"})," do C# s\xe3o constru\xeddos para acesso concorrente. Maps do Go n\xe3o s\xe3o seguros para escritas concorrentes; use ",(0,t.jsx)(n.code,{children:"sync.Map"})," ou mutexes. O modelo de ownership do Rust previne data races sem um tipo separado de map concorrente. Para estado mut\xe1vel compartilhado entre threads, prefira Java ou C#; em Go, envolva maps com mutexes ou use ",(0,t.jsx)(n.code,{children:"sync.Map"}),"; em Rust, use channels ou ",(0,t.jsx)(n.code,{children:"Arc<Mutex<HashMap>>"}),"."]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);