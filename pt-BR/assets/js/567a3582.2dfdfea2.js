"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[812],{1484(n,e,s){s.r(e),s.d(e,{assets:()=>p,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"objects-structs","title":"Objetos & Structs","description":"Objetos, structs e tipos de dados estruturados comparados em 12 linguagens de programa\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/objects-structs.md","sourceDirName":".","slug":"/objects-structs","permalink":"/language-comparison/pt-BR/docs/objects-structs","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/objects-structs.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"description":"Objetos, structs e tipos de dados estruturados comparados em 12 linguagens de programa\xe7\xe3o","keywords":["objetos","structs","estruturas","propriedades","m\xe9todos"]},"sidebar":"tutorialSidebar","previous":{"title":"Strings","permalink":"/language-comparison/pt-BR/docs/strings"},"next":{"title":"Maps & Dictionaries","permalink":"/language-comparison/pt-BR/docs/maps-dictionaries"}}');var o=s(4848),a=s(8453),t=s(6153);const i={sidebar_position:13,description:"Objetos, structs e tipos de dados estruturados comparados em 12 linguagens de programa\xe7\xe3o",keywords:["objetos","structs","estruturas","propriedades","m\xe9todos"]},c="Objetos & Structs",p={},l=[{value:"Cria\xe7\xe3o de Objetos/Structs",id:"cria\xe7\xe3o-de-objetosstructs",level:2},{value:"Trabalhando com Objetos",id:"trabalhando-com-objetos",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"objetos--structs",children:"Objetos & Structs"})}),"\n",(0,o.jsx)(e.p,{children:"Diferentes linguagens t\xeam diferentes formas de representar dados estruturados. Veja como objetos, structs e constru\xe7\xf5es similares funcionam em diferentes linguagens."}),"\n","\n",(0,o.jsx)(e.h2,{id:"cria\xe7\xe3o-de-objetosstructs",children:"Cria\xe7\xe3o de Objetos/Structs"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Object literal\nconst person = {\n  name: "John",\n  age: 30,\n  greet: function() {\n      return "Hello, " + this.name;\n  }\n};\n\n// Access properties\nperson.name;\nperson["age"];\n\n// Add properties\nperson.city = "NYC";\n\n// Object methods\nObject.keys(person);\nObject.values(person);'},{name:"PHP",lang:"php",code:"<?php\n// Associative array\n$person = [\n  'name' => 'John',\n  'age' => 30\n];\n\n// Access properties\n$person['name'];\n$person['age'];\n\n// Add properties\n$person['city'] = 'NYC';\n\n// Object (class instance)\nclass Person {\n  public $name;\n  public $age;\n  \n  public function __construct($name, $age) {\n      $this->name = $name;\n      $this->age = $age;\n  }\n}\n\n$person = new Person('John', 30);"},{name:"Rust",lang:"rust",code:'// Struct\nstruct Person {\n  name: String,\n  age: u32,\n}\n\n// Create instance\nlet person = Person {\n  name: String::from("John"),\n  age: 30,\n};\n\n// Access fields\nperson.name;\nperson.age;\n\n// Struct with methods\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n      Person { name, age }\n  }\n  \n  fn greet(&self) -> String {\n      format!("Hello, {}", self.name)\n  }\n}'},{name:"Go",lang:"go",code:'// Struct\ntype Person struct {\n  Name string\n  Age  int\n}\n\n// Create instance\nperson := Person{\n  Name: "John",\n  Age:  30,\n}\n\n// Access fields\nperson.Name\nperson.Age\n\n// Methods\nfunc (p Person) Greet() string {\n  return "Hello, " + p.Name\n}\n\n// Pointer receiver\nfunc (p *Person) SetAge(age int) {\n  p.Age = age\n}'},{name:"Python",lang:"python",code:'# Dictionary\nperson = {\n  "name": "John",\n  "age": 30\n}\n\n# Access properties\nperson["name"]\nperson.get("age")\n\n# Add properties\nperson["city"] = "NYC"\n\n# Dataclass (Python 3.7+)\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n  name: str\n  age: int\n  \n  def greet(self):\n      return f"Hello, {self.name}"\n\nperson = Person("John", 30)'},{name:"Zig",lang:"zig",code:'// Struct\nconst Person = struct {\n  name: []const u8,\n  age: u32,\n  \n  pub fn greet(self: Person) []const u8 {\n      return "Hello, " ++ self.name;\n  }\n};\n\n// Create instance\nconst person = Person{\n  .name = "John",\n  .age = 30,\n};\n\n// Access fields\nperson.name\nperson.age'},{name:"C#",lang:"csharp",code:'// Class\npublic class Person\n{\n  public string Name { get; set; }\n  public int Age { get; set; }\n  \n  public Person(string name, int age)\n  {\n      Name = name;\n      Age = age;\n  }\n  \n  public string Greet()\n  {\n      return $"Hello, {Name}";\n  }\n}\n\n// Create instance\nvar person = new Person("John", 30);\n\n// Record (C# 9+)\npublic record Person(string Name, int Age);'},{name:"C++",lang:"cpp",code:'// Struct\nstruct Person {\n  std::string name;\n  int age;\n  \n  Person(const std::string& n, int a) \n      : name(n), age(a) {}\n  \n  std::string greet() const {\n      return "Hello, " + name;\n  }\n};\n\n// Create instance\nPerson person("John", 30);\n\n// Access fields\nperson.name\nperson.age'},{name:"C",lang:"c",code:'// Struct\ntypedef struct {\n  char name[50];\n  int age;\n} Person;\n\n// Create instance\nPerson person;\nstrcpy(person.name, "John");\nperson.age = 30;\n\n// Access fields\nperson.name\nperson.age\n\n// Function to work with struct\nvoid greet(Person* p) {\n  printf("Hello, %s\\n", p->name);\n}'},{name:"Java",lang:"java",code:'// Class\npublic class Person {\n  private String name;\n  private int age;\n  \n  public Person(String name, int age) {\n      this.name = name;\n      this.age = age;\n  }\n  \n  public String getName() {\n      return name;\n  }\n  \n  public void setName(String name) {\n      this.name = name;\n  }\n  \n  public String greet() {\n      return "Hello, " + name;\n  }\n}\n\n// Create instance\nPerson person = new Person("John", 30);'},{name:"Ruby",lang:"ruby",code:'# Hash\nperson = {\n  name: "John",\n  age: 30\n}\n\n# Access properties\nperson[:name]\nperson[:age]\n\n# Add properties\nperson[:city] = "NYC"\n\n# Class\nclass Person\n  attr_accessor :name, :age\n  \n  def initialize(name, age)\n      @name = name\n      @age = age\n  end\n  \n  def greet\n      "Hello, #{@name}"\n  end\nend\n\nperson = Person.new("John", 30)'},{name:"Swift",lang:"swift",code:'// Struct\nstruct Person {\n  var name: String\n  var age: Int\n  \n  func greet() -> String {\n      "Hello, \\(name)"\n  }\n}\n\n// Create instance\nvar person = Person(name: "John", age: 30)\n\n// Access fields\nperson.name\nperson.age\n\n// Class\nclass Person {\n  var name: String\n  var age: Int\n  \n  init(name: String, age: Int) {\n      self.name = name\n      self.age = age\n  }\n  \n  func greet() -> String {\n      "Hello, \\(name)"\n  }\n}'}]}),"\n",(0,o.jsx)(e.h2,{id:"trabalhando-com-objetos",children:"Trabalhando com Objetos"}),"\n",(0,o.jsx)(t.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Object destructuring\nconst {name, age} = person;\n\n// Spread operator\nconst updated = {...person, age: 31};\n\n// Object methods\nObject.assign({}, person, {city: "NYC"});\nObject.freeze(person);  // Immutable\nObject.seal(person);    // Prevent adding/deleting\nObject.keys(person);    // ["name", "age"]\nObject.values(person);  // ["John", 30]\nObject.entries(person); // [["name", "John"], ["age", 30]]\n\n// Check property exists\n"name" in person;       // true\nperson.hasOwnProperty("name");  // true\n\n// Delete property\ndelete person.age;\n\n// Iterate over properties\nfor (const key in person) {\n  console.log(key, person[key]);\n}\nObject.keys(person).forEach(key => {\n  console.log(key, person[key]);\n});\n\n// Merge objects\nconst merged = Object.assign({}, person, {city: "NYC"});\nconst merged2 = {...person, ...{city: "NYC"}};\n\n// Compare objects\nJSON.stringify(obj1) === JSON.stringify(obj2);\n\n// Check if empty\nObject.keys(person).length === 0;\n\n// JSON\nJSON.stringify(person);\nJSON.parse(jsonString);'},{name:"PHP",lang:"php",code:"<?php\n// Array access\n$name = $person['name'];\n\n// Array merge\n$updated = array_merge($person, ['age' => 31]);\n$merged = array_merge($person, ['city' => 'NYC']);\n\n// Get keys/values\narray_keys($person);    // ['name', 'age']\narray_values($person);  // ['John', 30]\n\n// Check key exists\narray_key_exists('name', $person);  // true\nisset($person['name']);             // true\n\n// Delete key\nunset($person['age']);\n\n// Iterate\nforeach ($person as $key => $value) {\n  echo \"$key: $value\";\n}\n\n// Count\ncount($person);  // number of elements\n\n// Check if empty\nempty($person);  // false\n\n// JSON\njson_encode($person);\njson_decode($jsonString, true);\n\n// Object methods (for class instances)\nget_object_vars($person);  // get properties\nproperty_exists($person, 'name');  // check property"},{name:"Rust",lang:"rust",code:'// Struct update syntax\nlet updated = Person {\n  age: 31,\n  ..person\n};\n\n// Clone\nlet cloned = person.clone();\n\n// Debug print\n#[derive(Debug)]\nstruct Person { ... }\nprintln!("{:?}", person);\n\n// Compare\n#[derive(PartialEq, Eq)]\nstruct Person { ... }\nperson1 == person2;\n\n// Iterate over fields (manual or use macro)\n// Use macros like serde or custom derive\n\n// Check if struct has default values\nimpl Default for Person {\n  fn default() -> Self {\n      Person { name: String::new(), age: 0 }\n  }\n}\nlet empty = Person::default();\n\n// Serialization (with serde)\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\nstruct Person { ... }\n\nlet json = serde_json::to_string(&person)?;\nlet person: Person = serde_json::from_str(&json)?;\n\n// Convert to/from HashMap\nuse std::collections::HashMap;\nlet map: HashMap<String, String> = HashMap::new();'},{name:"Go",lang:"go",code:'// Struct literal update\nupdated := Person{\n  Name: person.Name,\n  Age:  31,\n}\n\n// Pointer\np := &person\np.Age = 31\n\n// Copy\ncloned := person\n\n// Compare (if fields are comparable)\nperson1 == person2\n\n// Iterate over struct fields (use reflection)\nimport "reflect"\nv := reflect.ValueOf(person)\nfor i := 0; i < v.NumField(); i++ {\n  field := v.Field(i)\n  // process field\n}\n\n// Check if zero value\nvar empty Person\nperson == empty  // check if empty\n\n// JSON\nimport "encoding/json"\n\njsonBytes, _ := json.Marshal(person)\nvar p Person\njson.Unmarshal(jsonBytes, &p)\n\n// Convert to map\nimport "encoding/json"\nvar m map[string]interface{}\njson.Unmarshal(jsonBytes, &m)\n\n// Tags for JSON\ntype Person struct {\n  Name string `json:"name"`\n  Age  int    `json:"age"`\n}'},{name:"Python",lang:"python",code:'# Dictionary update\nupdated = {**person, "age": 31}\n\n# Dictionary copy\ncloned = person.copy()  # shallow copy\nimport copy\ndeep_cloned = copy.deepcopy(person)  # deep copy\n\n# Get keys/values/items\nperson.keys()      # dict_keys([\'name\', \'age\'])\nperson.values()    # dict_values([\'John\', 30])\nperson.items()     # dict_items([(\'name\', \'John\'), (\'age\', 30)])\n\n# Check key exists\n"name" in person   # True\nperson.get("name") # "John" or None\nperson.get("name", "Default")  # with default\n\n# Delete key\ndel person["age"]\nperson.pop("age")  # returns value\nperson.pop("age", None)  # with default\n\n# Iterate\nfor key in person:\n  print(key, person[key])\nfor key, value in person.items():\n  print(key, value)\n\n# Merge dictionaries\nmerged = {**person, **{"city": "NYC"}}\nperson.update({"city": "NYC"})\n\n# Check if empty\nlen(person) == 0\nnot person\nbool(person)  # False if empty\n\n# Clear all\nperson.clear()\n\n# JSON\nimport json\njson_str = json.dumps(person)\nperson = json.loads(json_str)\n\n# Dataclass methods\nfrom dataclasses import dataclass, asdict, fields\nperson_dict = asdict(person)  # convert to dict\nfor field in fields(person):\n  print(field.name)'},{name:"Zig",lang:"zig",code:'// Struct update\nconst updated = Person{\n  .age = 31,\n  .name = person.name,\n};\n\n// Copy\nconst cloned = person;\n\n// Compare (manual or use std.mem.eql)\nstd.mem.eql(u8, person1.name, person2.name);\n\n// Iterate over fields (use @TypeOf and reflection)\nconst T = @TypeOf(person);\nconst fields = @typeInfo(T).Struct.fields;\nfor (fields) |field| {\n  // access field info\n}\n\n// Check if zero value\nconst zero = Person{ .name = "", .age = 0 };\nstd.mem.eql(Person, &person, &zero);\n\n// Debug print\nstd.debug.print("{any}\\n", .{person});\n\n// JSON (use external library)\n// zig-json or similar\n\n// Convert to array (manual)\nvar arr: [2]u8 = undefined;\narr[0] = person.age;'},{name:"C#",lang:"csharp",code:'// Object initializer\nvar updated = new Person(person.Name, 31);\n\n// With expression (C# 9+)\nvar updated = person with { Age = 31 };\n\n// Clone\nvar cloned = new Person(person.Name, person.Age);\n\n// Reflection\nusing System.Reflection;\nvar properties = typeof(Person).GetProperties();\nforeach (var prop in properties) {\n  var value = prop.GetValue(person);\n}\n\n// Check property exists\ntypeof(Person).GetProperty("Name") != null;\n\n// Compare\nperson.Equals(otherPerson);\nperson == otherPerson;  // if == operator defined\n\n// ToString\nperson.ToString();  // override for custom\n\n// GetHashCode\nperson.GetHashCode();\n\n// Convert to dictionary\nvar dict = new Dictionary<string, object>();\ndict["Name"] = person.Name;\ndict["Age"] = person.Age;\n\n// JSON\nusing System.Text.Json;\n\nvar json = JsonSerializer.Serialize(person);\nvar p = JsonSerializer.Deserialize<Person>(json);\n\n// Anonymous objects\nvar anon = new { Name = "John", Age = 30 };'},{name:"C++",lang:"cpp",code:'// Copy constructor\nPerson updated = person;\nupdated.age = 31;\n\n// Copy assignment\nPerson cloned;\ncloned = person;\n\n// Compare (define operator==)\nbool operator==(const Person& other) const {\n  return name == other.name && age == other.age;\n}\n\n// Stream output (for printing)\nfriend std::ostream& operator<<(std::ostream& os, const Person& p) {\n  os << "Person{name: " << p.name << ", age: " << p.age << "}";\n  return os;\n}\n\n// Structured bindings (C++17)\nauto [name, age] = person;\n\n// Reflection (C++20 or use libraries)\n// Use libraries like magic_enum or custom solutions\n\n// Convert to tuple\nstd::make_tuple(person.name, person.age);\n\n// JSON (use external library like nlohmann/json)\n#include <nlohmann/json.hpp>\n\nnlohmann::json j = person;\nstd::string json = j.dump();\nPerson p = j.get<Person>();'},{name:"C",lang:"c",code:'// Manual copy\nPerson updated;\nstrcpy(updated.name, person.name);\nupdated.age = 31;\n\n// Compare (manual function)\nint compare_person(const Person* p1, const Person* p2) {\n  if (strcmp(p1->name, p2->name) != 0) return -1;\n  if (p1->age != p2->age) return -1;\n  return 0;\n}\n\n// Print struct\nvoid print_person(const Person* p) {\n  printf("Person{name: %s, age: %d}\\n", p->name, p->age);\n}\n\n// Check if empty\nint is_empty_person(const Person* p) {\n  return strlen(p->name) == 0 && p->age == 0;\n}\n\n// Convert to string\nvoid person_to_string(const Person* p, char* buffer, size_t size) {\n  snprintf(buffer, size, "Person{name: %s, age: %d}", p->name, p->age);\n}\n\n// JSON (use external library like cJSON)\n#include <cjson/cJSON.h>\n\ncJSON* json = cJSON_CreateObject();\ncJSON_AddStringToObject(json, "name", person.name);\ncJSON_AddNumberToObject(json, "age", person.age);\nchar* json_string = cJSON_Print(json);'},{name:"Java",lang:"java",code:'// Clone (if implements Cloneable)\nPerson updated = person.clone();\nupdated.setAge(31);\n\n// Reflection\nimport java.lang.reflect.Field;\nField[] fields = Person.class.getDeclaredFields();\nfor (Field field : fields) {\n  field.setAccessible(true);\n  Object value = field.get(person);\n}\n\n// Compare\nperson.equals(otherPerson);  // override equals()\nperson.hashCode();            // override hashCode()\n\n// ToString\nperson.toString();  // override toString()\n\n// Check if null\nperson != null;\n\n// Convert to Map\nimport java.util.HashMap;\nMap<String, Object> map = new HashMap<>();\nmap.put("name", person.getName());\nmap.put("age", person.getAge());\n\n// Builder pattern\nPerson.Builder builder = new Person.Builder();\nPerson p = builder.name("John").age(30).build();\n\n// JSON (use Gson or Jackson)\nimport com.google.gson.Gson;\n\nGson gson = new Gson();\nString json = gson.toJson(person);\nPerson p = gson.fromJson(json, Person.class);\n\n// Record methods (Java 14+)\npublic record Person(String name, int age) {}\nperson.name();  // accessor\nperson.equals(other);  // auto-generated'},{name:"Ruby",lang:"ruby",code:'# Hash merge\nupdated = person.merge(age: 31)\nmerged = person.merge(city: "NYC")\n\n# Hash clone\ncloned = person.clone\ncloned = person.dup\n\n# Get keys/values\nperson.keys      # [:name, :age]\nperson.values    # ["John", 30]\nperson.to_a      # [[:name, "John"], [:age, 30]]\n\n# Check key exists\nperson.key?(:name)     # true\nperson.has_key?(:name) # true\nperson.include?(:name) # true\n\n# Delete key\nperson.delete(:age)    # returns value\nperson.delete_if { |k, v| k == :age }\n\n# Iterate\nperson.each { |key, value| puts "#{key}: #{value}" }\nperson.each_key { |key| puts key }\nperson.each_value { |value| puts value }\n\n# Check if empty\nperson.empty?    # false\nperson.length == 0\n\n# Clear\nperson.clear\n\n# Compare\nperson == other_person  # true if same keys/values\n\n# Convert to array\nperson.to_a\n\n# Select/Filter\nperson.select { |k, v| v.is_a?(Integer) }\n\n# Transform values\nperson.transform_values { |v| v.to_s }\n\n# JSON\nrequire \'json\'\n\njson_str = person.to_json\nperson = JSON.parse(json_str)\n\n# Object methods (for class instances)\nperson.instance_variables  # [:@name, :@age]\nperson.instance_variable_get(:@name)\nperson.respond_to?(:greet)  # check method exists'},{name:"Swift",lang:"swift",code:'// Struct update\nvar updated = person\nupdated.age = 31\n\n// Copy (structs are value types, automatically copied)\nlet cloned = person\n\n// Compare (if Equatable)\nextension Person: Equatable {\n  static func == (lhs: Person, rhs: Person) -> Bool {\n      lhs.name == rhs.name && lhs.age == rhs.age\n  }\n}\nperson == otherPerson\n\n// Hashable\nextension Person: Hashable {\n  func hash(into hasher: inout Hasher) {\n      hasher.combine(name)\n      hasher.combine(age)\n  }\n}\n\n// Codable (for JSON)\nextension Person: Codable { }\n\n// Mirror (reflection)\nlet mirror = Mirror(reflecting: person)\nfor child in mirror.children {\n  print("(child.label ?? ""): (child.value)")\n}\n\n// Convert to dictionary\nlet dict = ["name": person.name, "age": String(person.age)]\n\n// Check if empty (custom)\nextension Person {\n  var isEmpty: Bool {\n      name.isEmpty && age == 0\n  }\n}\n\n// CustomStringConvertible\nextension Person: CustomStringConvertible {\n  var description: String {\n      "Person(name: \\(name), age: \\(age))"\n  }\n}\nprint(person)  // uses description\n\n// JSON\nimport Foundation\n\nlet encoder = JSONEncoder()\nlet data = try encoder.encode(person)\nlet jsonString = String(data: data, encoding: .utf8)\n\nlet decoder = JSONDecoder()\nlet p = try decoder.decode(Person.self, from: data)'}]}),"\n",(0,o.jsx)(e.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Struct vs classe vs dicion\xe1rio"})," -- Swift, Rust, Go, Zig e C usam structs como cont\xeaineres de dados prim\xe1rios para campos nomeados. JavaScript, Python, PHP e Ruby frequentemente usam objetos simples ou dicion\xe1rios (ex: ",(0,o.jsx)(e.code,{children:'{ name: "John", age: 30 }'}),") para dados ad-hoc. Java e C# favorecem classes para dados estruturados. Use structs quando precisar de schemas fixos e verifica\xe7\xe3o em tempo de compila\xe7\xe3o; use dicion\xe1rios quando o schema \xe9 din\xe2mico ou voc\xea est\xe1 construindo configura\xe7\xe3o ou dados similares a JSON."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Sem\xe2ntica de valor vs refer\xeancia"})," -- Structs de Swift e Rust s\xe3o tipos de valor: ",(0,o.jsx)(e.code,{children:"let b = a"})," copia os dados. Objetos de Java, C# e JavaScript s\xe3o tipos de refer\xeancia: ",(0,o.jsx)(e.code,{children:"b = a"})," compartilha a mesma inst\xe2ncia. Structs de Go s\xe3o valores, mas s\xe3o comumente passados como ponteiros (",(0,o.jsx)(e.code,{children:"*Person"}),") para muta\xe7\xe3o. Sem\xe2ntica de valor evita muta\xe7\xe3o compartilhada acidental; sem\xe2ntica de refer\xeancia reduz c\xf3pias. Escolha tipos de valor (Swift, Rust) para comportamento previs\xedvel e seguran\xe7a de threads; tipos de refer\xeancia quando precisar de estado mut\xe1vel compartilhado."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Anexa\xe7\xe3o de m\xe9todos"})," -- Rust usa ",(0,o.jsx)(e.code,{children:"impl Person { fn greet(&self) {...} }"}),"; Go usa sintaxe de receiver ",(0,o.jsx)(e.code,{children:"func (p Person) Greet() string"}),"; Zig incorpora fun\xe7\xf5es dentro de structs. JavaScript e Python anexam m\xe9todos a classes. C usa fun\xe7\xf5es externas como ",(0,o.jsx)(e.code,{children:"greet(&person)"}),". O padr\xe3o afeta como voc\xea organiza o c\xf3digo: blocos ",(0,o.jsx)(e.code,{children:"impl"})," co-localizam l\xf3gica com dados em Rust; Go separa m\xe9todos de defini\xe7\xf5es de tipo. Prefira linguagens com sintaxe de m\xe9todos ao construir modelos de dom\xednio."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Alternativas leves"})," -- ",(0,o.jsx)(e.code,{children:"@dataclass"})," de Python, ",(0,o.jsx)(e.code,{children:"record"})," de C# e ",(0,o.jsx)(e.code,{children:"record"})," de Java fornecem defini\xe7\xf5es compactas para cont\xeaineres de dados sem boilerplate. JavaScript e Ruby usam object literals ou hashes. Para DTOs, objetos de configura\xe7\xe3o ou payloads de API, prefira dataclasses ou records; para l\xf3gica de neg\xf3cio rica, use classes ou structs completas com m\xe9todos."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Serializa\xe7\xe3o e reflex\xe3o"})," -- Rust e Go usam tags de struct (",(0,o.jsx)(e.code,{children:"#[derive(Serialize)]"}),", ",(0,o.jsx)(e.code,{children:'`json:"name"`'}),") para JSON. ",(0,o.jsx)(e.code,{children:"dataclass"})," de Python e ",(0,o.jsx)(e.code,{children:"asdict()"})," tornam a serializa\xe7\xe3o f\xe1cil. C e Zig exigem mapeamento manual. Se voc\xea frequentemente serializa para JSON ou outros formatos, favore\xe7a linguagens com suporte built-in (Go, Rust com serde, Python, C#); para runtime m\xednimo, C ou Zig podem ser aceit\xe1veis."]}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);