"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[426],{7895(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>u,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"closures-lambdas","title":"Closures & Lambdas","description":"Closures, lambdas, fun\xe7\xf5es an\xf4nimas e fun\xe7\xf5es de ordem superior em 12 linguagens","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/closures-lambdas.md","sourceDirName":".","slug":"/closures-lambdas","permalink":"/language-comparison/pt-BR/docs/closures-lambdas","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/closures-lambdas.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"description":"Closures, lambdas, fun\xe7\xf5es an\xf4nimas e fun\xe7\xf5es de ordem superior em 12 linguagens","keywords":["closures","lambdas","fun\xe7\xf5es an\xf4nimas","fun\xe7\xf5es de ordem superior","callbacks"]},"sidebar":"tutorialSidebar","previous":{"title":"Functions","permalink":"/language-comparison/pt-BR/docs/functions"},"next":{"title":"Arrays","permalink":"/language-comparison/pt-BR/docs/arrays"}}');var a=t(4848),o=t(8453),i=t(6153);const s={sidebar_position:10,description:"Closures, lambdas, fun\xe7\xf5es an\xf4nimas e fun\xe7\xf5es de ordem superior em 12 linguagens",keywords:["closures","lambdas","fun\xe7\xf5es an\xf4nimas","fun\xe7\xf5es de ordem superior","callbacks"]},u="Closures & Lambdas",c={},l=[{value:"Closures &amp; Fun\xe7\xf5es An\xf4nimas",id:"closures--fun\xe7\xf5es-an\xf4nimas",level:2},{value:"Fun\xe7\xf5es de Ordem Superior",id:"fun\xe7\xf5es-de-ordem-superior",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"closures--lambdas",children:"Closures & Lambdas"})}),"\n",(0,a.jsx)(e.p,{children:"Closures s\xe3o fun\xe7\xf5es que capturam vari\xe1veis do escopo ao redor. Veja como diferentes linguagens lidam com closures, lambdas e fun\xe7\xf5es de ordem superior."}),"\n","\n",(0,a.jsx)(e.h2,{id:"closures--fun\xe7\xf5es-an\xf4nimas",children:"Closures & Fun\xe7\xf5es An\xf4nimas"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Arrow functions (closures)\nconst add = (a, b) => a + b;\nconst square = x => x * x;\n\n// Capturing variables\nfunction counter() {\n  let count = 0;\n  return {\n      increment: () => ++count,\n      getCount: () => count,\n  };\n}\nconst c = counter();\nc.increment();  // 1\nc.increment();  // 2\nc.getCount();   // 2\n\n// IIFE (Immediately Invoked)\nconst result = ((x) => x * 2)(5);  // 10\n\n// Closures in loops\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n  // Prints 0, 1, 2 (let creates new scope)\n}"},{name:"PHP",lang:"php",code:"<?php\n// Anonymous functions\n$add = function($a, $b) { return $a + $b; };\n$add(1, 2);  // 3\n\n// Arrow functions (PHP 7.4+)\n$square = fn($x) => $x * $x;\n\n// Capturing variables (use keyword)\n$multiplier = 3;\n$multiply = function($x) use ($multiplier) {\n  return $x * $multiplier;\n};\n$multiply(5);  // 15\n\n// Capture by reference\n$count = 0;\n$increment = function() use (&$count) {\n  $count++;\n};\n$increment();  // $count is now 1\n\n// Arrow functions auto-capture by value\n$factor = 2;\n$double = fn($x) => $x * $factor;"},{name:"Rust",lang:"rust",code:'// Closures\nlet add = |a, b| a + b;\nlet square = |x: i32| -> i32 { x * x };\n\n// Capturing by reference (borrow)\nlet name = String::from("hello");\nlet greet = || println!("{}", name);  // borrows name\n\n// Capturing by value (move)\nlet name = String::from("hello");\nlet greet = move || println!("{}", name);\n// name is no longer accessible here\n\n// Closure types\n// Fn: borrows immutably\n// FnMut: borrows mutably\n// FnOnce: takes ownership\n\nfn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n  f(x)\n}\n\n// Mutable closure\nlet mut count = 0;\nlet mut increment = || {\n  count += 1;\n  count\n};'},{name:"Go",lang:"go",code:"// Anonymous functions\nadd := func(a, b int) int { return a + b }\nadd(1, 2)  // 3\n\n// Closures (capture by reference)\nfunc counter() func() int {\n  count := 0\n  return func() int {\n      count++\n      return count\n  }\n}\n\nc := counter()\nc()  // 1\nc()  // 2\n\n// Immediately invoked\nresult := func(x int) int { return x * 2 }(5)\n\n// Closures in goroutines\nfor i := 0; i < 3; i++ {\n  go func(n int) {\n      fmt.Println(n)  // Pass i as parameter\n  }(i)\n}"},{name:"Python",lang:"python",code:'# Lambda functions\nadd = lambda a, b: a + b\nsquare = lambda x: x * x\n\n# Closures\ndef counter():\n  count = 0\n  def increment():\n      nonlocal count\n      count += 1\n      return count\n  return increment\n\nc = counter()\nc()  # 1\nc()  # 2\n\n# functools.partial (partial application)\nfrom functools import partial\n\ndef multiply(a, b):\n  return a * b\n\ndouble = partial(multiply, 2)\ndouble(5)  # 10\n\n# Decorators (higher-order functions)\ndef log_calls(func):\n  def wrapper(*args, **kwargs):\n      print(f"Calling {func.__name__}")\n      return func(*args, **kwargs)\n  return wrapper\n\n@log_calls\ndef greet(name):\n  return f"Hello, {name}"'},{name:"Zig",lang:"zig",code:"// Zig has limited closure support\n// Use function pointers and context\n\n// Function pointer\nconst Op = fn (i32, i32) i32;\n\nfn add(a: i32, b: i32) i32 {\n  return a + b;\n}\n\nconst op: Op = add;\nconst result = op(1, 2);  // 3\n\n// Closure-like with struct\nfn makeMultiplier(factor: i32) fn (i32) i32 {\n  const Closure = struct {\n      fn multiply(x: i32) i32 {\n          // Note: can't capture runtime values\n          return x * 2;\n      }\n  };\n  return Closure.multiply;\n}\n\n// Comptime closures\nfn applyComptime(\n  comptime f: fn (i32) i32,\n  value: i32\n) i32 {\n  return f(value);\n}"},{name:"C#",lang:"csharp",code:'// Lambda expressions\nFunc<int, int, int> add = (a, b) => a + b;\nFunc<int, int> square = x => x * x;\n\n// Multi-statement lambda\nFunc<int, string> describe = x =>\n{\n  if (x > 0) return "positive";\n  if (x < 0) return "negative";\n  return "zero";\n};\n\n// Closures (capture by reference)\nint count = 0;\nAction increment = () => count++;\nincrement();  // count is 1\n\n// Action (void return)\nAction<string> greet = name =>\n  Console.WriteLine($"Hello, {name}");\n\n// Predicate\nPredicate<int> isEven = x => x % 2 == 0;\n\n// Local functions (C# 7+)\nint Multiply(int a, int b) => a * b;\n\n// Static lambda (no capture, C# 9+)\nFunc<int, int> doubleIt = static x => x * 2;'},{name:"C++",lang:"cpp",code:"// Lambda expressions\nauto add = [](int a, int b) { return a + b; };\nauto square = [](int x) { return x * x; };\n\n// Capture by value [=]\nint factor = 3;\nauto multiply = [factor](int x) { return x * factor; };\n\n// Capture by reference [&]\nint count = 0;\nauto increment = [&count]() { count++; };\n\n// Mixed capture\nauto func = [=, &count](int x) {\n  count++;\n  return x * factor;\n};\n\n// Mutable (modify captured value copy)\nauto counter = [count = 0]() mutable {\n  return ++count;\n};\n\n// Generic lambda (C++14)\nauto identity = [](auto x) { return x; };\n\n// Immediately invoked\nauto result = [](int x) { return x * 2; }(5);"},{name:"C",lang:"c",code:"// C has no closures or lambdas\n// Use function pointers\n\ntypedef int (*Operation)(int, int);\n\nint add(int a, int b) { return a + b; }\nint multiply(int a, int b) { return a * b; }\n\n// Pass function as argument\nint apply(Operation op, int a, int b) {\n  return op(a, b);\n}\n\nint result = apply(add, 3, 4);       // 7\nint result2 = apply(multiply, 3, 4); // 12\n\n// Simulate closure with struct + function pointer\ntypedef struct {\n  int factor;\n  int (*multiply)(int, int);\n} Multiplier;\n\nint mult(int x, int factor) {\n  return x * factor;\n}\n// Must pass context manually"},{name:"Java",lang:"java",code:'// Lambda expressions (Java 8+)\nFunction<Integer, Integer> square = x -> x * x;\nBiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;\n\n// Multi-statement\nFunction<Integer, String> describe = x -> {\n  if (x > 0) return "positive";\n  if (x < 0) return "negative";\n  return "zero";\n};\n\n// Effectively final (captures must be final)\nint factor = 3;\nFunction<Integer, Integer> multiply = x -> x * factor;\n// factor = 4;  // Error! Must be effectively final\n\n// Method references\nFunction<String, Integer> len = String::length;\nConsumer<String> printer = System.out::println;\n\n// Functional interfaces\nPredicate<Integer> isEven = x -> x % 2 == 0;\nSupplier<String> greeting = () -> "Hello";\nConsumer<String> logger = msg -> System.out.println(msg);\nRunnable task = () -> System.out.println("Running");'},{name:"Ruby",lang:"ruby",code:'# Blocks\n[1, 2, 3].each { |n| puts n }\n[1, 2, 3].each do |n|\nputs n\nend\n\n# Procs\nsquare = Proc.new { |x| x * x }\nsquare.call(5)  # 25\nsquare.(5)      # 25\nsquare[5]       # 25\n\n# Lambdas\nadd = ->(a, b) { a + b }\nadd.call(1, 2)  # 3\n\n# Lambda vs Proc differences\n# Lambda checks arity, Proc doesn\'t\n# Lambda return exits lambda, Proc return exits method\n\n# Closures (capture by reference)\ndef counter\ncount = 0\nincrement = -> { count += 1; count }\nget_count = -> { count }\n[increment, get_count]\nend\n\ninc, get = counter\ninc.call  # 1\ninc.call  # 2\nget.call  # 2\n\n# Method objects\nmethod_obj = method(:puts)\nmethod_obj.call("hello")'},{name:"Swift",lang:"swift",code:'// Closures\nlet add = { (a: Int, b: Int) -> Int in a + b }\nlet square: (Int) -> Int = { $0 * $0 }\n\n// Trailing closure syntax\nlet sorted = numbers.sorted { $0 < $1 }\n\n// Capturing values\nfunc makeCounter() -> () -> Int {\n  var count = 0\n  return {\n      count += 1\n      return count\n  }\n}\n\nlet counter = makeCounter()\ncounter()  // 1\ncounter()  // 2\n\n// Escaping closures\nfunc fetchData(completion: @escaping (String) -> Void) {\n  DispatchQueue.global().async {\n      completion("data")\n  }\n}\n\n// Autoclosure\nfunc assert(_ condition: @autoclosure () -> Bool) {\n  if !condition() { print("Failed") }\n}\nassert(2 + 2 == 4)  // Expression auto-wrapped'}]}),"\n",(0,a.jsx)(e.h2,{id:"fun\xe7\xf5es-de-ordem-superior",children:"Fun\xe7\xf5es de Ordem Superior"}),"\n",(0,a.jsx)(i.A,{languages:[{name:"JavaScript",lang:"javascript",code:"// Map, filter, reduce\nconst nums = [1, 2, 3, 4, 5];\n\nnums.map(x => x * 2);          // [2, 4, 6, 8, 10]\nnums.filter(x => x % 2 === 0); // [2, 4]\nnums.reduce((acc, x) => acc + x, 0); // 15\n\n// Function composition\nconst compose = (f, g) => x => f(g(x));\nconst double = x => x * 2;\nconst addOne = x => x + 1;\nconst doubleThenAdd = compose(addOne, double);\ndoubleThenAdd(3);  // 7\n\n// Currying\nconst curry = fn => a => b => fn(a, b);\nconst add = curry((a, b) => a + b);\nconst add5 = add(5);\nadd5(3);  // 8"},{name:"PHP",lang:"php",code:"<?php\n$nums = [1, 2, 3, 4, 5];\n\narray_map(fn($x) => $x * 2, $nums);\narray_filter($nums, fn($x) => $x % 2 === 0);\narray_reduce($nums, fn($acc, $x) => $acc + $x, 0);\n\n// Function composition\nfunction compose(callable $f, callable $g): Closure {\n  return fn($x) => $f($g($x));\n}\n\n// Currying\nfunction curry(callable $fn): Closure {\n  return fn($a) => fn($b) => $fn($a, $b);\n}\n\n$add = curry(fn($a, $b) => $a + $b);\n$add5 = $add(5);\n$add5(3);  // 8"},{name:"Rust",lang:"rust",code:"let nums = vec![1, 2, 3, 4, 5];\n\n// Iterator methods\nlet doubled: Vec<i32> = nums.iter()\n  .map(|x| x * 2).collect();\nlet evens: Vec<&i32> = nums.iter()\n  .filter(|x| *x % 2 == 0).collect();\nlet sum: i32 = nums.iter()\n  .fold(0, |acc, x| acc + x);\n\n// Chaining\nlet result: Vec<i32> = nums.iter()\n  .filter(|x| *x % 2 == 0)\n  .map(|x| x * 3)\n  .collect();\n\n// Accepting closures as parameters\nfn apply_twice<F: Fn(i32) -> i32>(f: F, x: i32) -> i32 {\n  f(f(x))\n}\n\nlet double = |x| x * 2;\napply_twice(double, 3);  // 12"},{name:"Go",lang:"go",code:"// Go doesn't have built-in map/filter/reduce\n// Manual higher-order functions\n\nfunc Map(slice []int, f func(int) int) []int {\n  result := make([]int, len(slice))\n  for i, v := range slice {\n      result[i] = f(v)\n  }\n  return result\n}\n\nfunc Filter(slice []int, f func(int) bool) []int {\n  var result []int\n  for _, v := range slice {\n      if f(v) {\n          result = append(result, v)\n      }\n  }\n  return result\n}\n\nnums := []int{1, 2, 3, 4, 5}\ndoubled := Map(nums, func(x int) int { return x * 2 })\nevens := Filter(nums, func(x int) bool { return x%2 == 0 })"},{name:"Python",lang:"python",code:"nums = [1, 2, 3, 4, 5]\n\n# Built-in higher-order functions\nlist(map(lambda x: x * 2, nums))\nlist(filter(lambda x: x % 2 == 0, nums))\n\nfrom functools import reduce\nreduce(lambda acc, x: acc + x, nums, 0)\n\n# Prefer comprehensions\n[x * 2 for x in nums]\n[x for x in nums if x % 2 == 0]\n\n# Function as argument\ndef apply_twice(f, x):\n  return f(f(x))\n\napply_twice(lambda x: x * 2, 3)  # 12\n\n# Composition with functools\nfrom functools import reduce\ndef compose(*funcs):\n  return reduce(lambda f, g: lambda x: f(g(x)), funcs)"},{name:"Zig",lang:"zig",code:"// Higher-order with function pointers\nfn map(arr: []const i32, f: fn(i32) i32, out: []i32) void {\n  for (arr, 0..) |val, i| {\n      out[i] = f(val);\n  }\n}\n\nfn double(x: i32) i32 {\n  return x * 2;\n}\n\nvar input = [_]i32{ 1, 2, 3, 4, 5 };\nvar output: [5]i32 = undefined;\nmap(&input, double, &output);\n\n// Inline for + comptime\ninline for (.{ add, subtract, multiply }) |op| {\n  // Apply each operation\n}"},{name:"C#",lang:"csharp",code:"var nums = new[] { 1, 2, 3, 4, 5 };\n\n// LINQ methods\nnums.Select(x => x * 2);\nnums.Where(x => x % 2 == 0);\nnums.Aggregate(0, (acc, x) => acc + x);\n\n// Chaining\nvar result = nums\n  .Where(x => x % 2 == 0)\n  .Select(x => x * 3)\n  .ToArray();\n\n// Function as parameter\nint ApplyTwice(Func<int, int> f, int x) => f(f(x));\nApplyTwice(x => x * 2, 3);  // 12"},{name:"C++",lang:"cpp",code:"#include <algorithm>\n#include <numeric>\n\nstd::vector<int> nums = {1, 2, 3, 4, 5};\n\n// transform (map)\nstd::vector<int> doubled;\nstd::transform(nums.begin(), nums.end(),\n  std::back_inserter(doubled),\n  [](int x) { return x * 2; });\n\n// accumulate (reduce)\nint sum = std::accumulate(nums.begin(), nums.end(), 0);\n\n// Ranges (C++20)\n#include <ranges>\nauto result = nums\n  | std::views::filter([](int x) { return x % 2 == 0; })\n  | std::views::transform([](int x) { return x * 3; });\n\n// Function as parameter\ntemplate<typename F>\nint applyTwice(F f, int x) {\n  return f(f(x));\n}"},{name:"C",lang:"c",code:"// Function pointers as arguments\nvoid map(int* in, int* out, int n, int (*f)(int)) {\n  for (int i = 0; i < n; i++) {\n      out[i] = f(in[i]);\n  }\n}\n\nint double_val(int x) { return x * 2; }\n\nint arr[] = {1, 2, 3, 4, 5};\nint result[5];\nmap(arr, result, 5, double_val);\n\n// qsort with comparator\nint compare_desc(const void* a, const void* b) {\n  return *(int*)b - *(int*)a;\n}\nqsort(arr, 5, sizeof(int), compare_desc);"},{name:"Java",lang:"java",code:"var nums = List.of(1, 2, 3, 4, 5);\n\n// Stream API\nnums.stream().map(x -> x * 2).toList();\nnums.stream().filter(x -> x % 2 == 0).toList();\nnums.stream().reduce(0, Integer::sum);\n\n// Chaining\nvar result = nums.stream()\n  .filter(x -> x % 2 == 0)\n  .map(x -> x * 3)\n  .toList();\n\n// Function composition\nFunction<Integer, Integer> doubleIt = x -> x * 2;\nFunction<Integer, Integer> addOne = x -> x + 1;\nvar doubleThenAdd = doubleIt.andThen(addOne);\ndoubleThenAdd.apply(3);  // 7"},{name:"Ruby",lang:"ruby",code:'nums = [1, 2, 3, 4, 5]\n\nnums.map { |x| x * 2 }\nnums.select { |x| x.even? }\nnums.reduce(0) { |acc, x| acc + x }\n\n# Chaining\nnums.select(&:even?).map { |x| x * 3 }\n\n# Symbol to proc\nnums.map(&:to_s)  # ["1", "2", "3", "4", "5"]\n\n# Yielding to blocks\ndef apply_twice(x)\nyield(yield(x))\nend\n\napply_twice(3) { |x| x * 2 }  # 12'},{name:"Swift",lang:"swift",code:"let nums = [1, 2, 3, 4, 5]\n\nnums.map { $0 * 2 }\nnums.filter { $0 % 2 == 0 }\nnums.reduce(0) { $0 + $1 }\nnums.reduce(0, +)  // Shorthand\n\n// Chaining\nlet result = nums\n  .filter { $0 % 2 == 0 }\n  .map { $0 * 3 }\n\n// Function as parameter\nfunc applyTwice(_ f: (Int) -> Int, _ x: Int) -> Int {\n  f(f(x))\n}\n\napplyTwice({ $0 * 2 }, 3)  // 12"}]}),"\n",(0,a.jsx)(e.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Sem\xe2ntica de captura"})," -- C++ usa ",(0,a.jsx)(e.code,{children:"[=]"})," para captura por valor e ",(0,a.jsx)(e.code,{children:"[&]"})," para por refer\xeancia; PHP usa ",(0,a.jsx)(e.code,{children:"use ($x)"})," para por valor e ",(0,a.jsx)(e.code,{children:"use (&$x)"})," para por refer\xeancia. Rust distingue ",(0,a.jsx)(e.code,{children:"Fn"})," (empr\xe9stimo imut\xe1vel), ",(0,a.jsx)(e.code,{children:"FnMut"})," (empr\xe9stimo mut\xe1vel) e ",(0,a.jsx)(e.code,{children:"FnOnce"})," (toma posse). Por exemplo, ",(0,a.jsx)(e.code,{children:"let mut count = 0; let inc = || { count += 1; count };"})," em Rust requer ",(0,a.jsx)(e.code,{children:"FnMut"})," porque a closure muta ",(0,a.jsx)(e.code,{children:"count"}),". Escolha captura expl\xedcita quando precisar controlar tempo de vida e mutabilidade; os traits de Rust imp\xf5em isso em tempo de compila\xe7\xe3o e previnem movimentos acidentais ou conflitos de empr\xe9stimo."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Tipos de closure em Rust"})," -- Os traits ",(0,a.jsx)(e.code,{children:"Fn"}),", ",(0,a.jsx)(e.code,{children:"FnMut"})," e ",(0,a.jsx)(e.code,{children:"FnOnce"})," de Rust codificam a sem\xe2ntica de captura em tempo de compila\xe7\xe3o. Uma closure que apenas l\xea vari\xe1veis capturadas implementa ",(0,a.jsx)(e.code,{children:"Fn"}),"; uma que as muta implementa ",(0,a.jsx)(e.code,{children:"FnMut"}),"; uma que as consome (ex: ",(0,a.jsx)(e.code,{children:"move"}),") implementa ",(0,a.jsx)(e.code,{children:"FnOnce"}),". Ao aceitar closures como par\xe2metros, use ",(0,a.jsx)(e.code,{children:"impl Fn(i32) -> i32"})," ou ",(0,a.jsx)(e.code,{children:"F: Fn(i32) -> i32"})," para restringir o que o chamador pode passar. Isso importa porque ",(0,a.jsx)(e.code,{children:"FnOnce"})," s\xf3 pode ser chamada uma vez, ent\xe3o n\xe3o pode ser usada em um loop. Se voc\xea escreve closures que capturam estado, entenda qual trait sua closure implementa para evitar erros de ownership."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Limita\xe7\xf5es de lambda em C"})," -- C n\xe3o tem closures ou lambdas; apenas ponteiros de fun\xe7\xe3o (",(0,a.jsx)(e.code,{children:"int (*op)(int, int)"}),'). Para simular "closures", voc\xea deve passar uma struct de contexto manualmente: ',(0,a.jsx)(e.code,{children:"typedef struct { int factor; } Context; int apply(int x, Context* ctx) { return x * ctx->factor; }"}),". Isso \xe9 verboso e propenso a erros. Para c\xf3digo com muitos callbacks em C, considere passar um contexto ",(0,a.jsx)(e.code,{children:"void*"})," junto com o ponteiro de fun\xe7\xe3o; para novos projetos, prefira linguagens com closures nativas (Go, Rust, C++) se precisar de sem\xe2ntica de captura."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Effectively final em Java"})," -- Lambdas em Java s\xf3 podem capturar vari\xe1veis que s\xe3o final ou effectively final (nunca reatribu\xeddas). Por exemplo, ",(0,a.jsx)(e.code,{children:"int factor = 3; Function<Integer, Integer> mul = x -> x * factor;"})," funciona, mas ",(0,a.jsx)(e.code,{children:"factor = 4;"})," depois seria um erro de compila\xe7\xe3o. Isso previne muta\xe7\xe3o de estado capturado e simplifica o modelo, mas limita closures que precisam manter estado mut\xe1vel. Para capturas imut\xe1veis ou sem estado, lambdas de Java s\xe3o suficientes; para estado mut\xe1vel, use um array de um elemento ou ",(0,a.jsx)(e.code,{children:"AtomicInteger"})," como alternativa, ou prefira uma linguagem com captura completa de closures (ex: JavaScript, C#)."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Fun\xe7\xf5es de ordem superior e built-ins"})," -- JavaScript, Python, Ruby, C# e Swift t\xeam ",(0,a.jsx)(e.code,{children:"map"}),", ",(0,a.jsx)(e.code,{children:"filter"}),", ",(0,a.jsx)(e.code,{children:"reduce"})," (ou equivalentes) built-in. Go n\xe3o tem; voc\xea deve implement\xe1-los ou usar uma biblioteca. C usa ",(0,a.jsx)(e.code,{children:"qsort"})," com um ponteiro de fun\xe7\xe3o comparador. Rust usa m\xe9todos de iterador (",(0,a.jsx)(e.code,{children:".map()"}),", ",(0,a.jsx)(e.code,{children:".filter()"}),", ",(0,a.jsx)(e.code,{children:".fold()"}),"). Zig usa ponteiros de fun\xe7\xe3o e loops manuais. Se voc\xea depende muito de pipelines funcionais, escolha uma linguagem com APIs ricas de iterador/cole\xe7\xe3o; caso contr\xe1rio, espere c\xf3digo imperativo mais verboso."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Quando escolher qual"})," -- Para c\xf3digo web e orientado a eventos, closures de JavaScript s\xe3o idiom\xe1ticas. Para sistemas com seguran\xe7a e performance, closures de Rust com ",(0,a.jsx)(e.code,{children:"Fn"}),"/",(0,a.jsx)(e.code,{children:"FnMut"}),"/",(0,a.jsx)(e.code,{children:"FnOnce"}),' equilibram expressividade e controle. Para Java empresarial, lambdas e streams funcionam bem dentro da restri\xe7\xe3o "effectively final". Para C/C++/Zig, ponteiros de fun\xe7\xe3o s\xe3o a norma; use closures apenas quando tiver C++ ou Rust dispon\xedvel. Combine o suporte a closures com seu caso de uso: pesado em callbacks vs. predominantemente procedural vs. pipelines funcionais.']}),"\n"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);