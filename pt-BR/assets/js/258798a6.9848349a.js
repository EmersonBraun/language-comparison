"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[782],{6458(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>c,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"pattern-matching","title":"Pattern Matching","description":"Pattern matching, destructuring, and switch expressions compared across 12 programming languages","source":"@site/docs/pattern-matching.md","sourceDirName":".","slug":"/pattern-matching","permalink":"/language-comparison/pt-BR/docs/pattern-matching","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/pattern-matching.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"description":"Pattern matching, destructuring, and switch expressions compared across 12 programming languages","keywords":["pattern matching","destructuring","switch","match","guards"]},"sidebar":"tutorialSidebar","previous":{"title":"Loops","permalink":"/language-comparison/pt-BR/docs/loops"},"next":{"title":"Functions","permalink":"/language-comparison/pt-BR/docs/functions"}}');var i=t(4848),r=t(8453),s=t(2531);const c={sidebar_position:8,description:"Pattern matching, destructuring, and switch expressions compared across 12 programming languages",keywords:["pattern matching","destructuring","switch","match","guards"]},o="Pattern Matching",l={},u=[{value:"Basic Pattern Matching",id:"basic-pattern-matching",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"pattern-matching",children:"Pattern Matching"})}),"\n",(0,i.jsx)(e.p,{children:"Pattern matching allows you to check values against patterns and destructure data. Here's how different languages handle pattern matching."}),"\n","\n",(0,i.jsx)(e.h2,{id:"basic-pattern-matching",children:"Basic Pattern Matching"}),"\n",(0,i.jsx)(s.A,{languages:[{name:"JavaScript",lang:"javascript",code:'// Switch statement\nswitch (value) {\n  case 1:\n      console.log("one");\n      break;\n  case 2:\n  case 3:\n      console.log("two or three");\n      break;\n  default:\n      console.log("other");\n}\n\n// Destructuring (object)\nconst { name, age } = person;\nconst { name: userName, ...rest } = person;\n\n// Destructuring (array)\nconst [first, second, ...remaining] = arr;\nconst [a, , c] = [1, 2, 3];  // skip second\n\n// Nested destructuring\nconst { address: { city } } = person;\n\n// Default values\nconst { name = "unknown" } = person;'},{name:"PHP",lang:"php",code:"<?php\n// Match expression (PHP 8.0+)\n$result = match($status) {\n  'active' => 'User is active',\n  'inactive', 'banned' => 'User is not active',\n  default => 'Unknown status',\n};\n\n// Match with no argument (like if/else)\n$result = match(true) {\n  $age < 18 => 'minor',\n  $age < 65 => 'adult',\n  default => 'senior',\n};\n\n// Array destructuring\n[$first, $second] = [1, 2];\n[, , $third] = [1, 2, 3];  // skip first two\n\n// List destructuring\nlist($a, $b, $c) = [1, 2, 3];\n\n// Associative destructuring\n['name' => $name, 'age' => $age] = $person;"},{name:"Rust",lang:"rust",code:'// Match expression (exhaustive)\nmatch value {\n  1 => println!("one"),\n  2 | 3 => println!("two or three"),\n  4..=10 => println!("four to ten"),\n  _ => println!("other"),\n}\n\n// Match with return value\nlet msg = match value {\n  0 => "zero",\n  1 => "one",\n  _ => "many",\n};\n\n// Destructuring structs\nstruct Point { x: i32, y: i32 }\nlet Point { x, y } = point;\n\n// Destructuring enums\nenum Shape {\n  Circle(f64),\n  Rectangle(f64, f64),\n}\n\nmatch shape {\n  Shape::Circle(r) => println!("Circle: {}", r),\n  Shape::Rectangle(w, h) => println!("Rect: {}x{}", w, h),\n}\n\n// Guards\nmatch value {\n  x if x < 0 => println!("negative"),\n  x if x > 0 => println!("positive"),\n  _ => println!("zero"),\n}\n\n// Nested patterns\nmatch point {\n  Point { x: 0, y: 0 } => println!("origin"),\n  Point { x, y: 0 } => println!("on x-axis at {}", x),\n  Point { x: 0, y } => println!("on y-axis at {}", y),\n  Point { x, y } => println!("({}, {})", x, y),\n}'},{name:"Go",lang:"go",code:'// Switch (no break needed)\nswitch value {\ncase 1:\n  fmt.Println("one")\ncase 2, 3:\n  fmt.Println("two or three")\ndefault:\n  fmt.Println("other")\n}\n\n// Switch with no condition\nswitch {\ncase age < 18:\n  fmt.Println("minor")\ncase age < 65:\n  fmt.Println("adult")\ndefault:\n  fmt.Println("senior")\n}\n\n// Type switch\nswitch v := value.(type) {\ncase int:\n  fmt.Println("integer:", v)\ncase string:\n  fmt.Println("string:", v)\ncase []int:\n  fmt.Println("int slice:", v)\ndefault:\n  fmt.Println("unknown type")\n}\n\n// Multiple return value "destructuring"\nvalue, err := someFunction()\n_, err := someFunction()  // ignore first'},{name:"Python",lang:"python",code:'# Match statement (Python 3.10+)\nmatch command:\n  case "quit":\n      quit_game()\n  case "go" | "move":\n      move_player()\n  case _:\n      print("unknown command")\n\n# Structural pattern matching\nmatch point:\n  case (0, 0):\n      print("origin")\n  case (x, 0):\n      print(f"on x-axis at {x}")\n  case (0, y):\n      print(f"on y-axis at {y}")\n  case (x, y):\n      print(f"({x}, {y})")\n\n# Class patterns\nmatch shape:\n  case Circle(radius=r):\n      print(f"Circle: {r}")\n  case Rectangle(width=w, height=h):\n      print(f"Rect: {w}x{h}")\n\n# Guards\nmatch value:\n  case x if x < 0:\n      print("negative")\n  case x if x > 0:\n      print("positive")\n  case _:\n      print("zero")\n\n# Destructuring\na, b, *rest = [1, 2, 3, 4, 5]  # a=1, b=2, rest=[3,4,5]\n(x, y) = (10, 20)'},{name:"Zig",lang:"zig",code:'// Switch expression\nconst result = switch (value) {\n  1 => "one",\n  2, 3 => "two or three",\n  4...10 => "four to ten",\n  else => "other",\n};\n\n// Switch on tagged unions (enums)\nconst Shape = union(enum) {\n  circle: f64,\n  rectangle: struct { w: f64, h: f64 },\n};\n\nswitch (shape) {\n  .circle => |r| std.debug.print("Circle: {d}\\n", .{r}),\n  .rectangle => |rect| std.debug.print(\n      "Rect: {d}x{d}\\n", .{rect.w, rect.h}\n  ),\n}\n\n// Switch with captures\nswitch (optional_value) {\n  null => std.debug.print("null\\n", .{}),\n  else => |val| std.debug.print("{d}\\n", .{val}),\n}\n\n// Inline for with switch\ninline for (items) |item| {\n  switch (item) {\n      .a => doA(),\n      .b => doB(),\n  }\n}'},{name:"C#",lang:"csharp",code:'// Switch expression (C# 8+)\nvar result = value switch\n{\n  1 => "one",\n  2 or 3 => "two or three",\n  >= 4 and <= 10 => "four to ten",\n  _ => "other",\n};\n\n// Pattern matching with is\nif (obj is string s && s.Length > 0) { }\nif (value is > 0 and < 100) { }\nif (value is not null) { }\n\n// Type patterns\nvar msg = shape switch\n{\n  Circle c => $"Circle: {c.Radius}",\n  Rectangle r => $"Rect: {r.Width}x{r.Height}",\n  _ => "Unknown shape",\n};\n\n// Property patterns\nvar discount = customer switch\n{\n  { Age: < 18 } => 0.5,\n  { IsMember: true, Age: >= 65 } => 0.3,\n  { IsMember: true } => 0.1,\n  _ => 0.0,\n};\n\n// Tuple patterns\nvar quadrant = (x, y) switch\n{\n  ( > 0, > 0) => "Q1",\n  ( < 0, > 0) => "Q2",\n  ( < 0, < 0) => "Q3",\n  ( > 0, < 0) => "Q4",\n  _ => "On axis",\n};\n\n// Deconstruction\nvar (name, age) = person;'},{name:"C++",lang:"cpp",code:'// Switch statement\nswitch (value) {\n  case 1:\n      std::cout << "one" << std::endl;\n      break;\n  case 2:\n  case 3:\n      std::cout << "two or three" << std::endl;\n      break;\n  default:\n      std::cout << "other" << std::endl;\n}\n\n// Structured bindings (C++17)\nauto [x, y] = std::make_pair(1, 2);\n\nstruct Point { int x; int y; };\nauto [px, py] = Point{10, 20};\n\n// std::variant with std::visit (C++17)\nusing Shape = std::variant<Circle, Rectangle>;\n\nstd::visit([](auto&& shape) {\n  using T = std::decay_t<decltype(shape)>;\n  if constexpr (std::is_same_v<T, Circle>) {\n      std::cout << "Circle: " << shape.radius;\n  } else if constexpr (std::is_same_v<T, Rectangle>) {\n      std::cout << "Rect: " << shape.w << "x" << shape.h;\n  }\n}, shape);'},{name:"C",lang:"c",code:'// Switch statement\nswitch (value) {\n  case 1:\n      printf("one\\n");\n      break;\n  case 2:\n  case 3:\n      printf("two or three\\n");\n      break;\n  default:\n      printf("other\\n");\n      break;\n}\n\n// No destructuring in C\n// Manual extraction\nstruct Point { int x; int y; };\nstruct Point p = {10, 20};\nint x = p.x;\nint y = p.y;\n\n// Tagged unions (manual pattern matching)\nenum ShapeType { CIRCLE, RECTANGLE };\nstruct Shape {\n  enum ShapeType type;\n  union {\n      double radius;\n      struct { double w, h; } rect;\n  };\n};\n\nswitch (shape.type) {\n  case CIRCLE:\n      printf("Circle: %f\\n", shape.radius);\n      break;\n  case RECTANGLE:\n      printf("Rect: %fx%f\\n", shape.rect.w, shape.rect.h);\n      break;\n}'},{name:"Java",lang:"java",code:'// Switch expression (Java 14+)\nString result = switch (value) {\n  case 1 -> "one";\n  case 2, 3 -> "two or three";\n  default -> "other";\n};\n\n// Pattern matching instanceof (Java 16+)\nif (obj instanceof String s) {\n  System.out.println(s.length());\n}\n\n// Switch with patterns (Java 21+)\nString msg = switch (shape) {\n  case Circle c -> "Circle: " + c.radius();\n  case Rectangle r -> "Rect: " + r.width() + "x" + r.height();\n  default -> "Unknown";\n};\n\n// Guarded patterns (Java 21+)\nString desc = switch (value) {\n  case Integer i when i < 0 -> "negative";\n  case Integer i when i > 0 -> "positive";\n  case Integer i -> "zero";\n  default -> "not an integer";\n};\n\n// Records (Java 16+) with deconstruction\nrecord Point(int x, int y) {}\nif (obj instanceof Point(var x, var y)) {\n  System.out.println(x + ", " + y);\n}'},{name:"Ruby",lang:"ruby",code:'# Case/when (pattern matching)\ncase value\nwhen 1\nputs "one"\nwhen 2, 3\nputs "two or three"\nwhen 4..10\nputs "four to ten"\nelse\nputs "other"\nend\n\n# Pattern matching (Ruby 3.0+)\ncase [1, 2, 3]\nin [Integer => a, Integer => b, *rest]\nputs "a=#{a}, b=#{b}, rest=#{rest}"\nend\n\n# Hash patterns\ncase person\nin { name: String => name, age: (18..) => age }\nputs "Adult: #{name}, #{age}"\nin { name: String => name, age: age }\nputs "Minor: #{name}, #{age}"\nend\n\n# Find pattern\ncase items\nin [*, { name: /Ruby/ } => item, *]\nputs "Found Ruby item: #{item}"\nend\n\n# Destructuring\na, b, *rest = [1, 2, 3, 4, 5]\nfirst, = [1, 2, 3]  # first = 1'},{name:"Swift",lang:"swift",code:'// Switch (exhaustive)\nswitch value {\ncase 1:\n  print("one")\ncase 2, 3:\n  print("two or three")\ncase 4...10:\n  print("four to ten")\ndefault:\n  print("other")\n}\n\n// Enum pattern matching\nswitch shape {\ncase .circle(let radius):\n  print("Circle: \\(radius)")\ncase .rectangle(let w, let h):\n  print("Rect: \\(w)x\\(h)")\n}\n\n// Tuple matching\nswitch (x, y) {\ncase (0, 0):\n  print("origin")\ncase (let x, 0):\n  print("on x-axis at \\(x)")\ncase (0, let y):\n  print("on y-axis at \\(y)")\ncase let (x, y):\n  print("(\\(x), \\(y))")\n}\n\n// Where clause (guard)\nswitch value {\ncase let x where x < 0:\n  print("negative")\ncase let x where x > 0:\n  print("positive")\ndefault:\n  print("zero")\n}\n\n// if case (pattern in condition)\nif case .circle(let r) = shape, r > 5 {\n  print("large circle")\n}'}]}),"\n",(0,i.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Exhaustive matching"})," -- Rust and Swift require ",(0,i.jsx)(e.code,{children:"match"}),"/",(0,i.jsx)(e.code,{children:"switch"})," to cover all cases, preventing bugs from missed branches; other languages use ",(0,i.jsx)(e.code,{children:"default"}),"/",(0,i.jsx)(e.code,{children:"else"})," as catch-alls."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Destructuring support"})," -- Rust, Swift, Python, and C# offer rich destructuring of structs, tuples, and enums; C and Go have minimal or no destructuring."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Guard clauses"})," -- Rust (",(0,i.jsx)(e.code,{children:"if"}),"), Swift (",(0,i.jsx)(e.code,{children:"where"}),"), Python (",(0,i.jsx)(e.code,{children:"if"}),"), Java 21+ (",(0,i.jsx)(e.code,{children:"when"}),"), and C# support pattern guards for conditional logic within match arms."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Algebraic data types"})," -- Rust and Swift enums with associated values enable pattern matching on data-carrying variants; Zig's tagged unions offer similar capabilities."]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}}}]);