"use strict";(globalThis.webpackChunklanguage_comparison_docs=globalThis.webpackChunklanguage_comparison_docs||[]).push([[825],{1806(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>f});const i=JSON.parse('{"id":"file-io","title":"I/O de Arquivos","description":"Leitura, escrita e manipula\xe7\xe3o de arquivos comparados em 12 linguagens de programa\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/file-io.md","sourceDirName":".","slug":"/file-io","permalink":"/language-comparison/pt-BR/docs/file-io","draft":false,"unlisted":false,"editUrl":"https://github.com/EmersonBraun/language-comparison/tree/main/docs/file-io.md","tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19,"description":"Leitura, escrita e manipula\xe7\xe3o de arquivos comparados em 12 linguagens de programa\xe7\xe3o","keywords":["I/O de arquivos","leitura de arquivos","escrita de arquivos","sistema de arquivos","streams"]},"sidebar":"tutorialSidebar","previous":{"title":"Dates","permalink":"/language-comparison/pt-BR/docs/dates"},"next":{"title":"JSON & Serialization","permalink":"/language-comparison/pt-BR/docs/json-serialization"}}');var r=t(4848),a=t(8453),o=t(6153);const l={sidebar_position:19,description:"Leitura, escrita e manipula\xe7\xe3o de arquivos comparados em 12 linguagens de programa\xe7\xe3o",keywords:["I/O de arquivos","leitura de arquivos","escrita de arquivos","sistema de arquivos","streams"]},s="I/O de Arquivos",d={},f=[{value:"Lendo Arquivos",id:"lendo-arquivos",level:2},{value:"Escrevendo Arquivos",id:"escrevendo-arquivos",level:2},{value:"Principais Conclus\xf5es",id:"principais-conclus\xf5es",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"io-de-arquivos",children:"I/O de Arquivos"})}),"\n",(0,r.jsx)(n.p,{children:"Ler e escrever arquivos \xe9 uma opera\xe7\xe3o fundamental. Veja como diferentes linguagens lidam com opera\xe7\xf5es de arquivo."}),"\n","\n",(0,r.jsx)(n.h2,{id:"lendo-arquivos",children:"Lendo Arquivos"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Synchronous\nconst data = fs.readFileSync('file.txt', 'utf8');\n\n// Asynchronous (callback)\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n\n// Async/await (modern)\nconst data2 = await fsPromises.readFile('file.txt', 'utf8');\n\n// Read line by line\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: fs.createReadStream('file.txt'),\n});\nfor await (const line of rl) {\n  console.log(line);\n}"},{name:"PHP",lang:"php",code:"<?php\n// Read entire file\n$content = file_get_contents('file.txt');\n\n// Read into array of lines\n$lines = file('file.txt', FILE_IGNORE_NEW_LINES);\n\n// Read with fopen\n$fp = fopen('file.txt', 'r');\nwhile (($line = fgets($fp)) !== false) {\n  echo $line;\n}\nfclose($fp);\n\n// Read binary\n$data = file_get_contents('image.png');\n\n// Read CSV\n$fp = fopen('data.csv', 'r');\nwhile (($row = fgetcsv($fp)) !== false) {\n  print_r($row);\n}\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::{self, BufRead, Read};\n\n// Read entire file to string\nlet content = fs::read_to_string("file.txt")?;\n\n// Read to bytes\nlet bytes = fs::read("file.txt")?;\n\n// Read line by line\nlet file = fs::File::open("file.txt")?;\nlet reader = io::BufReader::new(file);\nfor line in reader.lines() {\n  let line = line?;\n  println!("{}", line);\n}\n\n// Read with buffer\nlet mut file = fs::File::open("file.txt")?;\nlet mut buffer = String::new();\nfile.read_to_string(&mut buffer)?;'},{name:"Go",lang:"go",code:'import (\n  "bufio"\n  "os"\n  "io"\n)\n\n// Read entire file\ndata, err := os.ReadFile("file.txt")\nif err != nil {\n  log.Fatal(err)\n}\nfmt.Println(string(data))\n\n// Read line by line\nfile, _ := os.Open("file.txt")\ndefer file.Close()\n\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\n  fmt.Println(scanner.Text())\n}\n\n// Read with io.ReadAll\nfile, _ := os.Open("file.txt")\ndefer file.Close()\ndata, _ := io.ReadAll(file)'},{name:"Python",lang:"python",code:"# Read entire file\nwith open('file.txt', 'r') as f:\n  content = f.read()\n\n# Read all lines\nwith open('file.txt', 'r') as f:\n  lines = f.readlines()\n\n# Read line by line (memory efficient)\nwith open('file.txt', 'r') as f:\n  for line in f:\n      print(line.strip())\n\n# Read binary\nwith open('image.png', 'rb') as f:\n  data = f.read()\n\n# Read with encoding\nwith open('file.txt', 'r', encoding='utf-8') as f:\n  content = f.read()\n\n# pathlib (modern)\nfrom pathlib import Path\ncontent = Path('file.txt').read_text()"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Read entire file\nconst content = try std.fs.cwd().readFileAlloc(\n  allocator, "file.txt", 1024 * 1024\n);\ndefer allocator.free(content);\n\n// Read with file handle\nconst file = try std.fs.cwd().openFile("file.txt", .{});\ndefer file.close();\n\nvar buf: [1024]u8 = undefined;\nconst bytes_read = try file.read(&buf);\n\n// Read line by line\nvar buf_reader = std.io.bufferedReader(file.reader());\nvar line_buf: [4096]u8 = undefined;\nwhile (try buf_reader.reader().readUntilDelimiterOrEof(\n  &line_buf, \'\\n\'\n)) |line| {\n  std.debug.print("{s}\\n", .{line});\n}'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Read entire file\nstring content = File.ReadAllText("file.txt");\n\n// Read all lines\nstring[] lines = File.ReadAllLines("file.txt");\n\n// Read line by line\nforeach (string line in File.ReadLines("file.txt"))\n{\n  Console.WriteLine(line);\n}\n\n// StreamReader\nusing var reader = new StreamReader("file.txt");\nstring? line;\nwhile ((line = reader.ReadLine()) != null)\n{\n  Console.WriteLine(line);\n}\n\n// Async\nstring content2 = await File.ReadAllTextAsync("file.txt");\n\n// Read bytes\nbyte[] bytes = File.ReadAllBytes("file.bin");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n#include <sstream>\n#include <string>\n\n// Read entire file\nstd::ifstream file("file.txt");\nstd::stringstream buffer;\nbuffer << file.rdbuf();\nstd::string content = buffer.str();\n\n// Read line by line\nstd::ifstream file("file.txt");\nstd::string line;\nwhile (std::getline(file, line)) {\n  std::cout << line << std::endl;\n}\n\n// Read binary\nstd::ifstream file("data.bin", std::ios::binary);\nstd::vector<char> data(\n  (std::istreambuf_iterator<char>(file)),\n  std::istreambuf_iterator<char>()\n);\n\n// Check if file exists (C++17)\n#include <filesystem>\nif (std::filesystem::exists("file.txt")) { }'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Read entire file\nFILE* fp = fopen("file.txt", "r");\nif (fp == NULL) { perror("Error"); return 1; }\n\nfseek(fp, 0, SEEK_END);\nlong size = ftell(fp);\nrewind(fp);\n\nchar* buffer = malloc(size + 1);\nfread(buffer, 1, size, fp);\nbuffer[size] = \'\\0\';\nfclose(fp);\n\n// Read line by line\nFILE* fp = fopen("file.txt", "r");\nchar line[256];\nwhile (fgets(line, sizeof(line), fp)) {\n  printf("%s", line);\n}\nfclose(fp);\n\n// Read binary\nFILE* fp = fopen("data.bin", "rb");\nunsigned char buf[1024];\nsize_t n = fread(buf, 1, sizeof(buf), fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\nimport java.io.*;\n\n// Read entire file (Java 11+)\nString content = Files.readString(Path.of("file.txt"));\n\n// Read all lines\nList<String> lines = Files.readAllLines(Path.of("file.txt"));\n\n// Read line by line (buffered)\ntry (BufferedReader reader =\n      Files.newBufferedReader(Path.of("file.txt"))) {\n  String line;\n  while ((line = reader.readLine()) != null) {\n      System.out.println(line);\n  }\n}\n\n// Stream lines\nFiles.lines(Path.of("file.txt"))\n   .forEach(System.out::println);\n\n// Read bytes\nbyte[] bytes = Files.readAllBytes(Path.of("file.bin"));'},{name:"Ruby",lang:"ruby",code:"# Read entire file\ncontent = File.read('file.txt')\n\n# Read all lines\nlines = File.readlines('file.txt', chomp: true)\n\n# Read line by line\nFile.foreach('file.txt') do |line|\nputs line.chomp\nend\n\n# Read with block (auto-closes)\nFile.open('file.txt', 'r') do |f|\ncontent = f.read\nend\n\n# Read binary\ndata = File.binread('image.png')\n\n# Check file existence\nFile.exist?('file.txt')  # true/false"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Read entire file\nlet content = try String(\n  contentsOfFile: "file.txt",\n  encoding: .utf8\n)\n\n// Read with URL\nlet url = URL(fileURLWithPath: "file.txt")\nlet data = try Data(contentsOf: url)\nlet text = String(data: data, encoding: .utf8)!\n\n// Read line by line\nif let contents = try? String(contentsOfFile: "file.txt") {\n  for line in contents.components(separatedBy: "\\n") {\n      print(line)\n  }\n}\n\n// FileManager\nlet fm = FileManager.default\nif fm.fileExists(atPath: "file.txt") {\n  let data = fm.contents(atPath: "file.txt")\n}'}]}),"\n",(0,r.jsx)(n.h2,{id:"escrevendo-arquivos",children:"Escrevendo Arquivos"}),"\n",(0,r.jsx)(o.A,{languages:[{name:"JavaScript",lang:"javascript",code:"const fs = require('fs');\nconst fsPromises = require('fs/promises');\n\n// Write (overwrite)\nfs.writeFileSync('output.txt', 'Hello World');\n\n// Write async\nawait fsPromises.writeFile('output.txt', 'Hello World');\n\n// Append\nfs.appendFileSync('output.txt', '\\nNew line');\n\n// Write with stream\nconst stream = fs.createWriteStream('output.txt');\nstream.write('Line 1\\n');\nstream.write('Line 2\\n');\nstream.end();"},{name:"PHP",lang:"php",code:"<?php\n// Write (overwrite)\nfile_put_contents('output.txt', 'Hello World');\n\n// Append\nfile_put_contents('output.txt', \"\\nNew line\", FILE_APPEND);\n\n// Write with fopen\n$fp = fopen('output.txt', 'w');\nfwrite($fp, \"Line 1\\n\");\nfwrite($fp, \"Line 2\\n\");\nfclose($fp);"},{name:"Rust",lang:"rust",code:'use std::fs;\nuse std::io::Write;\n\n// Write (overwrite)\nfs::write("output.txt", "Hello World")?;\n\n// Write with file handle\nlet mut file = fs::File::create("output.txt")?;\nfile.write_all(b"Hello World")?;\n\n// Append\nuse std::fs::OpenOptions;\nlet mut file = OpenOptions::new()\n  .append(true)\n  .open("output.txt")?;\nwriteln!(file, "New line")?;'},{name:"Go",lang:"go",code:'import "os"\n\n// Write (overwrite)\nos.WriteFile("output.txt", []byte("Hello World"), 0644)\n\n// Write with file handle\nfile, _ := os.Create("output.txt")\ndefer file.Close()\nfile.WriteString("Hello World\\n")\n\n// Append\nfile, _ := os.OpenFile("output.txt",\n  os.O_APPEND|os.O_WRONLY, 0644)\ndefer file.Close()\nfile.WriteString("New line\\n")\n\n// Buffered writer\nwriter := bufio.NewWriter(file)\nwriter.WriteString("Buffered content\\n")\nwriter.Flush()'},{name:"Python",lang:"python",code:"# Write (overwrite)\nwith open('output.txt', 'w') as f:\n  f.write('Hello World')\n\n# Append\nwith open('output.txt', 'a') as f:\n  f.write('\\nNew line')\n\n# Write multiple lines\nlines = ['Line 1', 'Line 2', 'Line 3']\nwith open('output.txt', 'w') as f:\n  f.writelines(line + '\\n' for line in lines)\n\n# pathlib (modern)\nfrom pathlib import Path\nPath('output.txt').write_text('Hello World')"},{name:"Zig",lang:"zig",code:'const std = @import("std");\n\n// Write (overwrite)\nconst file = try std.fs.cwd().createFile("output.txt", .{});\ndefer file.close();\ntry file.writeAll("Hello World");\n\n// Write formatted\nconst writer = file.writer();\ntry writer.print("Value: {d}\\n", .{42});\n\n// Append\nconst file = try std.fs.cwd().openFile("output.txt", .{\n  .mode = .write_only,\n});\ndefer file.close();\ntry file.seekFromEnd(0);\ntry file.writeAll("New line\\n");'},{name:"C#",lang:"csharp",code:'using System.IO;\n\n// Write (overwrite)\nFile.WriteAllText("output.txt", "Hello World");\n\n// Write lines\nFile.WriteAllLines("output.txt",\n  new[] { "Line 1", "Line 2" });\n\n// Append\nFile.AppendAllText("output.txt", "\\nNew line");\n\n// StreamWriter\nusing var writer = new StreamWriter("output.txt");\nwriter.WriteLine("Line 1");\nwriter.WriteLine("Line 2");\n\n// Async\nawait File.WriteAllTextAsync("output.txt", "Hello");'},{name:"C++",lang:"cpp",code:'#include <fstream>\n\n// Write (overwrite)\nstd::ofstream file("output.txt");\nfile << "Hello World" << std::endl;\nfile.close();\n\n// Append\nstd::ofstream file("output.txt", std::ios::app);\nfile << "New line" << std::endl;\n\n// Write binary\nstd::ofstream file("data.bin", std::ios::binary);\nfile.write(reinterpret_cast<char*>(&data), sizeof(data));'},{name:"C",lang:"c",code:'#include <stdio.h>\n\n// Write (overwrite)\nFILE* fp = fopen("output.txt", "w");\nfprintf(fp, "Hello World\\n");\nfclose(fp);\n\n// Append\nFILE* fp = fopen("output.txt", "a");\nfprintf(fp, "New line\\n");\nfclose(fp);\n\n// Write binary\nFILE* fp = fopen("data.bin", "wb");\nfwrite(data, sizeof(data[0]), count, fp);\nfclose(fp);'},{name:"Java",lang:"java",code:'import java.nio.file.*;\n\n// Write (overwrite) - Java 11+\nFiles.writeString(Path.of("output.txt"), "Hello World");\n\n// Write lines\nFiles.write(Path.of("output.txt"),\n  List.of("Line 1", "Line 2"));\n\n// Append\nFiles.writeString(Path.of("output.txt"), "\\nNew line",\n  StandardOpenOption.APPEND);\n\n// BufferedWriter\ntry (BufferedWriter writer =\n      Files.newBufferedWriter(Path.of("output.txt"))) {\n  writer.write("Line 1");\n  writer.newLine();\n}'},{name:"Ruby",lang:"ruby",code:"# Write (overwrite)\nFile.write('output.txt', 'Hello World')\n\n# Append\nFile.open('output.txt', 'a') do |f|\nf.puts 'New line'\nend\n\n# Write with block\nFile.open('output.txt', 'w') do |f|\nf.puts 'Line 1'\nf.puts 'Line 2'\nend\n\n# Write binary\nFile.binwrite('data.bin', binary_data)"},{name:"Swift",lang:"swift",code:'import Foundation\n\n// Write (overwrite)\ntry "Hello World".write(\n  toFile: "output.txt",\n  atomically: true,\n  encoding: .utf8\n)\n\n// Write with Data\nlet data = "Hello".data(using: .utf8)!\ntry data.write(to: URL(fileURLWithPath: "output.txt"))\n\n// Append\nlet handle = try FileHandle(\n  forWritingTo: URL(fileURLWithPath: "output.txt")\n)\nhandle.seekToEndOfFile()\nhandle.write("New line\\n".data(using: .utf8)!)\nhandle.closeFile()'}]}),"\n",(0,r.jsx)(n.h2,{id:"principais-conclus\xf5es",children:"Principais Conclus\xf5es"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"APIs s\xedncronas vs ass\xedncronas coexistem"})," \u2014 A maioria das linguagens oferece ambas: Node.js tem ",(0,r.jsx)(n.code,{children:"fs.readFileSync"})," e ",(0,r.jsx)(n.code,{children:"fs.promises.readFile"}),"; C# tem ",(0,r.jsx)(n.code,{children:"File.ReadAllText"})," e ",(0,r.jsx)(n.code,{children:"File.ReadAllTextAsync"}),"; o ",(0,r.jsx)(n.code,{children:"open()"})," do Python \xe9 s\xedncrono por padr\xe3o, embora ",(0,r.jsx)(n.code,{children:"asyncio"})," possa envolv\xea-lo. Para cargas de trabalho orientadas a I/O (ex.: servidores web lendo muitos arquivos), prefira ass\xedncrono para evitar bloqueio; para scripts ou ferramentas CLI, s\xedncrono geralmente \xe9 mais simples. Escolha uma linguagem que suporte seu modelo de concorr\xeancia \u2014 Node.js e C# s\xe3o async-first; Rust oferece ",(0,r.jsx)(n.code,{children:"tokio"})," para I/O de arquivo ass\xedncrono."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Padr\xf5es de limpeza de recursos diferem"})," \u2014 O ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," do Python e o ",(0,r.jsx)(n.code,{children:"using"}),"/try-with-resources do C#/Java, mais o RAII do Rust, garantem o fechamento mesmo em caso de erros. Go usa ",(0,r.jsx)(n.code,{children:"defer file.Close()"})," que executa quando a fun\xe7\xe3o retorna. C e Zig exigem ",(0,r.jsx)(n.code,{children:"fclose"})," ou ",(0,r.jsx)(n.code,{children:"file.close()"})," expl\xedcitos \u2014 se um erro ocorrer antes do close, o handle pode vazar. Prefira padr\xf5es baseados em bloco ou RAII quando dispon\xedveis; em C ou Zig, estruture o c\xf3digo para que todo ",(0,r.jsx)(n.code,{children:"open"})," tenha um ",(0,r.jsx)(n.code,{children:"close"})," correspondente no mesmo caminho de controle."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tratamento de encoding \xe9 expl\xedcito em algumas linguagens"})," \u2014 Python e Node.js aceitam ",(0,r.jsx)(n.code,{children:"encoding='utf-8'"})," ao ler texto; C# usa UTF-8 por padr\xe3o em APIs mais recentes. C e C++ tratam arquivos como bytes brutos; voc\xea deve usar bibliotecas ou convers\xe3o manual para UTF-8. Zig exp\xf5e APIs de bytes de baixo n\xedvel \u2014 ",(0,r.jsx)(n.code,{children:"readFileAlloc"})," retorna ",(0,r.jsx)(n.code,{children:"[]u8"}),", e voc\xea cuida da decodifica\xe7\xe3o de string. Para texto internacional, prefira Python, C# ou Java; para bin\xe1rio ou quando precisar de controle total, C/C++/Zig s\xe3o apropriados."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Helpers de alto n\xedvel vs controle manual"})," \u2014 C#, Python e Java oferecem ",(0,r.jsx)(n.code,{children:"File.ReadAllText"}),", ",(0,r.jsx)(n.code,{children:"Path('file.txt').read_text()"})," e ",(0,r.jsx)(n.code,{children:'Files.readString(Path.of("file.txt"))'})," para leituras em uma linha. C e Zig exigem aloca\xe7\xe3o manual de buffer, loops ",(0,r.jsx)(n.code,{children:"fread"}),"/",(0,r.jsx)(n.code,{children:"read"})," e termina\xe7\xe3o nula. APIs de alto n\xedvel s\xe3o convenientes mas podem carregar arquivos inteiros na mem\xf3ria; para arquivos grandes, use streaming (ex.: ",(0,r.jsx)(n.code,{children:"File.ReadLines"}),", ",(0,r.jsx)(n.code,{children:"BufferedReader"})," ou ",(0,r.jsx)(n.code,{children:"BufReader"})," do Rust). Escolha helpers para arquivos pequenos; use streams quando mem\xf3ria ou lat\xeancia importarem."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"APIs baseadas em bloco evitam vazamentos"})," \u2014 O ",(0,r.jsx)(n.code,{children:"File.open('file.txt') { |f| }"})," do Ruby e o ",(0,r.jsx)(n.code,{children:"with open('file.txt') as f:"})," do Python garantem o fechamento mesmo quando exce\xe7\xf5es ocorrem. ",(0,r.jsx)(n.code,{children:"fclose"})," expl\xedcito em C e PHP pode levar a vazamentos se um erro acontecer antes do close \u2014 ex.: um ",(0,r.jsx)(n.code,{children:"return"})," ou ",(0,r.jsx)(n.code,{children:"throw"})," no meio do processamento. Sempre prefira padr\xf5es baseados em bloco ou RAII quando dispon\xedveis; em C, considere usar ",(0,r.jsx)(n.code,{children:"goto"})," para um label de limpeza ou um padr\xe3o de wrapper m\xednimo para centralizar a l\xf3gica de close."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);